/*****************************************************************************\
*
*  Module Name    RadeonProRender.h
*  Project        AMD Radeon ProRender
*
*  Description    Radeon ProRender Interface header
*
*  Copyright(C) 2017-2021 Advanced Micro Devices, Inc. All rights reserved.
*
\*****************************************************************************/


// RadeonProRender_v2 is an improved Radeon ProRender header : stricter and more secured.
// RadeonProRender_v2.h and RadeonProRender.h can't be used together in the same project.
// For new projects we advise to only use RadeonProRender_v2.h.
// For existing projects, you can easily swith to V2 by defining RPR_API_USE_HEADER_V2.

#ifndef __RADEONPRORENDER_V2_H
#define __RADEONPRORENDER_V2_H

#if defined(__APPLE__)
#include "stddef.h"
#else
#include "cstddef"
#endif

#define RPR_API_ENTRY

#ifdef __cplusplus
extern "C" {
#endif

typedef char rpr_char;
typedef unsigned char rpr_uchar;
typedef int rpr_int;
typedef unsigned int rpr_uint;
typedef long int rpr_long;
typedef long unsigned int rpr_ulong;
typedef short int rpr_short;
typedef short unsigned int rpr_ushort;
typedef float rpr_float;
typedef double rpr_double;
typedef long long int rpr_longlong;
typedef int rpr_bool;
typedef rpr_uint rpr_bitfield;
typedef struct rpr_context_t { void*_; } * rpr_context;
typedef struct rpr_camera_t { void*_; } * rpr_camera;
typedef struct rpr_shape_t { void*_; } * rpr_shape;
typedef struct rpr_light_t { void*_; } * rpr_light;
typedef struct rpr_scene_t { void*_; } * rpr_scene;
typedef struct rpr_image_t { void*_; } * rpr_image;
typedef struct rpr_buffer_t { void*_; } * rpr_buffer;
typedef struct rpr_hetero_volume_t { void*_; } * rpr_hetero_volume;
typedef struct rpr_grid_t { void*_; } * rpr_grid;
typedef struct rpr_curve_t { void*_; } * rpr_curve;
typedef struct rpr_framebuffer_t { void*_; } * rpr_framebuffer;
typedef struct rpr_material_system_t { void*_; } * rpr_material_system;
typedef struct rpr_material_node_t { void*_; } * rpr_material_node;
typedef struct rpr_post_effect_t { void*_; } * rpr_post_effect;
typedef struct rpr_context_properties_t { void*_; } * rpr_context_properties;
typedef struct rpr_composite_t { void*_; } * rpr_composite;
typedef struct rpr_lut_t { void*_; } * rpr_lut;
typedef rpr_uint rpr_image_option;
typedef rpr_uint rpr_context_type;
typedef rpr_bitfield rpr_creation_flags;
typedef rpr_uint rpr_channel_order;
typedef rpr_uint rpr_channel_type;
typedef rpr_uint rpr_material_system_type;
typedef rpr_uint rpr_environment_override;


#define RPR_VERSION_MAJOR 3 
#define RPR_VERSION_MINOR 1 
#define RPR_VERSION_REVISION 6 
#define RPR_VERSION_BUILD 0x1f29f423 
#define RPR_VERSION_MAJOR_MINOR_REVISION 0x00300106 
#define RPR_API_VERSION RPR_VERSION_MAJOR_MINOR_REVISION 
#define RPR_API_VERSION_MINOR RPR_VERSION_BUILD 
#define RPR_OBJECT_NAME 0x777777 
#define RPR_OBJECT_UNIQUE_ID 0x777778 
#define RPR_OBJECT_CUSTOM_PTR 0x777779 
#define RPR_INSTANCE_PARENT_SHAPE 0x1601 
#define RPR_FALSE 0u
#define RPR_TRUE 1u
typedef enum // rpr_status
{
	RPR_SUCCESS = 0 ,
	RPR_ERROR_COMPUTE_API_NOT_SUPPORTED = -1 ,
	RPR_ERROR_OUT_OF_SYSTEM_MEMORY = -2 ,
	RPR_ERROR_OUT_OF_VIDEO_MEMORY = -3 ,
	RPR_ERROR_SHADER_COMPILATION = -4 ,
	RPR_ERROR_INVALID_LIGHTPATH_EXPR = -5 ,
	RPR_ERROR_INVALID_IMAGE = -6 ,
	RPR_ERROR_INVALID_AA_METHOD = -7 ,
	RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT = -8 ,
	RPR_ERROR_INVALID_GL_TEXTURE = -9 ,
	RPR_ERROR_INVALID_CL_IMAGE = -10 ,
	RPR_ERROR_INVALID_OBJECT = -11 ,
	RPR_ERROR_INVALID_PARAMETER = -12 ,
	RPR_ERROR_INVALID_TAG = -13 ,
	RPR_ERROR_INVALID_LIGHT = -14 ,
	RPR_ERROR_INVALID_CONTEXT = -15 ,
	RPR_ERROR_UNIMPLEMENTED = -16 ,
	RPR_ERROR_INVALID_API_VERSION = -17 ,
	RPR_ERROR_INTERNAL_ERROR = -18 ,
	RPR_ERROR_IO_ERROR = -19 ,
	RPR_ERROR_UNSUPPORTED_SHADER_PARAMETER_TYPE = -20 ,
	RPR_ERROR_MATERIAL_STACK_OVERFLOW = -21 ,
	RPR_ERROR_INVALID_PARAMETER_TYPE = -22 ,
	RPR_ERROR_UNSUPPORTED = -23 ,
	RPR_ERROR_OPENCL_OUT_OF_HOST_MEMORY = -24 ,
	RPR_ERROR_OPENGL = -25 ,
	RPR_ERROR_OPENCL = -26 ,
	RPR_ERROR_NULLPTR = -27 ,
	RPR_ERROR_NODETYPE = -28 ,
	RPR_ERROR_ABORTED = -29 ,
} rpr_status ;

typedef enum // rpr_parameter_type
{
	RPR_PARAMETER_TYPE_UNDEF = 0x0 ,
	RPR_PARAMETER_TYPE_FLOAT = 0x1 ,
	RPR_PARAMETER_TYPE_FLOAT2 = 0x2 ,
	RPR_PARAMETER_TYPE_FLOAT3 = 0x3 ,
	RPR_PARAMETER_TYPE_FLOAT4 = 0x4 ,
	RPR_PARAMETER_TYPE_IMAGE = 0x5 ,
	RPR_PARAMETER_TYPE_STRING = 0x6 ,
	RPR_PARAMETER_TYPE_SHADER = 0x7 ,
	RPR_PARAMETER_TYPE_UINT = 0x8 ,
	RPR_PARAMETER_TYPE_ULONG = 0x9 ,
	RPR_PARAMETER_TYPE_LONGLONG = 0xa ,
} rpr_parameter_type ;

enum rpr_creation_flags_t // rpr_creation_flags
{
	RPR_CREATION_FLAGS_ENABLE_GPU0 = (1 << 0) ,
	RPR_CREATION_FLAGS_ENABLE_GPU1 = (1 << 1) ,
	RPR_CREATION_FLAGS_ENABLE_GPU2 = (1 << 2) ,
	RPR_CREATION_FLAGS_ENABLE_GPU3 = (1 << 3) ,
	RPR_CREATION_FLAGS_ENABLE_CPU = (1 << 4) ,
	RPR_CREATION_FLAGS_ENABLE_GL_INTEROP = (1 << 5) ,
	RPR_CREATION_FLAGS_ENABLE_GPU4 = (1 << 6) ,
	RPR_CREATION_FLAGS_ENABLE_GPU5 = (1 << 7) ,
	RPR_CREATION_FLAGS_ENABLE_GPU6 = (1 << 8) ,
	RPR_CREATION_FLAGS_ENABLE_GPU7 = (1 << 9) ,
	RPR_CREATION_FLAGS_ENABLE_METAL = (1 << 10) ,
	RPR_CREATION_FLAGS_ENABLE_GPU8 = (1 << 11) ,
	RPR_CREATION_FLAGS_ENABLE_GPU9 = (1 << 12) ,
	RPR_CREATION_FLAGS_ENABLE_GPU10 = (1 << 13) ,
	RPR_CREATION_FLAGS_ENABLE_GPU11 = (1 << 14) ,
	RPR_CREATION_FLAGS_ENABLE_GPU12 = (1 << 15) ,
	RPR_CREATION_FLAGS_ENABLE_GPU13 = (1 << 16) ,
	RPR_CREATION_FLAGS_ENABLE_GPU14 = (1 << 17) ,
	RPR_CREATION_FLAGS_ENABLE_GPU15 = (1 << 18) ,
	RPR_CREATION_FLAGS_ENABLE_HIP = (1 << 19) ,
	RPR_CREATION_FLAGS_ENABLE_OPENCL = (1 << 20) ,
	RPR_CREATION_FLAGS_ENABLE_DEBUG = (1 << 31) ,
};

typedef enum // rpr_aa_filter
{
	RPR_FILTER_NONE = 0x0 ,
	RPR_FILTER_BOX = 0x1 ,
	RPR_FILTER_TRIANGLE = 0x2 ,
	RPR_FILTER_GAUSSIAN = 0x3 ,
	RPR_FILTER_MITCHELL = 0x4 ,
	RPR_FILTER_LANCZOS = 0x5 ,
	RPR_FILTER_BLACKMANHARRIS = 0x6 ,
} rpr_aa_filter ;

typedef enum // rpr_context_sampler_type
{
	RPR_CONTEXT_SAMPLER_TYPE_SOBOL = 0x1 ,
	RPR_CONTEXT_SAMPLER_TYPE_RANDOM = 0x2 ,
	RPR_CONTEXT_SAMPLER_TYPE_CMJ = 0x3 ,
} rpr_context_sampler_type ;

typedef enum // rpr_primvar_interpolation_type
{
	RPR_PRIMVAR_INTERPOLATION_CONSTANT = 0x1 ,
	RPR_PRIMVAR_INTERPOLATION_UNIFORM = 0x2 ,
	RPR_PRIMVAR_INTERPOLATION_VERTEX = 0x3 ,
	RPR_PRIMVAR_INTERPOLATION_FACEVARYING_NORMAL = 0x4 ,
	RPR_PRIMVAR_INTERPOLATION_FACEVARYING_UV = 0x5 ,
} rpr_primvar_interpolation_type ;

typedef enum // rpr_shape_type
{
	RPR_SHAPE_TYPE_MESH = 0x1 ,
	RPR_SHAPE_TYPE_INSTANCE = 0x2 ,
} rpr_shape_type ;

typedef enum // rpr_light_type
{
	RPR_LIGHT_TYPE_POINT = 0x1 ,
	RPR_LIGHT_TYPE_DIRECTIONAL = 0x2 ,
	RPR_LIGHT_TYPE_SPOT = 0x3 ,
	RPR_LIGHT_TYPE_ENVIRONMENT = 0x4 ,
	RPR_LIGHT_TYPE_SKY = 0x5 ,
	RPR_LIGHT_TYPE_IES = 0x6 ,
	RPR_LIGHT_TYPE_SPHERE = 0x7 ,
	RPR_LIGHT_TYPE_DISK = 0x8 ,
} rpr_light_type ;

typedef enum // rpr_context_info
{
	RPR_CONTEXT_CREATION_FLAGS = 0x102 ,
	RPR_CONTEXT_CACHE_PATH = 0x103 ,
	RPR_CONTEXT_RENDER_STATUS = 0x104 ,
	RPR_CONTEXT_RENDER_STATISTICS = 0x105 ,
	RPR_CONTEXT_DEVICE_COUNT = 0x106 ,
	RPR_CONTEXT_PARAMETER_COUNT = 0x107 ,
	RPR_CONTEXT_ACTIVE_PLUGIN = 0x108 ,
	RPR_CONTEXT_SCENE = 0x109 ,
	RPR_CONTEXT_ITERATIONS = 0x10B ,
	RPR_CONTEXT_IMAGE_FILTER_TYPE = 0x10C ,
	RPR_CONTEXT_TONE_MAPPING_TYPE = 0x113 ,
	RPR_CONTEXT_TONE_MAPPING_LINEAR_SCALE = 0x114 ,
	RPR_CONTEXT_TONE_MAPPING_PHOTO_LINEAR_SENSITIVITY = 0x115 ,
	RPR_CONTEXT_TONE_MAPPING_PHOTO_LINEAR_EXPOSURE = 0x116 ,
	RPR_CONTEXT_TONE_MAPPING_PHOTO_LINEAR_FSTOP = 0x117 ,
	RPR_CONTEXT_TONE_MAPPING_REINHARD02_PRE_SCALE = 0x118 ,
	RPR_CONTEXT_TONE_MAPPING_REINHARD02_POST_SCALE = 0x119 ,
	RPR_CONTEXT_TONE_MAPPING_REINHARD02_BURN = 0x11A ,
	RPR_CONTEXT_MAX_RECURSION = 0x11B ,
	RPR_CONTEXT_RAY_CAST_EPSILON = 0x11C ,
	RPR_CONTEXT_RADIANCE_CLAMP = 0x11D ,
	RPR_CONTEXT_X_FLIP = 0x11E ,
	RPR_CONTEXT_Y_FLIP = 0x11F ,
	RPR_CONTEXT_TEXTURE_GAMMA = 0x120 ,
	RPR_CONTEXT_PDF_THRESHOLD = 0x121 ,
	RPR_CONTEXT_RENDER_MODE = 0x122 ,
	RPR_CONTEXT_ROUGHNESS_CAP = 0x123 ,
	RPR_CONTEXT_DISPLAY_GAMMA = 0x124 ,
	RPR_CONTEXT_MATERIAL_STACK_SIZE = 0x125 ,
	RPR_CONTEXT_CUTTING_PLANES = 0x126 ,
	RPR_CONTEXT_GPU0_NAME = 0x127 ,
	RPR_CONTEXT_GPU1_NAME = 0x128 ,
	RPR_CONTEXT_GPU2_NAME = 0x129 ,
	RPR_CONTEXT_GPU3_NAME = 0x12A ,
	RPR_CONTEXT_CPU_NAME = 0x12B ,
	RPR_CONTEXT_GPU4_NAME = 0x12C ,
	RPR_CONTEXT_GPU5_NAME = 0x12D ,
	RPR_CONTEXT_GPU6_NAME = 0x12E ,
	RPR_CONTEXT_GPU7_NAME = 0x12F ,
	RPR_CONTEXT_TONE_MAPPING_EXPONENTIAL_INTENSITY = 0x130 ,
	RPR_CONTEXT_FRAMECOUNT = 0x131 ,
	RPR_CONTEXT_TEXTURE_COMPRESSION = 0x132 ,
	RPR_CONTEXT_AO_RAY_LENGTH = 0x133 ,
	RPR_CONTEXT_OOC_TEXTURE_CACHE = 0x134 ,
	RPR_CONTEXT_PREVIEW = 0x135 ,
	RPR_CONTEXT_CPU_THREAD_LIMIT = 0x136 ,
	RPR_CONTEXT_LAST_ERROR_MESSAGE = 0x137 ,
	RPR_CONTEXT_MAX_DEPTH_DIFFUSE = 0x138 ,
	RPR_CONTEXT_MAX_DEPTH_GLOSSY = 0x139 ,
	RPR_CONTEXT_OOC_CACHE_PATH = 0x13a ,
	RPR_CONTEXT_MAX_DEPTH_REFRACTION = 0x13B ,
	RPR_CONTEXT_MAX_DEPTH_GLOSSY_REFRACTION = 0x13C ,
	RPR_CONTEXT_RENDER_LAYER_MASK = 0x13D ,
	RPR_CONTEXT_SINGLE_LEVEL_BVH_ENABLED = 0x13E ,
	RPR_CONTEXT_TRANSPARENT_BACKGROUND = 0x13F ,
	RPR_CONTEXT_MAX_DEPTH_SHADOW = 0x140 ,
	RPR_CONTEXT_API_VERSION = 0x141 ,
	RPR_CONTEXT_GPU8_NAME = 0x142 ,
	RPR_CONTEXT_GPU9_NAME = 0x143 ,
	RPR_CONTEXT_GPU10_NAME = 0x144 ,
	RPR_CONTEXT_GPU11_NAME = 0x145 ,
	RPR_CONTEXT_GPU12_NAME = 0x146 ,
	RPR_CONTEXT_GPU13_NAME = 0x147 ,
	RPR_CONTEXT_GPU14_NAME = 0x148 ,
	RPR_CONTEXT_GPU15_NAME = 0x149 ,
	RPR_CONTEXT_API_VERSION_MINOR = 0x14A ,
	RPR_CONTEXT_METAL_PERFORMANCE_SHADER = 0x14B ,
	RPR_CONTEXT_USER_TEXTURE_0 = 0x14C ,
	RPR_CONTEXT_USER_TEXTURE_1 = 0x14D ,
	RPR_CONTEXT_USER_TEXTURE_2 = 0x14E ,
	RPR_CONTEXT_USER_TEXTURE_3 = 0x14F ,
	RPR_CONTEXT_MIPMAP_LOD_OFFSET = 0x150 ,
	RPR_CONTEXT_AO_RAY_COUNT = 0x151 ,
	RPR_CONTEXT_SAMPLER_TYPE = 0x152 ,
	RPR_CONTEXT_ADAPTIVE_SAMPLING_TILE_SIZE = 0x153 ,
	RPR_CONTEXT_ADAPTIVE_SAMPLING_MIN_SPP = 0x154 ,
	RPR_CONTEXT_ADAPTIVE_SAMPLING_THRESHOLD = 0x155 ,
	RPR_CONTEXT_TILE_SIZE = 0x156 ,
	RPR_CONTEXT_LIST_CREATED_CAMERAS = 0x157 ,
	RPR_CONTEXT_LIST_CREATED_MATERIALNODES = 0x158 ,
	RPR_CONTEXT_LIST_CREATED_LIGHTS = 0x159 ,
	RPR_CONTEXT_LIST_CREATED_SHAPES = 0x15A ,
	RPR_CONTEXT_LIST_CREATED_POSTEFFECTS = 0x15B ,
	RPR_CONTEXT_LIST_CREATED_HETEROVOLUMES = 0x15C ,
	RPR_CONTEXT_LIST_CREATED_GRIDS = 0x15D ,
	RPR_CONTEXT_LIST_CREATED_BUFFERS = 0x15E ,
	RPR_CONTEXT_LIST_CREATED_IMAGES = 0x15F ,
	RPR_CONTEXT_LIST_CREATED_FRAMEBUFFERS = 0x160 ,
	RPR_CONTEXT_LIST_CREATED_SCENES = 0x161 ,
	RPR_CONTEXT_LIST_CREATED_CURVES = 0x162 ,
	RPR_CONTEXT_LIST_CREATED_MATERIALSYSTEM = 0x163 ,
	RPR_CONTEXT_LIST_CREATED_COMPOSITE = 0x164 ,
	RPR_CONTEXT_LIST_CREATED_LUT = 0x165 ,
	RPR_CONTEXT_AA_ENABLED = 0x166 ,
	RPR_CONTEXT_ACTIVE_PIXEL_COUNT = 0x167 ,
	RPR_CONTEXT_TRACING_ENABLED = 0x168 ,
	RPR_CONTEXT_TRACING_PATH = 0x169 ,
	RPR_CONTEXT_TILE_RECT = 0x16A ,
	RPR_CONTEXT_PLUGIN_VERSION = 0x16B ,
	RPR_CONTEXT_RUSSIAN_ROULETTE_DEPTH = 0x16C ,
	RPR_CONTEXT_SHADOW_CATCHER_BAKING = 0x16D ,
	RPR_CONTEXT_RENDER_UPDATE_CALLBACK_FUNC = 0x16E ,
	RPR_CONTEXT_RENDER_UPDATE_CALLBACK_DATA = 0x16F ,
	RPR_CONTEXT_COMPILE_CALLBACK_FUNC = 0x601 ,
	RPR_CONTEXT_COMPILE_CALLBACK_DATA = 0x602 ,
	RPR_CONTEXT_TEXTURE_CACHE_PATH = 0x170 ,
	RPR_CONTEXT_OCIO_CONFIG_PATH = 0x171 ,
	RPR_CONTEXT_OCIO_RENDERING_COLOR_SPACE = 0x172 ,
	RPR_CONTEXT_CONTOUR_USE_OBJECTID = 0x173 ,
	RPR_CONTEXT_CONTOUR_USE_MATERIALID = 0x174 ,
	RPR_CONTEXT_CONTOUR_USE_NORMAL = 0x175 ,
	RPR_CONTEXT_CONTOUR_USE_UV = 0x186 ,
	RPR_CONTEXT_CONTOUR_NORMAL_THRESHOLD = 0x176 ,
	RPR_CONTEXT_CONTOUR_UV_THRESHOLD = 0x187 ,
	RPR_CONTEXT_CONTOUR_UV_SECONDARY = 0x194 ,
	RPR_CONTEXT_CONTOUR_LINEWIDTH_OBJECTID = 0x177 ,
	RPR_CONTEXT_CONTOUR_LINEWIDTH_MATERIALID = 0x178 ,
	RPR_CONTEXT_CONTOUR_LINEWIDTH_NORMAL = 0x179 ,
	RPR_CONTEXT_CONTOUR_LINEWIDTH_UV = 0x188 ,
	RPR_CONTEXT_CONTOUR_ANTIALIASING = 0x17A ,
	RPR_CONTEXT_CONTOUR_DEBUG_ENABLED = 0x17F ,
	RPR_CONTEXT_GPUINTEGRATOR = 0x17B ,
	RPR_CONTEXT_CPUINTEGRATOR = 0x17C ,
	RPR_CONTEXT_BEAUTY_MOTION_BLUR = 0x17D ,
	RPR_CONTEXT_CAUSTICS_REDUCTION = 0x17E ,
	RPR_CONTEXT_GPU_MEMORY_LIMIT = 0x180 ,
	RPR_CONTEXT_RENDER_LAYER_LIST = 0x181 ,
	RPR_CONTEXT_WINDING_ORDER_CORRECTION = 0x182 ,
	RPR_CONTEXT_DEEP_SUBPIXEL_MERGE_Z_THRESHOLD = 0x183 ,
	RPR_CONTEXT_DEEP_GPU_ALLOCATION_LEVEL = 0x184 ,
	RPR_CONTEXT_DEEP_COLOR_ENABLED = 0x185 ,
	RPR_CONTEXT_FOG_COLOR = 0x189 ,
	RPR_CONTEXT_FOG_DISTANCE = 0x18A ,
	RPR_CONTEXT_FOG_HEIGHT = 0x18B ,
	RPR_CONTEXT_ATMOSPHERE_VOLUME_COLOR = 0x18C ,
	RPR_CONTEXT_ATMOSPHERE_VOLUME_DENSITY = 0x18D ,
	RPR_CONTEXT_ATMOSPHERE_VOLUME_RADIANCE_CLAMP = 0x18F ,
	RPR_CONTEXT_FOG_HEIGHT_OFFSET = 0x18E ,
	RPR_CONTEXT_INDIRECT_DOWNSAMPLE = 0x190 ,
	RPR_CONTEXT_CRYPTOMATTE_EXTENDED = 0x191 ,
	RPR_CONTEXT_CRYPTOMATTE_SPLIT_INDIRECT = 0x192 ,
	RPR_CONTEXT_FOG_DIRECTION = 0x193 ,
	RPR_CONTEXT_RANDOM_SEED = 0x1000 ,
	RPR_CONTEXT_IBL_DISPLAY = 0x195 ,
	RPR_CONTEXT_FRAMEBUFFER_SAVE_FLOAT32 = 0x196 ,
	RPR_CONTEXT_UPDATE_TIME_CALLBACK_FUNC = 0x197 ,
	RPR_CONTEXT_UPDATE_TIME_CALLBACK_DATA = 0x198 ,
	RPR_CONTEXT_RENDER_TIME_CALLBACK_FUNC = 0x199 ,
	RPR_CONTEXT_RENDER_TIME_CALLBACK_DATA = 0x19A ,
	RPR_CONTEXT_FIRST_ITERATION_TIME_CALLBACK_FUNC = 0x19B ,
	RPR_CONTEXT_FIRST_ITERATION_TIME_CALLBACK_DATA = 0x19C ,
	RPR_CONTEXT_IMAGE_FILTER_RADIUS = 0x19D ,
	RPR_CONTEXT_PRECOMPILED_BINARY_PATH = 0x19E ,
	RPR_CONTEXT_REFLECTION_ENERGY_COMPENSATION_ENABLED = 0x19F ,
	RPR_CONTEXT_NORMALIZE_LIGHT_INTENSITY_ENABLED = 0x1A0 ,
	RPR_CONTEXT_NAME = RPR_OBJECT_NAME,
	RPR_CONTEXT_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_CONTEXT_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_context_info ;

typedef enum // rpr_camera_info
{
	RPR_CAMERA_TRANSFORM = 0x201 ,
	RPR_CAMERA_FSTOP = 0x202 ,
	RPR_CAMERA_APERTURE_BLADES = 0x203 ,
	RPR_CAMERA_RESPONSE = 0x204 ,
	RPR_CAMERA_EXPOSURE = 0x205 ,
	RPR_CAMERA_FOCAL_LENGTH = 0x206 ,
	RPR_CAMERA_SENSOR_SIZE = 0x207 ,
	RPR_CAMERA_MODE = 0x208 ,
	RPR_CAMERA_ORTHO_WIDTH = 0x209 ,
	RPR_CAMERA_ORTHO_HEIGHT = 0x20A ,
	RPR_CAMERA_FOCUS_DISTANCE = 0x20B ,
	RPR_CAMERA_POSITION = 0x20C ,
	RPR_CAMERA_LOOKAT = 0x20D ,
	RPR_CAMERA_UP = 0x20E ,
	RPR_CAMERA_FOCAL_TILT = 0x20F ,
	RPR_CAMERA_LENS_SHIFT = 0x210 ,
	RPR_CAMERA_IPD = 0x211 ,
	RPR_CAMERA_TILT_CORRECTION = 0x212 ,
	RPR_CAMERA_NEAR_PLANE = 0x213 ,
	RPR_CAMERA_FAR_PLANE = 0x214 ,
	RPR_CAMERA_LINEAR_MOTION = 0x215 ,
	RPR_CAMERA_ANGULAR_MOTION = 0x216 ,
	RPR_CAMERA_MOTION_TRANSFORMS_COUNT = 0x217 ,
	RPR_CAMERA_MOTION_TRANSFORMS = 0x218 ,
	RPR_CAMERA_POST_SCALE = 0x219 ,
	RPR_CAMERA_UV_DISTORTION = 0x21A ,
	RPR_CAMERA_NAME = RPR_OBJECT_NAME,
	RPR_CAMERA_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_CAMERA_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_camera_info ;

typedef enum // rpr_image_info
{
	RPR_IMAGE_FORMAT = 0x301 ,
	RPR_IMAGE_DESC = 0x302 ,
	RPR_IMAGE_DATA = 0x303 ,
	RPR_IMAGE_DATA_SIZEBYTE = 0x304 ,
	RPR_IMAGE_WRAP = 0x305 ,
	RPR_IMAGE_FILTER = 0x306 ,
	RPR_IMAGE_GAMMA = 0x307 ,
	RPR_IMAGE_MIPMAP_ENABLED = 0x308 ,
	RPR_IMAGE_MIP_COUNT = 0x309 ,
	RPR_IMAGE_GAMMA_FROM_FILE = 0x30A ,
	RPR_IMAGE_UDIM = 0x30B ,
	RPR_IMAGE_OCIO_COLORSPACE = 0x30C ,
	RPR_IMAGE_INTERNAL_COMPRESSION = 0x30D ,
	RPR_IMAGE_NAME = RPR_OBJECT_NAME,
	RPR_IMAGE_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_IMAGE_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_image_info ;

typedef enum // rpr_buffer_info
{
	RPR_BUFFER_DESC = 0x350 ,
	RPR_BUFFER_DATA = 0x351 ,
	RPR_BUFFER_NAME = RPR_OBJECT_NAME,
	RPR_BUFFER_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_BUFFER_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_buffer_info ;

typedef enum // rpr_shape_info
{
	RPR_SHAPE_TYPE = 0x401 ,
	RPR_SHAPE_VIDMEM_USAGE = 0x402 ,
	RPR_SHAPE_TRANSFORM = 0x403 ,
	RPR_SHAPE_MATERIAL = 0x404 ,
	RPR_SHAPE_LINEAR_MOTION = 0x405 ,
	RPR_SHAPE_ANGULAR_MOTION = 0x406 ,
	RPR_SHAPE_SHADOW_FLAG = 0x408,
	RPR_SHAPE_SUBDIVISION_FACTOR = 0x409 ,
	RPR_SHAPE_DISPLACEMENT_SCALE = 0x40A ,
	RPR_SHAPE_SHADOW_CATCHER_FLAG = 0x40E ,
	RPR_SHAPE_VOLUME_MATERIAL = 0x40F ,
	RPR_SHAPE_OBJECT_GROUP_ID = 0x410 ,
	RPR_SHAPE_SUBDIVISION_CREASEWEIGHT = 0x411 ,
	RPR_SHAPE_SUBDIVISION_BOUNDARYINTEROP = 0x412 ,
	RPR_SHAPE_DISPLACEMENT_MATERIAL = 0x413 ,
	RPR_SHAPE_MATERIALS_PER_FACE = 0x415 ,
	RPR_SHAPE_SCALE_MOTION = 0x416 ,
	RPR_SHAPE_HETERO_VOLUME = 0x417 ,
	RPR_SHAPE_LAYER_MASK = 0x418 ,
	RPR_SHAPE_VISIBILITY_PRIMARY_ONLY_FLAG = 0x40C ,
	RPR_SHAPE_VISIBILITY_SHADOW = 0x41A ,
	RPR_SHAPE_VISIBILITY_REFLECTION = 0x41B ,
	RPR_SHAPE_VISIBILITY_REFRACTION = 0x41C ,
	RPR_SHAPE_VISIBILITY_TRANSPARENT = 0x41D ,
	RPR_SHAPE_VISIBILITY_DIFFUSE = 0x41E ,
	RPR_SHAPE_VISIBILITY_GLOSSY_REFLECTION = 0x41F ,
	RPR_SHAPE_VISIBILITY_GLOSSY_REFRACTION = 0x420 ,
	RPR_SHAPE_VISIBILITY_LIGHT = 0x421 ,
	RPR_SHAPE_LIGHT_GROUP_ID = 0x422 ,
	RPR_SHAPE_STATIC = 0x423,
	RPR_SHAPE_PER_VERTEX_VALUE0 = 0x424,
	RPR_SHAPE_PER_VERTEX_VALUE1 = 0x425,
	RPR_SHAPE_PER_VERTEX_VALUE2 = 0x426,
	RPR_SHAPE_PER_VERTEX_VALUE3 = 0x427,
	RPR_SHAPE_REFLECTION_CATCHER_FLAG = 0x428 ,
	RPR_SHAPE_OBJECT_ID = 0x429 ,
	RPR_SHAPE_SUBDIVISION_AUTO_RATIO_CAP = 0x42A ,
	RPR_SHAPE_MOTION_TRANSFORMS_COUNT = 0x42B ,
	RPR_SHAPE_MOTION_TRANSFORMS = 0x42C ,
	RPR_SHAPE_CONTOUR_IGNORE = 0x42D ,
	RPR_SHAPE_RENDER_LAYER_LIST = 0x42E ,
	RPR_SHAPE_SHADOW_COLOR = 0x42F ,
	RPR_SHAPE_VISIBILITY_RECEIVE_SHADOW = 0x430 ,
	RPR_SHAPE_PRIMVARS = 0x431,
	RPR_SHAPE_ENVIRONMENT_LIGHT = 0x432,
	RPR_SHAPE_NAME = RPR_OBJECT_NAME,
	RPR_SHAPE_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_SHAPE_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_shape_info ;

typedef enum // rpr_mesh_info
{
	RPR_MESH_POLYGON_COUNT = 0x501 ,
	RPR_MESH_VERTEX_COUNT = 0x502 ,
	RPR_MESH_NORMAL_COUNT = 0x503 ,
	RPR_MESH_UV_COUNT = 0x504 ,
	RPR_MESH_VERTEX_ARRAY = 0x505 ,
	RPR_MESH_NORMAL_ARRAY = 0x506 ,
	RPR_MESH_UV_ARRAY = 0x507 ,
	RPR_MESH_VERTEX_INDEX_ARRAY = 0x508 ,
	RPR_MESH_NORMAL_INDEX_ARRAY = 0x509 ,
	RPR_MESH_UV_INDEX_ARRAY = 0x50A ,
	RPR_MESH_VERTEX_STRIDE = 0x50C ,
	RPR_MESH_NORMAL_STRIDE = 0x50D ,
	RPR_MESH_UV_STRIDE = 0x50E ,
	RPR_MESH_VERTEX_INDEX_STRIDE = 0x50F ,
	RPR_MESH_NORMAL_INDEX_STRIDE = 0x510 ,
	RPR_MESH_UV_INDEX_STRIDE = 0x511 ,
	RPR_MESH_NUM_FACE_VERTICES_ARRAY = 0x512 ,
	RPR_MESH_UV2_COUNT = 0x513 ,
	RPR_MESH_UV2_ARRAY = 0x514 ,
	RPR_MESH_UV2_INDEX_ARRAY = 0x515 ,
	RPR_MESH_UV2_STRIDE = 0x516 ,
	RPR_MESH_UV2_INDEX_STRIDE = 0x517 ,
	RPR_MESH_UV_DIM = 0x518 ,
	RPR_MESH_MOTION_DIMENSION = 0x519 ,
	RPR_MESH_VOLUME_FLAG = 0x51A ,
} rpr_mesh_info ;

typedef enum // rpr_scene_info
{
	RPR_SCENE_SHAPE_COUNT = 0x701 ,
	RPR_SCENE_LIGHT_COUNT = 0x702 ,
	RPR_SCENE_SHAPE_LIST = 0x704 ,
	RPR_SCENE_LIGHT_LIST = 0x705 ,
	RPR_SCENE_CAMERA = 0x706 ,
	RPR_SCENE_CAMERA_RIGHT = 0x707 ,
	RPR_SCENE_BACKGROUND_IMAGE = 0x708 ,
	RPR_SCENE_AABB = 0x70D ,
	RPR_SCENE_HETEROVOLUME_LIST = 0x70E ,
	RPR_SCENE_HETEROVOLUME_COUNT = 0x70F ,
	RPR_SCENE_CURVE_LIST = 0x710 ,
	RPR_SCENE_CURVE_COUNT = 0x711 ,
	RPR_SCENE_ENVIRONMENT_LIGHT = 0x712 ,
	RPR_SCENE_NAME = RPR_OBJECT_NAME,
	RPR_SCENE_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_SCENE_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_scene_info ;

typedef enum // rpr_lut_info
{
	RPR_LUT_FILENAME = 0x850 ,
	RPR_LUT_DATA = 0x851 ,
} rpr_lut_info ;

typedef enum // rpr_light_info
{
	RPR_LIGHT_TYPE = 0x801 ,
	RPR_LIGHT_TRANSFORM = 0x803 ,
	RPR_LIGHT_GROUP_ID = 0x805 ,
	RPR_LIGHT_RENDER_LAYER_LIST = 0x806 ,
	RPR_LIGHT_VISIBILITY_LIGHT = 0x807 ,
	RPR_LIGHT_NAME = RPR_OBJECT_NAME,
	RPR_LIGHT_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_LIGHT_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
/* rpr_light_info - point light */
	RPR_POINT_LIGHT_RADIANT_POWER = 0x804 ,
/* rpr_light_info - directional light */
	RPR_DIRECTIONAL_LIGHT_RADIANT_POWER = 0x808 ,
	RPR_DIRECTIONAL_LIGHT_SHADOW_SOFTNESS_ANGLE = 0x80A ,
/* rpr_light_info - spot light */
	RPR_SPOT_LIGHT_RADIANT_POWER = 0x80B ,
	RPR_SPOT_LIGHT_CONE_SHAPE = 0x80C ,
	RPR_SPOT_LIGHT_IMAGE = 0x80D ,
/* rpr_light_info - environment light */
	RPR_ENVIRONMENT_LIGHT_IMAGE = 0x80F ,
	RPR_ENVIRONMENT_LIGHT_INTENSITY_SCALE = 0x810 ,
	RPR_ENVIRONMENT_LIGHT_PORTAL_LIST = 0x818 ,
	RPR_ENVIRONMENT_LIGHT_PORTAL_COUNT = 0x819 ,
	RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFLECTION = 0x81A ,
	RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFRACTION = 0x81B ,
	RPR_ENVIRONMENT_LIGHT_OVERRIDE_TRANSPARENCY = 0x81C ,
	RPR_ENVIRONMENT_LIGHT_OVERRIDE_BACKGROUND = 0x81D ,
	RPR_ENVIRONMENT_LIGHT_OVERRIDE_IRRADIANCE = 0x81E ,
/* rpr_light_info - sky light */
	RPR_SKY_LIGHT_TURBIDITY = 0x812 ,
	RPR_SKY_LIGHT_ALBEDO = 0x813 ,
	RPR_SKY_LIGHT_SCALE = 0x814 ,
	RPR_SKY_LIGHT_DIRECTION = 0x815 ,
	RPR_SKY_LIGHT_PORTAL_LIST = 0x820 ,
	RPR_SKY_LIGHT_PORTAL_COUNT = 0x821 ,
/* rpr_light_info - IES light */
	RPR_IES_LIGHT_RADIANT_POWER = 0x816 ,
	RPR_IES_LIGHT_IMAGE_DESC = 0x817 ,
/* rpr_light_info - sphere light */
	RPR_SPHERE_LIGHT_RADIANT_POWER = 0x822 ,
	RPR_SPHERE_LIGHT_RADIUS = 0x824 ,
/* rpr_light_info - disk light */
	RPR_DISK_LIGHT_RADIANT_POWER = 0x823 ,
	RPR_DISK_LIGHT_RADIUS = 0x825 ,
	RPR_DISK_LIGHT_ANGLE = 0x826 ,
	RPR_DISK_LIGHT_INNER_ANGLE = 0x827 ,
} rpr_light_info ;

typedef enum // rpr_parameter_info
{
	RPR_PARAMETER_NAME = 0x1201 ,
	RPR_PARAMETER_TYPE = 0x1203 ,
	RPR_PARAMETER_DESCRIPTION = 0x1204 ,
	RPR_PARAMETER_VALUE = 0x1205 ,
} rpr_parameter_info ;

typedef enum // rpr_framebuffer_info
{
	RPR_FRAMEBUFFER_FORMAT = 0x1301 ,
	RPR_FRAMEBUFFER_DESC = 0x1302 ,
	RPR_FRAMEBUFFER_DATA = 0x1303 ,
	RPR_FRAMEBUFFER_GL_TARGET = 0x1304 ,
	RPR_FRAMEBUFFER_GL_MIPLEVEL = 0x1305 ,
	RPR_FRAMEBUFFER_GL_TEXTURE = 0x1306 ,
	RPR_FRAMEBUFFER_LPE = 0x1307 ,
	RPR_FRAMEBUFFER_NAME = RPR_OBJECT_NAME,
	RPR_FRAMEBUFFER_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_FRAMEBUFFER_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_framebuffer_info ;

typedef enum // rpr_component_type
{
	RPR_COMPONENT_TYPE_UINT8 = 0x1 ,
	RPR_COMPONENT_TYPE_FLOAT16 = 0x2,
	RPR_COMPONENT_TYPE_FLOAT32 = 0x3,
	RPR_COMPONENT_TYPE_UNKNOWN = 0x4,
	RPR_COMPONENT_TYPE_DEEP = 0x5,
	RPR_COMPONENT_TYPE_UINT32 = 0x6,
} rpr_component_type ;

typedef enum // rpr_buffer_element_type
{
	RPR_BUFFER_ELEMENT_TYPE_INT32 = 0x1 ,
	RPR_BUFFER_ELEMENT_TYPE_FLOAT32 = 0x2 ,
} rpr_buffer_element_type ;

typedef enum // rpr_render_mode
{
	RPR_RENDER_MODE_GLOBAL_ILLUMINATION = 0x1 ,
	RPR_RENDER_MODE_DIRECT_ILLUMINATION = 0x2 ,
	RPR_RENDER_MODE_DIRECT_ILLUMINATION_NO_SHADOW = 0x3 ,
	RPR_RENDER_MODE_WIREFRAME = 0x4 ,
	RPR_RENDER_MODE_MATERIAL_INDEX = 0x5 ,
	RPR_RENDER_MODE_POSITION = 0x6 ,
	RPR_RENDER_MODE_NORMAL = 0x7 ,
	RPR_RENDER_MODE_TEXCOORD = 0x8 ,
	RPR_RENDER_MODE_AMBIENT_OCCLUSION = 0x9 ,
	RPR_RENDER_MODE_DIFFUSE = 0x0a ,
} rpr_render_mode ;

typedef enum // rpr_camera_mode
{
	RPR_CAMERA_MODE_PERSPECTIVE = 0x1 ,
	RPR_CAMERA_MODE_ORTHOGRAPHIC = 0x2 ,
	RPR_CAMERA_MODE_LATITUDE_LONGITUDE_360 = 0x3 ,
	RPR_CAMERA_MODE_LATITUDE_LONGITUDE_STEREO = 0x4 ,
	RPR_CAMERA_MODE_CUBEMAP = 0x5 ,
	RPR_CAMERA_MODE_CUBEMAP_STEREO = 0x6 ,
	RPR_CAMERA_MODE_FISHEYE = 0x7 ,
} rpr_camera_mode ;

typedef enum // rpr_tonemapping_operator
{
	RPR_TONEMAPPING_OPERATOR_NONE = 0x0 ,
	RPR_TONEMAPPING_OPERATOR_LINEAR = 0x1 ,
	RPR_TONEMAPPING_OPERATOR_PHOTOLINEAR = 0x2 ,
	RPR_TONEMAPPING_OPERATOR_AUTOLINEAR = 0x3 ,
	RPR_TONEMAPPING_OPERATOR_MAXWHITE = 0x4 ,
	RPR_TONEMAPPING_OPERATOR_REINHARD02 = 0x5 ,
	RPR_TONEMAPPING_OPERATOR_EXPONENTIAL = 0x6 ,
} rpr_tonemapping_operator ;

typedef enum // rpr_volume_type
{
	RPR_VOLUME_TYPE_NONE = 0xFFFF ,
	RPR_VOLUME_TYPE_HOMOGENEOUS = 0x0 ,
	RPR_VOLUME_TYPE_HETEROGENEOUS = 0x1 ,
} rpr_volume_type ;

typedef enum // rpr_material_system_info
{
	RPR_MATERIAL_SYSTEM_NODE_LIST = 0x1100,
} rpr_material_system_info ;

typedef enum // rpr_material_node_info
{
	RPR_MATERIAL_NODE_TYPE = 0x1101 ,
	RPR_MATERIAL_NODE_SYSTEM = 0x1102 ,
	RPR_MATERIAL_NODE_INPUT_COUNT = 0x1103 ,
	RPR_MATERIAL_NODE_ID = 0x1104 ,
	RPR_MATERIAL_NODE_NAME = RPR_OBJECT_NAME,
	RPR_MATERIAL_NODE_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_MATERIAL_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_material_node_info ;

typedef enum // rpr_material_node_input_info
{
	RPR_MATERIAL_NODE_INPUT_NAME = 0x1103 ,
	RPR_MATERIAL_NODE_INPUT_DESCRIPTION = 0x1105 ,
	RPR_MATERIAL_NODE_INPUT_VALUE = 0x1106 ,
	RPR_MATERIAL_NODE_INPUT_TYPE = 0x1107 ,
} rpr_material_node_input_info ;

typedef enum // rpr_material_node_type
{
	RPR_MATERIAL_NODE_DIFFUSE = 0x1 ,
	RPR_MATERIAL_NODE_MICROFACET = 0x2 ,
	RPR_MATERIAL_NODE_REFLECTION = 0x3 ,
	RPR_MATERIAL_NODE_REFRACTION = 0x4 ,
	RPR_MATERIAL_NODE_MICROFACET_REFRACTION = 0x5 ,
	RPR_MATERIAL_NODE_TRANSPARENT = 0x6 ,
	RPR_MATERIAL_NODE_EMISSIVE = 0x7 ,
	RPR_MATERIAL_NODE_WARD = 0x8 ,
	RPR_MATERIAL_NODE_ADD = 0x9 ,
	RPR_MATERIAL_NODE_BLEND = 0xA ,
	RPR_MATERIAL_NODE_ARITHMETIC = 0xB ,
	RPR_MATERIAL_NODE_FRESNEL = 0xC ,
	RPR_MATERIAL_NODE_NORMAL_MAP = 0xD ,
	RPR_MATERIAL_NODE_IMAGE_TEXTURE = 0xE ,
	RPR_MATERIAL_NODE_NOISE2D_TEXTURE = 0xF ,
	RPR_MATERIAL_NODE_DOT_TEXTURE = 0x10 ,
	RPR_MATERIAL_NODE_GRADIENT_TEXTURE = 0x11 ,
	RPR_MATERIAL_NODE_CHECKER_TEXTURE = 0x12 ,
	RPR_MATERIAL_NODE_CONSTANT_TEXTURE = 0x13 ,
	RPR_MATERIAL_NODE_INPUT_LOOKUP = 0x14 ,
	RPR_MATERIAL_NODE_BLEND_VALUE = 0x16 ,
	RPR_MATERIAL_NODE_PASSTHROUGH = 0x17 ,
	RPR_MATERIAL_NODE_ORENNAYAR = 0x18 ,
	RPR_MATERIAL_NODE_FRESNEL_SCHLICK = 0x19 ,
	RPR_MATERIAL_NODE_DIFFUSE_REFRACTION = 0x1B ,
	RPR_MATERIAL_NODE_BUMP_MAP = 0x1C ,
	RPR_MATERIAL_NODE_VOLUME = 0x1D ,
	RPR_MATERIAL_NODE_MICROFACET_ANISOTROPIC_REFLECTION = 0x1E ,
	RPR_MATERIAL_NODE_MICROFACET_ANISOTROPIC_REFRACTION = 0x1F ,
	RPR_MATERIAL_NODE_TWOSIDED = 0x20 ,
	RPR_MATERIAL_NODE_UV_PROCEDURAL = 0x21 ,
	RPR_MATERIAL_NODE_MICROFACET_BECKMANN = 0x22 ,
	RPR_MATERIAL_NODE_PHONG = 0x23 ,
	RPR_MATERIAL_NODE_BUFFER_SAMPLER = 0x24 ,
	RPR_MATERIAL_NODE_UV_TRIPLANAR = 0x25 ,
	RPR_MATERIAL_NODE_AO_MAP = 0x26 ,
	RPR_MATERIAL_NODE_USER_TEXTURE_0 = 0x27 ,
	RPR_MATERIAL_NODE_USER_TEXTURE_1 = 0x28 ,
	RPR_MATERIAL_NODE_USER_TEXTURE_2 = 0x29 ,
	RPR_MATERIAL_NODE_USER_TEXTURE_3 = 0x2a ,
	RPR_MATERIAL_NODE_UBERV2 = 0x2b,
	RPR_MATERIAL_NODE_TRANSFORM = 0x2c,
	RPR_MATERIAL_NODE_RGB_TO_HSV = 0x2d,
	RPR_MATERIAL_NODE_HSV_TO_RGB = 0x2e,
	RPR_MATERIAL_NODE_USER_TEXTURE = 0x2f,
	RPR_MATERIAL_NODE_TOON_CLOSURE = 0x30,
	RPR_MATERIAL_NODE_TOON_RAMP = 0x31,
	RPR_MATERIAL_NODE_VORONOI_TEXTURE = 0x32 ,
	RPR_MATERIAL_NODE_GRID_SAMPLER = 0x33 ,
	RPR_MATERIAL_NODE_BLACKBODY = 0x34 ,
	RPR_MATERIAL_NODE_RAMP = 0x35 ,
	RPR_MATERIAL_NODE_PRIMVAR_LOOKUP = 0x36 ,
	RPR_MATERIAL_NODE_ROUNDED_CORNER = 0x37 ,

	// MaterialX materials
	RPR_MATERIAL_NODE_MATX_DIFFUSE_BRDF = 0x1000,
	RPR_MATERIAL_NODE_MATX_DIELECTRIC_BRDF = 0x1001,
	RPR_MATERIAL_NODE_MATX_GENERALIZED_SCHLICK_BRDF = 0x1002,
	RPR_MATERIAL_NODE_MATX_NOISE3D = 0x1003,
	RPR_MATERIAL_NODE_MATX_TANGENT = 0x1004,
	RPR_MATERIAL_NODE_MATX_NORMAL = 0x1005,
	RPR_MATERIAL_NODE_MATX_POSITION = 0x1006,
	RPR_MATERIAL_NODE_MATX_ROUGHNESS_ANISOTROPY = 0x1007,
	RPR_MATERIAL_NODE_MATX_ROTATE3D = 0x1008,
	RPR_MATERIAL_NODE_MATX_NORMALIZE = 0x1009,
	RPR_MATERIAL_NODE_MATX_IFGREATER = 0x100A,
	RPR_MATERIAL_NODE_MATX_SHEEN_BRDF = 0x100B,
	RPR_MATERIAL_NODE_MATX_DIFFUSE_BTDF = 0x100C,
	RPR_MATERIAL_NODE_MATX_CONVERT = 0x100D,
	RPR_MATERIAL_NODE_MATX_SUBSURFACE_BRDF = 0x100E,
	RPR_MATERIAL_NODE_MATX_DIELECTRIC_BTDF = 0x100F,
	RPR_MATERIAL_NODE_MATX_CONDUCTOR_BRDF = 0x1010,
	RPR_MATERIAL_NODE_MATX_FRESNEL = 0x1011,
	RPR_MATERIAL_NODE_MATX_LUMINANCE = 0x1012,
	RPR_MATERIAL_NODE_MATX_FRACTAL3D = 0x1013,
	RPR_MATERIAL_NODE_MATX_MIX = 0x1014,
	RPR_MATERIAL_NODE_MATX = 0x1015,
	RPR_MATERIAL_NODE_MATX_ARTISTIC_IOR = 0x1016,
	RPR_MATERIAL_NODE_MATX_GENERALIZED_SCHLICK_BTDF = 0x1017,
	RPR_MATERIAL_NODE_MATX_LAYER = 0x1018,
	RPR_MATERIAL_NODE_MATX_THIN_FILM = 0x1019,
	RPR_MATERIAL_NODE_MATX_BITANGENT = 0x101A,
	RPR_MATERIAL_NODE_MATX_TEXCOORD = 0x101B,
	RPR_MATERIAL_NODE_MATX_MODULO = 0x101C,
	RPR_MATERIAL_NODE_MATX_ABSVAL = 0x101D,
	RPR_MATERIAL_NODE_MATX_SIGN = 0x101E,
	RPR_MATERIAL_NODE_MATX_FLOOR = 0x101F,
	RPR_MATERIAL_NODE_MATX_CEIL = 0x1020,
	RPR_MATERIAL_NODE_MATX_ATAN2 = 0x1021,
	RPR_MATERIAL_NODE_MATX_SQRT = 0x1022,
	RPR_MATERIAL_NODE_MATX_LN = 0x1023,
	RPR_MATERIAL_NODE_MATX_EXP = 0x1024,
	RPR_MATERIAL_NODE_MATX_CLAMP = 0x1025,
	RPR_MATERIAL_NODE_MATX_MIN = 0x1026,
	RPR_MATERIAL_NODE_MATX_MAX = 0x1027,
	RPR_MATERIAL_NODE_MATX_MAGNITUDE = 0x1028,
	RPR_MATERIAL_NODE_MATX_CROSSPRODUCT = 0x1029,
	RPR_MATERIAL_NODE_MATX_REMAP = 0x102A,
	RPR_MATERIAL_NODE_MATX_SMOOTHSTEP = 0x102B,
	RPR_MATERIAL_NODE_MATX_RGBTOHSV = 0x102C,
	RPR_MATERIAL_NODE_MATX_HSVTORGB = 0x102D,
	RPR_MATERIAL_NODE_MATX_IFGREATEREQ = 0x102E,
	RPR_MATERIAL_NODE_MATX_IFEQUAL = 0x102F,
	RPR_MATERIAL_NODE_MATX_SWIZZLE = 0x1030,
	RPR_MATERIAL_NODE_MATX_NOISE2D = 0x1031,
	RPR_MATERIAL_NODE_MATX_PLUS = 0x1032,
	RPR_MATERIAL_NODE_MATX_MINUS = 0x1033,
	RPR_MATERIAL_NODE_MATX_DIFFERENCE = 0x1034,
	RPR_MATERIAL_NODE_MATX_BURN = 0x1035,
	RPR_MATERIAL_NODE_MATX_DODGE = 0x1036,
	RPR_MATERIAL_NODE_MATX_SCREEN = 0x1037,
	RPR_MATERIAL_NODE_MATX_OVERLAY = 0x1038,
	RPR_MATERIAL_NODE_MATX_INSIDE = 0x1039,
	RPR_MATERIAL_NODE_MATX_OUTSIDE = 0x103A,
	RPR_MATERIAL_NODE_MATX_RAMPLR = 0x103B,
	RPR_MATERIAL_NODE_MATX_RAMPTB = 0x103C,
	RPR_MATERIAL_NODE_MATX_SPLITLR = 0x103D,
	RPR_MATERIAL_NODE_MATX_SPLITTB = 0x103E,
	RPR_MATERIAL_NODE_MATX_CELLNOISE2D = 0x103F,
	RPR_MATERIAL_NODE_MATX_CELLNOISE3D = 0x1040,
	RPR_MATERIAL_NODE_MATX_ROTATE2D = 0x1041,
	RPR_MATERIAL_NODE_MATX_DOT = 0x1042,
	RPR_MATERIAL_NODE_MATX_RANGE = 0x1043,
	RPR_MATERIAL_NODE_MATX_SWITCH = 0x1044,
	RPR_MATERIAL_NODE_MATX_EXTRACT = 0x1045,
	RPR_MATERIAL_NODE_MATX_COMBINE2 = 0x1046,
	RPR_MATERIAL_NODE_MATX_COMBINE3 = 0x1047,
	RPR_MATERIAL_NODE_MATX_COMBINE4 = 0x1048,
	RPR_MATERIAL_NODE_MATX_TRIPLANARPROJECTION = 0x1049,
	RPR_MATERIAL_NODE_MATX_MULTIPLY = 0x104A,
} rpr_material_node_type ;

typedef enum // rpr_material_node_input
{
	RPR_MATERIAL_INPUT_COLOR = 0x0 ,
	RPR_MATERIAL_INPUT_COLOR0 = 0x1 ,
	RPR_MATERIAL_INPUT_COLOR1 = 0x2 ,
	RPR_MATERIAL_INPUT_NORMAL = 0x3 ,
	RPR_MATERIAL_INPUT_UV = 0x4 ,
	RPR_MATERIAL_INPUT_DATA = 0x5 ,
	RPR_MATERIAL_INPUT_ROUGHNESS = 0x6 ,
	RPR_MATERIAL_INPUT_IOR = 0x7 ,
	RPR_MATERIAL_INPUT_ROUGHNESS_X = 0x8 ,
	RPR_MATERIAL_INPUT_ROUGHNESS_Y = 0x9 ,
	RPR_MATERIAL_INPUT_ROTATION = 0xA ,
	RPR_MATERIAL_INPUT_WEIGHT = 0xB ,
	RPR_MATERIAL_INPUT_OP = 0xC ,
	RPR_MATERIAL_INPUT_INVEC = 0xD ,
	RPR_MATERIAL_INPUT_UV_SCALE = 0xE ,
	RPR_MATERIAL_INPUT_VALUE = 0xF ,
	RPR_MATERIAL_INPUT_REFLECTANCE = 0x10 ,
	RPR_MATERIAL_INPUT_SCALE = 0x11 ,
	RPR_MATERIAL_INPUT_SCATTERING = 0x12 ,
	RPR_MATERIAL_INPUT_ABSORBTION = 0x13 ,
	RPR_MATERIAL_INPUT_EMISSION = 0x14 ,
	RPR_MATERIAL_INPUT_G = 0x15 ,
	RPR_MATERIAL_INPUT_MULTISCATTER = 0x16 ,
	RPR_MATERIAL_INPUT_COLOR2 = 0x17 ,
	RPR_MATERIAL_INPUT_COLOR3 = 0x18 ,
	RPR_MATERIAL_INPUT_ANISOTROPIC = 0x19 ,
	RPR_MATERIAL_INPUT_FRONTFACE = 0x1a ,
	RPR_MATERIAL_INPUT_BACKFACE = 0x1b ,
	RPR_MATERIAL_INPUT_ORIGIN = 0x1c ,
	RPR_MATERIAL_INPUT_ZAXIS = 0x1d ,
	RPR_MATERIAL_INPUT_XAXIS = 0x1e ,
	RPR_MATERIAL_INPUT_THRESHOLD = 0x1f ,
	RPR_MATERIAL_INPUT_OFFSET = 0x20 ,
	RPR_MATERIAL_INPUT_UV_TYPE = 0x21 ,
	RPR_MATERIAL_INPUT_RADIUS = 0x22 ,
	RPR_MATERIAL_INPUT_SIDE = 0x23 ,
	RPR_MATERIAL_INPUT_CAUSTICS = 0x24 ,
	RPR_MATERIAL_INPUT_TRANSMISSION_COLOR = 0x25 ,
	RPR_MATERIAL_INPUT_THICKNESS = 0x26 ,
	RPR_MATERIAL_INPUT_0 = 0x27 ,
	RPR_MATERIAL_INPUT_1 = 0x28 ,
	RPR_MATERIAL_INPUT_2 = 0x29 ,
	RPR_MATERIAL_INPUT_3 = 0x2a ,
	RPR_MATERIAL_INPUT_4 = 0x2b ,
	RPR_MATERIAL_INPUT_SCHLICK_APPROXIMATION = 0x2c ,
	RPR_MATERIAL_INPUT_APPLYSURFACE = 0x2d ,
	RPR_MATERIAL_INPUT_TANGENT = 0x2e ,
	RPR_MATERIAL_INPUT_DISTRIBUTION = 0x2f ,
	RPR_MATERIAL_INPUT_BASE = 0x30 ,
	RPR_MATERIAL_INPUT_TINT = 0x31 ,
	RPR_MATERIAL_INPUT_EXPONENT = 0x32 ,
	RPR_MATERIAL_INPUT_AMPLITUDE = 0x33 ,
	RPR_MATERIAL_INPUT_PIVOT = 0x34 ,
	RPR_MATERIAL_INPUT_POSITION = 0x35 ,
	RPR_MATERIAL_INPUT_AMOUNT = 0x36 ,
	RPR_MATERIAL_INPUT_AXIS = 0x37 ,
	RPR_MATERIAL_INPUT_LUMACOEFF = 0x38 ,
	RPR_MATERIAL_INPUT_REFLECTIVITY = 0x39 ,
	RPR_MATERIAL_INPUT_EDGE_COLOR = 0x3a ,
	RPR_MATERIAL_INPUT_VIEW_DIRECTION = 0x3b ,
	RPR_MATERIAL_INPUT_INTERIOR = 0x3c ,
	RPR_MATERIAL_INPUT_OCTAVES = 0x3d ,
	RPR_MATERIAL_INPUT_LACUNARITY = 0x3e ,
	RPR_MATERIAL_INPUT_DIMINISH = 0x3f ,
	RPR_MATERIAL_INPUT_WRAP_U = 0x40 ,
	RPR_MATERIAL_INPUT_WRAP_V = 0x41 ,
	RPR_MATERIAL_INPUT_WRAP_W = 0x42 ,
	RPR_MATERIAL_INPUT_5 = 0x43 ,
	RPR_MATERIAL_INPUT_6 = 0x44 ,
	RPR_MATERIAL_INPUT_7 = 0x45 ,
	RPR_MATERIAL_INPUT_8 = 0x46 ,
	RPR_MATERIAL_INPUT_9 = 0x47 ,
	RPR_MATERIAL_INPUT_10 = 0x48 ,
	RPR_MATERIAL_INPUT_11 = 0x49 ,
	RPR_MATERIAL_INPUT_12 = 0x4a ,
	RPR_MATERIAL_INPUT_13 = 0x4b ,
	RPR_MATERIAL_INPUT_14 = 0x4c ,
	RPR_MATERIAL_INPUT_15 = 0x4d ,
	RPR_MATERIAL_INPUT_DIFFUSE_RAMP = 0x4e ,
	RPR_MATERIAL_INPUT_SHADOW = 0x4f ,
	RPR_MATERIAL_INPUT_MID = 0x50 ,
	RPR_MATERIAL_INPUT_HIGHLIGHT = 0x51 ,
	RPR_MATERIAL_INPUT_POSITION1 = 0x52 ,
	RPR_MATERIAL_INPUT_POSITION2 = 0x53 ,
	RPR_MATERIAL_INPUT_RANGE1 = 0x54 ,
	RPR_MATERIAL_INPUT_RANGE2 = 0x55 ,
	RPR_MATERIAL_INPUT_INTERPOLATION = 0x56 ,
	RPR_MATERIAL_INPUT_RANDOMNESS = 0x57 ,
	RPR_MATERIAL_INPUT_DIMENSION = 0x58 ,
	RPR_MATERIAL_INPUT_OUTTYPE = 0x59 ,
	RPR_MATERIAL_INPUT_DENSITY = 0x5a ,
	RPR_MATERIAL_INPUT_DENSITYGRID = 0x5b ,
	RPR_MATERIAL_INPUT_DISPLACEMENT = 0x5c ,
	RPR_MATERIAL_INPUT_TEMPERATURE = 0x5d ,
	RPR_MATERIAL_INPUT_KELVIN = 0x5e ,
	RPR_MATERIAL_INPUT_EXTINCTION = 0x5f ,
	RPR_MATERIAL_INPUT_THIN_FILM = 0x60 ,
	RPR_MATERIAL_INPUT_TOP = 0x61 ,
	RPR_MATERIAL_INPUT_HIGHLIGHT2 = 0x62 ,
	RPR_MATERIAL_INPUT_SHADOW2 = 0x63 ,
	RPR_MATERIAL_INPUT_POSITION_SHADOW = 0x64 ,
	RPR_MATERIAL_INPUT_POSITION_HIGHLIGHT = 0x65 ,
	RPR_MATERIAL_INPUT_RANGE_SHADOW = 0x66 ,
	RPR_MATERIAL_INPUT_RANGE_HIGHLIGHT = 0x67 ,
	RPR_MATERIAL_INPUT_TOON_5_COLORS = 0x68 ,
	RPR_MATERIAL_INPUT_X = 0x69 ,
	RPR_MATERIAL_INPUT_Y = 0x6a ,
	RPR_MATERIAL_INPUT_Z = 0x6b ,
	RPR_MATERIAL_INPUT_W = 0x6c ,
	RPR_MATERIAL_INPUT_LIGHT = 0x6d ,
	RPR_MATERIAL_INPUT_MID_IS_ALBEDO = 0x6e ,
	RPR_MATERIAL_INPUT_SAMPLES = 0x6f ,
	RPR_MATERIAL_INPUT_BASE_NORMAL = 0x70 ,
	RPR_MATERIAL_INPUT_UBER_DIFFUSE_COLOR = 0x910,
	RPR_MATERIAL_INPUT_UBER_DIFFUSE_WEIGHT = 0x927,
	RPR_MATERIAL_INPUT_UBER_DIFFUSE_ROUGHNESS = 0x911,
	RPR_MATERIAL_INPUT_UBER_DIFFUSE_NORMAL = 0x912,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_COLOR = 0x913,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_WEIGHT = 0x928,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_ROUGHNESS = 0x914,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_ANISOTROPY = 0x915,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_ANISOTROPY_ROTATION = 0x916,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_MODE = 0x917,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_IOR = 0x918,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_METALNESS = 0x919,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_NORMAL = 0x929,
	RPR_MATERIAL_INPUT_UBER_REFLECTION_DIELECTRIC_REFLECTANCE = 0x93e,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_COLOR = 0x91A,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_WEIGHT = 0x92a,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_ROUGHNESS = 0x91B,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_IOR = 0x91C,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_NORMAL = 0x92b,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_THIN_SURFACE = 0x91D,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_ABSORPTION_COLOR = 0x92c,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_ABSORPTION_DISTANCE = 0x92d,
	RPR_MATERIAL_INPUT_UBER_REFRACTION_CAUSTICS = 0x92e,
	RPR_MATERIAL_INPUT_UBER_COATING_COLOR = 0x91E,
	RPR_MATERIAL_INPUT_UBER_COATING_WEIGHT = 0x92f,
	RPR_MATERIAL_INPUT_UBER_COATING_ROUGHNESS = 0x91F,
	RPR_MATERIAL_INPUT_UBER_COATING_MODE = 0x920,
	RPR_MATERIAL_INPUT_UBER_COATING_IOR = 0x921,
	RPR_MATERIAL_INPUT_UBER_COATING_METALNESS = 0x922,
	RPR_MATERIAL_INPUT_UBER_COATING_NORMAL = 0x923,
	RPR_MATERIAL_INPUT_UBER_COATING_TRANSMISSION_COLOR = 0x930,
	RPR_MATERIAL_INPUT_UBER_COATING_THICKNESS = 0x931,
	RPR_MATERIAL_INPUT_UBER_SHEEN = 0x932,
	RPR_MATERIAL_INPUT_UBER_SHEEN_TINT = 0x933,
	RPR_MATERIAL_INPUT_UBER_SHEEN_WEIGHT = 0x934,
	RPR_MATERIAL_INPUT_UBER_EMISSION_COLOR = 0x924,
	RPR_MATERIAL_INPUT_UBER_EMISSION_WEIGHT = 0x925,
	RPR_MATERIAL_INPUT_UBER_EMISSION_MODE = 0x935,
	RPR_MATERIAL_INPUT_UBER_TRANSPARENCY = 0x926,
	RPR_MATERIAL_INPUT_UBER_SSS_SCATTER_COLOR = 0x937,
	RPR_MATERIAL_INPUT_UBER_SSS_SCATTER_DISTANCE = 0x938,
	RPR_MATERIAL_INPUT_UBER_SSS_SCATTER_DIRECTION = 0x939,
	RPR_MATERIAL_INPUT_UBER_SSS_WEIGHT = 0x93a,
	RPR_MATERIAL_INPUT_UBER_SSS_MULTISCATTER = 0x93b,
	RPR_MATERIAL_INPUT_UBER_BACKSCATTER_WEIGHT = 0x93c,
	RPR_MATERIAL_INPUT_UBER_BACKSCATTER_COLOR = 0x93d,
	RPR_MATERIAL_INPUT_ADDRESS = 0x93e,
	RPR_MATERIAL_INPUT_TYPE = 0x93f,
	RPR_MATERIAL_INPUT_UBER_FRESNEL_SCHLICK_APPROXIMATION = RPR_MATERIAL_INPUT_SCHLICK_APPROXIMATION,
} rpr_material_node_input ;

typedef enum // rpr_material_input_raster
{
	RPR_MATERIAL_INPUT_RASTER_METALLIC = 0x901 ,
	RPR_MATERIAL_INPUT_RASTER_ROUGHNESS = 0x902 ,
	RPR_MATERIAL_INPUT_RASTER_SUBSURFACE = 0x903 ,
	RPR_MATERIAL_INPUT_RASTER_ANISOTROPIC = 0x904 ,
	RPR_MATERIAL_INPUT_RASTER_SPECULAR = 0x905 ,
	RPR_MATERIAL_INPUT_RASTER_SPECULARTINT = 0x906 ,
	RPR_MATERIAL_INPUT_RASTER_SHEEN = 0x907 ,
	RPR_MATERIAL_INPUT_RASTER_SHEENTINT = 0x908 ,
	RPR_MATERIAL_INPUT_RASTER_CLEARCOAT = 0x90A ,
	RPR_MATERIAL_INPUT_RASTER_CLEARCOATGLOSS = 0x90B ,
	RPR_MATERIAL_INPUT_RASTER_COLOR = 0x90C ,
	RPR_MATERIAL_INPUT_RASTER_NORMAL = 0x90D ,
} rpr_material_input_raster ;

typedef enum // rpr_interpolation_mode
{
	RPR_INTERPOLATION_MODE_NONE = 0x0,
	RPR_INTERPOLATION_MODE_LINEAR = 0x1,
	RPR_INTERPOLATION_MODE_EXPONENTIAL_UP = 0x2,
	RPR_INTERPOLATION_MODE_EXPONENTIAL_DOWN = 0x3,
	RPR_INTERPOLATION_MODE_SMOOTH = 0x4,
	RPR_INTERPOLATION_MODE_BUMP = 0x5,
	RPR_INTERPOLATION_MODE_SPIKE = 0x6,
} rpr_interpolation_mode ;

typedef enum // rpr_ubermaterial_ior_mode
{
	RPR_UBER_MATERIAL_IOR_MODE_PBR = 0x1,
	RPR_UBER_MATERIAL_IOR_MODE_METALNESS = 0x2,
} rpr_ubermaterial_ior_mode ;

typedef enum // rpr_ubermaterial_emission_mode
{
	RPR_UBER_MATERIAL_EMISSION_MODE_SINGLESIDED = 0x1,
	RPR_UBER_MATERIAL_EMISSION_MODE_DOUBLESIDED = 0x2,
} rpr_ubermaterial_emission_mode ;

typedef enum // rpr_material_node_arithmetic_operation
{
	RPR_MATERIAL_NODE_OP_ADD = 0x00 ,
	RPR_MATERIAL_NODE_OP_SUB = 0x01 ,
	RPR_MATERIAL_NODE_OP_MUL = 0x02 ,
	RPR_MATERIAL_NODE_OP_DIV = 0x03 ,
	RPR_MATERIAL_NODE_OP_SIN = 0x04 ,
	RPR_MATERIAL_NODE_OP_COS = 0x05 ,
	RPR_MATERIAL_NODE_OP_TAN = 0x06 ,
	RPR_MATERIAL_NODE_OP_SELECT_X = 0x07 ,
	RPR_MATERIAL_NODE_OP_SELECT_Y = 0x08 ,
	RPR_MATERIAL_NODE_OP_SELECT_Z = 0x09 ,
	RPR_MATERIAL_NODE_OP_COMBINE = 0x0A ,
	RPR_MATERIAL_NODE_OP_DOT3 = 0x0B ,
	RPR_MATERIAL_NODE_OP_CROSS3 = 0x0C ,
	RPR_MATERIAL_NODE_OP_LENGTH3 = 0x0D ,
	RPR_MATERIAL_NODE_OP_NORMALIZE3 = 0x0E ,
	RPR_MATERIAL_NODE_OP_POW = 0x0F ,
	RPR_MATERIAL_NODE_OP_ACOS = 0x10 ,
	RPR_MATERIAL_NODE_OP_ASIN = 0x11 ,
	RPR_MATERIAL_NODE_OP_ATAN = 0x12 ,
	RPR_MATERIAL_NODE_OP_AVERAGE_XYZ = 0x13 ,
	RPR_MATERIAL_NODE_OP_AVERAGE = 0x14 ,
	RPR_MATERIAL_NODE_OP_MIN = 0x15 ,
	RPR_MATERIAL_NODE_OP_MAX = 0x16 ,
	RPR_MATERIAL_NODE_OP_FLOOR = 0x17 ,
	RPR_MATERIAL_NODE_OP_MOD = 0x18 ,
	RPR_MATERIAL_NODE_OP_ABS = 0x19 ,
	RPR_MATERIAL_NODE_OP_SHUFFLE_YZWX = 0x1a ,
	RPR_MATERIAL_NODE_OP_SHUFFLE_ZWXY = 0x1b ,
	RPR_MATERIAL_NODE_OP_SHUFFLE_WXYZ = 0x1c ,
	RPR_MATERIAL_NODE_OP_MAT_MUL = 0x1d ,
	RPR_MATERIAL_NODE_OP_SELECT_W = 0x1e ,
	RPR_MATERIAL_NODE_OP_DOT4 = 0x1f ,
	RPR_MATERIAL_NODE_OP_LOG = 0x20 ,
	RPR_MATERIAL_NODE_OP_LOWER_OR_EQUAL = 0x21 ,
	RPR_MATERIAL_NODE_OP_LOWER = 0x22 ,
	RPR_MATERIAL_NODE_OP_GREATER_OR_EQUAL = 0x23 ,
	RPR_MATERIAL_NODE_OP_GREATER = 0x24 ,
	RPR_MATERIAL_NODE_OP_EQUAL = 0x25 ,
	RPR_MATERIAL_NODE_OP_NOT_EQUAL = 0x26 ,
	RPR_MATERIAL_NODE_OP_AND = 0x27 ,
	RPR_MATERIAL_NODE_OP_OR = 0x28 ,
	RPR_MATERIAL_NODE_OP_TERNARY = 0x29 ,
	RPR_MATERIAL_NODE_OP_EXP = 0x2a ,
	RPR_MATERIAL_NODE_OP_ROTATE2D = 0x2b ,
	RPR_MATERIAL_NODE_OP_ROTATE3D = 0x2c ,
	RPR_MATERIAL_NODE_OP_NOP = 0x2d ,
	RPR_MATERIAL_NODE_OP_CEIL = 0x102a ,
	RPR_MATERIAL_NODE_OP_ROUND = 0x102b ,
	RPR_MATERIAL_NODE_OP_SIGN = 0x102c ,
	RPR_MATERIAL_NODE_OP_SQRT = 0x102f ,
	RPR_MATERIAL_NODE_OP_CLAMP = 0x1035 ,
} rpr_material_node_arithmetic_operation ;

typedef enum // rpr_material_node_lookup_value
{
	RPR_MATERIAL_NODE_LOOKUP_UV = 0x0 ,
	RPR_MATERIAL_NODE_LOOKUP_N = 0x1 ,
	RPR_MATERIAL_NODE_LOOKUP_P = 0x2 ,
	RPR_MATERIAL_NODE_LOOKUP_INVEC = 0x3 ,
	RPR_MATERIAL_NODE_LOOKUP_OUTVEC = 0x4 ,
	RPR_MATERIAL_NODE_LOOKUP_UV1 = 0x5 ,
	RPR_MATERIAL_NODE_LOOKUP_P_LOCAL = 0x6 ,
	RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE0 = 0x7 ,
	RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE1 = 0x8 ,
	RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE2 = 0x9 ,
	RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE3 = 0xa ,
	RPR_MATERIAL_NODE_LOOKUP_SHAPE_RANDOM_COLOR = 0xb ,
	RPR_MATERIAL_NODE_LOOKUP_OBJECT_ID = 0xc ,
	RPR_MATERIAL_NODE_LOOKUP_PRIMITIVE_RANDOM_COLOR = 0xd ,
} rpr_material_node_lookup_value ;

typedef enum // rpr_material_gradient_procedural_type
{
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_LINEAR = 0x1 ,
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_QUADRATIC = 0x2 ,
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_EASING = 0x3 ,
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_DIAGONAL = 0x4 ,
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_SPHERICAL = 0x5 ,
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_QUAD_SPHERE = 0x6 ,
	RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_RADIAL = 0x7 ,
} rpr_material_gradient_procedural_type ;

typedef enum // rpr_material_node_uvtype_value
{
	RPR_MATERIAL_NODE_UVTYPE_PLANAR = 0x0 ,
	RPR_MATERIAL_NODE_UVTYPE_CYLINDICAL = 0x1 ,
	RPR_MATERIAL_NODE_UVTYPE_SPHERICAL = 0x2 ,
	RPR_MATERIAL_NODE_UVTYPE_PROJECT = 0x3 ,
} rpr_material_node_uvtype_value ;

typedef enum // rpr_material_node_transform_op
{
	RPR_MATERIAL_NODE_TRANSFORM_ROTATE_LOCAL_TO_WORLD = 0x1 ,
} rpr_material_node_transform_op ;

typedef enum // rpr_post_effect_info
{
	RPR_POST_EFFECT_TYPE = 0x0 ,
	RPR_POST_EFFECT_WHITE_BALANCE_COLOR_SPACE = 0x4 ,
	RPR_POST_EFFECT_WHITE_BALANCE_COLOR_TEMPERATURE = 0x5 ,
	RPR_POST_EFFECT_SIMPLE_TONEMAP_EXPOSURE = 0x6 ,
	RPR_POST_EFFECT_SIMPLE_TONEMAP_CONTRAST = 0x7 ,
	RPR_POST_EFFECT_SIMPLE_TONEMAP_ENABLE_TONEMAP = 0x8 ,
	RPR_POST_EFFECT_BLOOM_RADIUS = 0x9 ,
	RPR_POST_EFFECT_BLOOM_THRESHOLD = 0x0a ,
	RPR_POST_EFFECT_BLOOM_WEIGHT = 0x0b ,
	RPR_POST_EFFECT_NAME = RPR_OBJECT_NAME,
	RPR_POST_EFFECT_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_POST_EFFECT_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_post_effect_info ;

typedef enum // rpr_aov
{
	RPR_AOV_COLOR = 0x0 ,
	RPR_AOV_OPACITY = 0x1 ,
	RPR_AOV_WORLD_COORDINATE = 0x2 ,
	RPR_AOV_UV = 0x3 ,
	RPR_AOV_MATERIAL_ID = 0x4 ,
	RPR_AOV_GEOMETRIC_NORMAL = 0x5 ,
	RPR_AOV_SHADING_NORMAL = 0x6 ,
	RPR_AOV_DEPTH = 0x7 ,
	RPR_AOV_OBJECT_ID = 0x8 ,
	RPR_AOV_OBJECT_GROUP_ID = 0x9 ,
	RPR_AOV_SHADOW_CATCHER = 0x0a ,
	RPR_AOV_BACKGROUND = 0x0b ,
	RPR_AOV_EMISSION = 0x0c ,
	RPR_AOV_VELOCITY = 0x0d ,
	RPR_AOV_DIRECT_ILLUMINATION = 0x0e ,
	RPR_AOV_INDIRECT_ILLUMINATION = 0x0f ,
	RPR_AOV_AO = 0x10 ,
	RPR_AOV_DIRECT_DIFFUSE = 0x11 ,
	RPR_AOV_DIRECT_REFLECT = 0x12 ,
	RPR_AOV_INDIRECT_DIFFUSE = 0x13 ,
	RPR_AOV_INDIRECT_REFLECT = 0x14 ,
	RPR_AOV_REFRACT = 0x15 ,
	RPR_AOV_VOLUME = 0x16 ,
	RPR_AOV_LIGHT_GROUP0 = 0x17 ,
	RPR_AOV_LIGHT_GROUP1 = 0x18 ,
	RPR_AOV_LIGHT_GROUP2 = 0x19 ,
	RPR_AOV_LIGHT_GROUP3 = 0x1a ,
	RPR_AOV_DIFFUSE_ALBEDO = 0x1b ,
	RPR_AOV_VARIANCE = 0x1c ,
	RPR_AOV_VIEW_SHADING_NORMAL = 0x1d,
	RPR_AOV_REFLECTION_CATCHER = 0x1e,
	RPR_AOV_COLOR_RIGHT = 0x1f ,
	RPR_AOV_LPE_0 = 0x20 ,
	RPR_AOV_LPE_1 = 0x21 ,
	RPR_AOV_LPE_2 = 0x22 ,
	RPR_AOV_LPE_3 = 0x23 ,
	RPR_AOV_LPE_4 = 0x24 ,
	RPR_AOV_LPE_5 = 0x25 ,
	RPR_AOV_LPE_6 = 0x26 ,
	RPR_AOV_LPE_7 = 0x27 ,
	RPR_AOV_LPE_8 = 0x28 ,
	RPR_AOV_CAMERA_NORMAL = 0x29 ,
	RPR_AOV_MATTE_PASS = 0x2a ,
	RPR_AOV_SSS = 0x2b ,
	RPR_AOV_CRYPTOMATTE_MAT0 = 0x30,
	RPR_AOV_CRYPTOMATTE_MAT1 = 0x31,
	RPR_AOV_CRYPTOMATTE_MAT2 = 0x32,
	RPR_AOV_CRYPTOMATTE_MAT3 = 0x33,
	RPR_AOV_CRYPTOMATTE_MAT4 = 0x34,
	RPR_AOV_CRYPTOMATTE_MAT5 = 0x35,
	RPR_AOV_CRYPTOMATTE_OBJ0 = 0x38,
	RPR_AOV_CRYPTOMATTE_OBJ1 = 0x39,
	RPR_AOV_CRYPTOMATTE_OBJ2 = 0x3a,
	RPR_AOV_CRYPTOMATTE_OBJ3 = 0x3b,
	RPR_AOV_CRYPTOMATTE_OBJ4 = 0x3c,
	RPR_AOV_CRYPTOMATTE_OBJ5 = 0x3d,
	RPR_AOV_DEEP_COLOR = 0x40,
	RPR_AOV_LIGHT_GROUP4 = 0x50 ,
	RPR_AOV_LIGHT_GROUP5 = 0x51 ,
	RPR_AOV_LIGHT_GROUP6 = 0x52 ,
	RPR_AOV_LIGHT_GROUP7 = 0x53 ,
	RPR_AOV_LIGHT_GROUP8 = 0x54 ,
	RPR_AOV_LIGHT_GROUP9 = 0x55 ,
	RPR_AOV_LIGHT_GROUP10 = 0x56 ,
	RPR_AOV_LIGHT_GROUP11 = 0x57 ,
	RPR_AOV_LIGHT_GROUP12 = 0x58 ,
	RPR_AOV_LIGHT_GROUP13 = 0x59 ,
	RPR_AOV_LIGHT_GROUP14 = 0x5a ,
	RPR_AOV_LIGHT_GROUP15 = 0x5b ,
	RPR_AOV_MESH_ID = 0x60 ,
} rpr_aov ;

typedef enum // rpr_post_effect_type
{
	RPR_POST_EFFECT_TONE_MAP = 0x0 ,
	RPR_POST_EFFECT_WHITE_BALANCE = 0x1 ,
	RPR_POST_EFFECT_SIMPLE_TONEMAP = 0x2 ,
	RPR_POST_EFFECT_NORMALIZATION = 0x3 ,
	RPR_POST_EFFECT_GAMMA_CORRECTION = 0x4 ,
	RPR_POST_EFFECT_BLOOM = 0x5 ,
} rpr_post_effect_type ;

typedef enum // rpr_color_space
{
	RPR_COLOR_SPACE_SRGB = 0x1 ,
	RPR_COLOR_SPACE_ADOBE_RGB = 0x2 ,
	RPR_COLOR_SPACE_REC2020 = 0x3 ,
	RPR_COLOR_SPACE_DCIP3 = 0x4 ,
} rpr_color_space ;

typedef enum // rpr_material_node_input_type
{
/* rpr_material_node_input_type */
	RPR_MATERIAL_NODE_INPUT_TYPE_FLOAT4 = 0x1 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_UINT = 0x2 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_NODE = 0x3 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_IMAGE = 0x4 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_BUFFER = 0x5 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_GRID = 0x6 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_DATA = 0x7 ,
	RPR_MATERIAL_NODE_INPUT_TYPE_LIGHT = 0x8 ,
} rpr_material_node_input_type ;

typedef enum // rpr_subdiv_boundary_interfop_type
{
	RPR_SUBDIV_BOUNDARY_INTERFOP_TYPE_EDGE_AND_CORNER = 0x1 ,
	RPR_SUBDIV_BOUNDARY_INTERFOP_TYPE_EDGE_ONLY = 0x2 ,
} rpr_subdiv_boundary_interfop_type ;

typedef enum // rpr_image_wrap_type
{
	RPR_IMAGE_WRAP_TYPE_REPEAT = 0x1 ,
	RPR_IMAGE_WRAP_TYPE_MIRRORED_REPEAT = 0x2 ,
	RPR_IMAGE_WRAP_TYPE_CLAMP_TO_EDGE = 0x3 ,
	RPR_IMAGE_WRAP_TYPE_CLAMP_ZERO = 0x5 ,
	RPR_IMAGE_WRAP_TYPE_CLAMP_ONE = 0x6 ,
} rpr_image_wrap_type ;

typedef enum // rpr_voronoi_out_type
{
	RPR_VORONOI_OUT_TYPE_DISTANCE = 0x1 ,
	RPR_VORONOI_OUT_TYPE_COLOR = 0x2 ,
	RPR_VORONOI_OUT_TYPE_POSITION = 0x3 ,
} rpr_voronoi_out_type ;

typedef enum // rpr_image_filter_type
{
	RPR_IMAGE_FILTER_TYPE_NEAREST = 0x1 ,
	RPR_IMAGE_FILTER_TYPE_LINEAR = 0x2 ,
} rpr_image_filter_type ;

typedef enum // rpr_composite_info
{
	RPR_COMPOSITE_TYPE = 0x1  ,
	RPR_COMPOSITE_FRAMEBUFFER_INPUT_FB = 0x2  ,
	RPR_COMPOSITE_NORMALIZE_INPUT_COLOR = 0x3  ,
	RPR_COMPOSITE_NORMALIZE_INPUT_AOVTYPE = 0x4  ,
	RPR_COMPOSITE_CONSTANT_INPUT_VALUE = 0x5  ,
	RPR_COMPOSITE_LERP_VALUE_INPUT_COLOR0 = 0x6  ,
	RPR_COMPOSITE_LERP_VALUE_INPUT_COLOR1 = 0x7  ,
	RPR_COMPOSITE_LERP_VALUE_INPUT_WEIGHT = 0x8  ,
	RPR_COMPOSITE_ARITHMETIC_INPUT_COLOR0 = 0x9  ,
	RPR_COMPOSITE_ARITHMETIC_INPUT_COLOR1 = 0x0a  ,
	RPR_COMPOSITE_ARITHMETIC_INPUT_OP = 0x0b  ,
	RPR_COMPOSITE_GAMMA_CORRECTION_INPUT_COLOR = 0x0c  ,
	RPR_COMPOSITE_LUT_INPUT_LUT = 0x0d  ,
	RPR_COMPOSITE_LUT_INPUT_COLOR = 0x0e  ,
	RPR_COMPOSITE_NAME = RPR_OBJECT_NAME,
	RPR_COMPOSITE_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_COMPOSITE_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_composite_info ;

typedef enum // rpr_composite_type
{
	RPR_COMPOSITE_ARITHMETIC = 0x1  ,
	RPR_COMPOSITE_LERP_VALUE = 0x2  ,
	RPR_COMPOSITE_INVERSE = 0x3  ,
	RPR_COMPOSITE_NORMALIZE = 0x4  ,
	RPR_COMPOSITE_GAMMA_CORRECTION = 0x5  ,
	RPR_COMPOSITE_EXPOSURE = 0x6  ,
	RPR_COMPOSITE_CONTRAST = 0x7  ,
	RPR_COMPOSITE_SIDE_BY_SIDE = 0x8  ,
	RPR_COMPOSITE_TONEMAP_ACES = 0x9  ,
	RPR_COMPOSITE_TONEMAP_REINHARD = 0xa  ,
	RPR_COMPOSITE_TONEMAP_LINEAR = 0xb  ,
	RPR_COMPOSITE_FRAMEBUFFER = 0xc  ,
	RPR_COMPOSITE_CONSTANT = 0xd  ,
	RPR_COMPOSITE_LUT = 0xe  ,
} rpr_composite_type ;

typedef enum // rpr_grid_parameter
{
	RPR_GRID_SIZE_X = 0x930 ,
	RPR_GRID_SIZE_Y = 0x931 ,
	RPR_GRID_SIZE_Z = 0x932 ,
	RPR_GRID_DATA = 0x933 ,
	RPR_GRID_DATA_SIZEBYTE = 0x934 ,
	RPR_GRID_INDICES = 0x936 ,
	RPR_GRID_INDICES_NUMBER = 0x937 ,
	RPR_GRID_INDICES_TOPOLOGY = 0x938 ,
	RPR_GRID_NAME = RPR_OBJECT_NAME,
	RPR_GRID_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_GRID_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_grid_parameter ;

typedef enum // rpr_hetero_volume_parameter
{
	RPR_HETEROVOLUME_TRANSFORM = 0x735 ,
	RPR_HETEROVOLUME_ALBEDO_V2 = 0x73c ,
	RPR_HETEROVOLUME_DENSITY_V2 = 0x73d ,
	RPR_HETEROVOLUME_EMISSION_V2 = 0x73e ,
	RPR_HETEROVOLUME_ALBEDO_LOOKUP_VALUES = 0x73f ,
	RPR_HETEROVOLUME_ALBEDO_LOOKUP_VALUES_COUNT = 0x740 ,
	RPR_HETEROVOLUME_DENSITY_LOOKUP_VALUES = 0x741 ,
	RPR_HETEROVOLUME_DENSITY_LOOKUP_VALUES_COUNT = 0x742 ,
	RPR_HETEROVOLUME_EMISSION_LOOKUP_VALUES = 0x743 ,
	RPR_HETEROVOLUME_EMISSION_LOOKUP_VALUES_COUNT = 0x744 ,
	RPR_HETEROVOLUME_ALBEDO_SCALE = 0x745 ,
	RPR_HETEROVOLUME_DENSITY_SCALE = 0x746 ,
	RPR_HETEROVOLUME_EMISSION_SCALE = 0x747 ,
	RPR_HETEROVOLUME_NAME = RPR_OBJECT_NAME,
	RPR_HETEROVOLUME_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_HETEROVOLUME_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
} rpr_hetero_volume_parameter ;

typedef enum // rpr_grid_indices_topology
{
	RPR_GRID_INDICES_TOPOLOGY_I_U64 = 0x950 ,
	RPR_GRID_INDICES_TOPOLOGY_XYZ_U32 = 0x951 ,
	RPR_GRID_INDICES_TOPOLOGY_I_S64 = 0x952 ,
	RPR_GRID_INDICES_TOPOLOGY_XYZ_S32 = 0x953 ,
} rpr_grid_indices_topology ;

typedef enum // rpr_curve_parameter
{
	RPR_CURVE_CONTROLPOINTS_COUNT = 0x830 ,
	RPR_CURVE_CONTROLPOINTS_DATA = 0x831 ,
	RPR_CURVE_CONTROLPOINTS_STRIDE = 0x832 ,
	RPR_CURVE_INDICES_COUNT = 0x833 ,
	RPR_CURVE_INDICES_DATA = 0x834 ,
	RPR_CURVE_RADIUS = 0x835 ,
	RPR_CURVE_UV = 0x836 ,
	RPR_CURVE_COUNT_CURVE = 0x837 ,
	RPR_CURVE_SEGMENTS_PER_CURVE = 0x838 ,
	RPR_CURVE_CREATION_FLAG = 0x839 ,
	RPR_CURVE_NAME = RPR_OBJECT_NAME,
	RPR_CURVE_UNIQUE_ID = RPR_OBJECT_UNIQUE_ID,
	RPR_CURVE_CUSTOM_PTR = RPR_OBJECT_CUSTOM_PTR,
	RPR_CURVE_TRANSFORM = RPR_SHAPE_TRANSFORM,
	RPR_CURVE_MATERIAL = RPR_SHAPE_MATERIAL,
	RPR_CURVE_VISIBILITY_PRIMARY_ONLY_FLAG = RPR_SHAPE_VISIBILITY_PRIMARY_ONLY_FLAG,
	RPR_CURVE_VISIBILITY_SHADOW = RPR_SHAPE_VISIBILITY_SHADOW,
	RPR_CURVE_VISIBILITY_REFLECTION = RPR_SHAPE_VISIBILITY_REFLECTION,
	RPR_CURVE_VISIBILITY_REFRACTION = RPR_SHAPE_VISIBILITY_REFRACTION,
	RPR_CURVE_VISIBILITY_TRANSPARENT = RPR_SHAPE_VISIBILITY_TRANSPARENT,
	RPR_CURVE_VISIBILITY_DIFFUSE = RPR_SHAPE_VISIBILITY_DIFFUSE,
	RPR_CURVE_VISIBILITY_GLOSSY_REFLECTION = RPR_SHAPE_VISIBILITY_GLOSSY_REFLECTION,
	RPR_CURVE_VISIBILITY_GLOSSY_REFRACTION = RPR_SHAPE_VISIBILITY_GLOSSY_REFRACTION,
	RPR_CURVE_VISIBILITY_LIGHT = RPR_SHAPE_VISIBILITY_LIGHT,
	RPR_CURVE_VISIBILITY_RECEIVE_SHADOW = RPR_SHAPE_VISIBILITY_RECEIVE_SHADOW,
} rpr_curve_parameter ;

typedef struct //rpr_image_desc
{
	rpr_uint image_width;
	rpr_uint image_height;
	rpr_uint image_depth;
	rpr_uint image_row_pitch;
	rpr_uint image_slice_pitch;
} rpr_image_desc;
typedef struct //rpr_buffer_desc
{
	rpr_uint nb_element;
	rpr_buffer_element_type element_type;
	rpr_uint element_channel_size;
} rpr_buffer_desc;
typedef struct //rpr_framebuffer_desc
{
	rpr_uint fb_width;
	rpr_uint fb_height;
} rpr_framebuffer_desc;
typedef struct //rpr_render_statistics
{
	rpr_longlong gpumem_usage;
	rpr_longlong gpumem_total;
	rpr_longlong gpumem_max_allocation;
	rpr_longlong sysmem_usage;
} rpr_render_statistics;
typedef struct //rpr_image_format
{
	rpr_uint num_components;
	rpr_component_type type;
} rpr_image_format;
typedef struct //rpr_framebuffer_format
{
	rpr_uint num_components;
	rpr_component_type type;
} rpr_framebuffer_format;
typedef struct //rpr_ies_image_desc
{
	rpr_int w;
	rpr_int h;
	rpr_char const * data;
	rpr_char const * filename;
} rpr_ies_image_desc;
// Deprecated version naming - will be removed in the future :
/* last of the RPR_CONTEXT_* */
  // RPR_PARAMETER_NAME_STRING 0x1202   not used anymore  you can only set/get parameters using  RPR_CONTEXT_*

/* rpr_instance_info */
// RPR_MATERIAL_NODE_INPUT_NAME_STRING 0x1104  not used anymore  you can only set/get parameters using  RPR_MATERIAL_INPUT_*

/* rpr_bool */
/* Library types *//* This is going to be moved to rpr_platform.h or similar */
/* API functions */
    /** @brief Register rendering plugin
    *
    *  <Description>
    *
    *  @param path     Path of plugin to load (for UNICODE, supports UTF-8 encoding)
    *  @return         unique identifier of plugin, -1 otherwise
    */
  extern RPR_API_ENTRY rpr_int rprRegisterPlugin(rpr_char const * path);


    /** @brief Create rendering context
    *
    *  Rendering context is a root concept encapsulating the render states and responsible
    *  for execution control. All the entities in Radeon ProRender are created for a particular rendering context.
    *  Entities created for some context can't be used with other contexts. Possible error codes for this call are:
    *
    *     RPR_ERROR_COMPUTE_API_NOT_SUPPORTED
    *     RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *     RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *     RPR_ERROR_INVALID_API_VERSION
    *     RPR_ERROR_INVALID_PARAMETER
    *
    *  @param api_version     Api version constant
    *	 @param context_type    Determines compute API to use, OPENCL only is supported for now
    *  @param creation_flags  Determines multi-gpu or cpu-gpu configuration
    *  @param props           Context creation properties. Specifies a list of context property names and their corresponding values.
    *                         Each property name is immediately followed by the corresponding desired value.
    *                         The list is terminated with 0.
    *  @param cache_path      Full path to kernel cache created by Radeon ProRender, NULL means to use current folder (for UNICODE, supports UTF-8 encoding)
    *  @param cpu_thread_limit	Limit for the number of threads used for CPU rendering
    *  @param out_context		Pointer to context object
    *  @return                RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCreateContext(rpr_uint api_version, rpr_int const * pluginIDs, size_t pluginCount, rpr_creation_flags creation_flags, rpr_context_properties const * props, rpr_char const * cache_path, rpr_context * out_context);


    /** @breif Set active context plugin
    *
    */
  extern RPR_API_ENTRY rpr_status rprContextSetActivePlugin(rpr_context context, rpr_int pluginID);


    /** @brief Query information about a context
    *
    *  The workflow is usually two-step: query with the data == NULL and size = 0 to get the required buffer size in size_ret,
    *  then query with size_ret == NULL to fill the buffer with the data.
    *   Possible error codes:
    *     RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context         The context to query
    *  @param  context_info    The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetInfo(rpr_context context, rpr_context_info context_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a context parameter
    *
    *  The workflow is usually two-step: query with the data == NULL and size = 0 to get the required buffer size in size_ret,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *     RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context         The context to query
    *  @param  param_idx	   The index of the parameter - must be between 0 and  (value stored by RPR_CONTEXT_PARAMETER_COUNT)-1
    *  @param  parameter_info  The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetParameterInfo(rpr_context context, int param_idx, rpr_parameter_info parameter_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query the AOV
    *
    *  @param  context     The context to get a frame buffer from
    *  @param  out_fb		Pointer to framebuffer object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetAOV(rpr_context context, rpr_aov aov, rpr_framebuffer * out_fb);


    /** @brief Set AOV
    *
    *  @param  context         The context to set AOV
    *  @param  aov				AOV
    *  @param  frame_buffer    Frame buffer object to set
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetAOV(rpr_context context, rpr_aov aov, rpr_framebuffer frame_buffer);


    /** @brief
    *
    *  @param  context               The context to set 
    *  @param  renderLayerString   Render layer name to attach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextAttachRenderLayer(rpr_context context, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  context               The context to set 
    *  @param  renderLayerString   Render layer name to detach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextDetachRenderLayer(rpr_context context, rpr_char const * renderLayerString);


    /** @brief Set a LPE ( Light Path Expression ) to a framebuffer.
    *          Note that this framebuffer should also be assigned to a LPE AOV:  RPR_AOV_LPE_0 , RPR_AOV_LPE_1 ....
    *
    *
    *  @param  frame_buffer    Frame buffer object to set
    *  @param  lpe             Light Path Expression
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferSetLPE(rpr_framebuffer frame_buffer, rpr_char const * lpe);


    /** @brief Set AOV Index Lookup Color
    *          change the color of  AOV rendering IDs,  like : RPR_AOV_MATERIAL_ID , RPR_AOV_OBJECT_ID, RPR_AOV_OBJECT_GROUP_ID.
    *          for example, you can render all the  shapes with ObjectGroupID=4  in the Red color inside the RPR_AOV_OBJECT_GROUP_ID AOV
    *
    *  @param  context         The context to set AOV index lookup
    *  @param  key				id
    *  @param  colorR			red channel
    *  @param  colorG			green channel
    *  @param  colorB			blue channel
    *  @param  colorA			alpha channel
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetAOVindexLookup(rpr_context context, rpr_int key, rpr_float colorR, rpr_float colorG, rpr_float colorB, rpr_float colorA);


    /** @brief Set a Cutting Plane (also called Clipping plane).
    *
    * Notes:
    *  - In order to disable the 'index' cutting plane, set (A,B,C,D) = (0,0,0,0)
    *    By default, on context creation all cutting planes are disabled.
    * 
    *  - Index can be any number. It doesn't need to define the list of plane as a contiguous list of indices.
    *
    *  - If the number of enabled planes is greater than the limit supported by the renderer,
    *    then RPR_ERROR_UNSUPPORTED is return by the function.
    *
    *  - The normal of the equation plane points toward the area that is kept.
    *
    *  - If several clipping planes are used the rendered area will be the one commonly facing all the planes.
    *
    *  - Plane equation is Ax + By + Cz + D = 0
    *
    *  @param  context			The context to set the Cutting Plane
    *  @param  index			cutting plane index ( starts from 0 )
    *  @param  a				equation plane A
    *  @param  b				equation plane B
    *  @param  c				equation plane C
    *  @param  d				equation plane D
    *  @return					RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetCuttingPlane(rpr_context context, rpr_int index, rpr_float a, rpr_float b, rpr_float c, rpr_float d);


    /** @brief call a batch of rprContextSetAOVindexLookup
    *
    * example:
    * rprContextSetAOVindicesLookup(ctx, 2, 3, table);
    * is equivalent to call :
    * rprContextSetAOVindexLookup(ctx, 2, table[0], table[1], table[2],  table[3]);
    * rprContextSetAOVindexLookup(ctx, 3, table[4], table[5], table[6],  table[7]);
    * rprContextSetAOVindexLookup(ctx, 4, table[8], table[9], table[10], table[11]);
    * 
    * Depending on the plugin, rprContextSetAOVindicesLookup could be faster than calling several rprContextSetAOVindexLookup.
    */
  extern RPR_API_ENTRY rpr_status rprContextSetAOVindicesLookup(rpr_context context, rpr_int keyOffset, rpr_int keyCount, rpr_float const * colorRGBA);


    /**
    * API user can create its own procedural texture.
    * The API needs both a GPU code ( OpenCL string code ) and a CPU code ( callback )
    * (API function supported by Northstar only)
    *
    * example:  
    *      #define DEFINE_FUNC(FUNCNAME, FUNC) FUNC; const std::string g_str_##FUNCNAME = #FUNC;
    *      DEFINE_FUNC( RprCustomMatA ,   void RprCustomMatA(float* a, float* b, float* c, float* d, float* e, float* f, float* valueOut){   valueOut[0]=0.0;  valueOut[1]=sin(d[0]*3.14159);  valueOut[2]=0.0;  }   );
    *      rprContextSetUserTexture(context, 3, g_str_RprCustomMatA.c_str(), RprCustomMatA); // use slot 3
    *      // create material based on slot 3 :
    *      rpr_material_node matUserTex3; rprMaterialSystemCreateNode(matsys, RPR_MATERIAL_NODE_USER_TEXTURE, & matUserTex3);
    *      rprMaterialNodeSetInputUByKey(matUserTex3, RPR_MATERIAL_INPUT_OP, 3 ); // bind matUserTex3 to slot 3
    *      rprMaterialNodeSetInputNByKey(matUserTex3, RPR_MATERIAL_INPUT_4, paramInput ); // bind 'paramInput' to the 'e' argument of 'RprCustomMatA'
    *
    * Notes:
    * - If only the GPU is used, a nullptr can be given to 'cpuCode'.
    * - RPR_MATERIAL_NODE_USER_TEXTURE_0...RPR_MATERIAL_NODE_USER_TEXTURE_3   ,    RPR_CONTEXT_USER_TEXTURE_0...RPR_CONTEXT_USER_TEXTURE_3  are deprecated and should only be used with the old Tahoe plugin.
    * - When exporting the RPR scene to RPRS or GLTF, the CPU callback pointer will be lost in the imported scene.
    *
    */
  extern RPR_API_ENTRY rpr_status rprContextSetUserTexture(rpr_context context, rpr_int index, rpr_char const * gpuCode, void * cpuCode);


    /**
    * get the gpuCode string set by rprContextSetUserTexture.
    * (API function supported by Northstar only)
    */
  extern RPR_API_ENTRY rpr_status rprContextGetUserTexture(rpr_context context, rpr_int index, size_t bufferSizeByte, void * buffer, size_t * size_ret);


    /** @brief Set the scene
    *
    *  The scene is a collection of objects and lights
    *  along with all the data required to shade those. The scene is
    *  used by the context to render the image.
    *
    *  @param  context     The context to set the scene
    *  @param  scene       The scene to set
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetScene(rpr_context context, rpr_scene scene);


    /** @brief Get the current scene
    *
    *  The scene is a collection of objects and lights
    *  along with all the data required to shade those. The scene is
    *  used by the context ro render the image.
    *
    *  @param  context     The context to get the scene from
    *  @param  out_scene   Pointer to scene object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetScene(rpr_context arg0, rpr_scene * out_scene);


    /** @brief Set context parameter
    *
    * Parameters are used to control rendering modes, global sampling and AA settings, etc
    *
    * @param  context                        The context to set the value to
    * @param  in_input						  Param name, can be any  RPR_CONTEXT_*  value
    * @param x,y,z,w						   Parameter value
    * @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey1u(rpr_context context, rpr_context_info in_input, rpr_uint x);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKeyPtr(rpr_context context, rpr_context_info in_input, void * x);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey1f(rpr_context context, rpr_context_info in_input, rpr_float x);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey3f(rpr_context context, rpr_context_info in_input, rpr_float x, rpr_float y, rpr_float z);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey4f(rpr_context context, rpr_context_info in_input, rpr_float x, rpr_float y, rpr_float z, rpr_float w);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKeyString(rpr_context context, rpr_context_info in_input, rpr_char const * value);


    /** @brief This is an internal/experimental backdoor for RPR developers team.
    *
    * A classic usage of RPR doesn't require usage of this call.
    * Use this only if you understand what you are doing.
    * It's sending the name/value directly to the plugin without any process of RPR API.
    * the 'paramName' is not related with the parameters of rprContextSetParameterByKey4f.
    * 'pluginIndex' can be used if the context has more than one plugin - Not Implemented for now, set it to 0.
    */
  extern RPR_API_ENTRY rpr_status rprContextSetInternalParameter4f(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_float x, rpr_float y, rpr_float z, rpr_float w);
extern RPR_API_ENTRY rpr_status rprContextSetInternalParameter1u(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_uint x);
extern RPR_API_ENTRY rpr_status rprContextSetInternalParameterBuffer(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, void const * buffer, size_t bufferSizeByte);
extern RPR_API_ENTRY rpr_status rprContextGetInternalParameter4f(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_float * x, rpr_float * y, rpr_float * z, rpr_float * w);
extern RPR_API_ENTRY rpr_status rprContextGetInternalParameter1u(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_uint * x);
extern RPR_API_ENTRY rpr_status rprContextGetInternalParameterBuffer(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, size_t bufferSizeByte, void * buffer, size_t * size_ret);


    /** @brief Perform evaluation and accumulation of a single sample (or number of AA samples if AA is enabled)
    *
    *  The call is blocking and the image is ready when returned. The context accumulates the samples in order
    *  to progressively refine the image and enable interactive response. So each new call to Render refines the
    *  resultin image with 1 (or num aa samples) color samples. Call rprFrameBufferClear if you want to start rendering new image
    *  instead of refining the previous one.
    *
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_INTERNAL_ERROR
    *      RPR_ERROR_MATERIAL_STACK_OVERFLOW
    *
    *  if you have the RPR_ERROR_MATERIAL_STACK_OVERFLOW error, you have created a shader graph with too many nodes.
    *  you can check the nodes limit with rprContextGetInfo(,RPR_CONTEXT_MATERIAL_STACK_SIZE,)
    *
    *  @param  context     The context object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextRender(rpr_context context);


    /** @brief  can be called in a different thread to interrupt the rendering
	*  then, rprContextRender will return  RPR_ERROR_ABORTED instead of RPR_SUCCESS
    */
  extern RPR_API_ENTRY rpr_status rprContextAbortRender(rpr_context context);


    /** @brief Perform evaluation and accumulation of a single sample (or number of AA samples if AA is enabled) on the part of the image
    *
    *  The call is blocking and the image is ready when returned. The context accumulates the samples in order
    *  to progressively refine the image and enable interactive response. So each new call to Render refines the
    *  resultin image with 1 (or num aa samples) color samples. Call rprFrameBufferClear if you want to start rendering new image
    *  instead of refining the previous one. Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_INTERNAL_ERROR
    *
    *  @param  context     The context to use for the rendering
    *  @param  xmin        X coordinate of the top left corner of a tile
    *  @param  xmax        X coordinate of the bottom right corner of a tile
    *  @param  ymin        Y coordinate of the top left corner of a tile
    *  @param  ymax        Y coordinate of the bottom right corner of a tile
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextRenderTile(rpr_context context, rpr_uint xmin, rpr_uint xmax, rpr_uint ymin, rpr_uint ymax);


    /** @brief Clear all video memory used by the context
    *
    *  This function should be called after all context objects have been destroyed.
    *  It guarantees that all context memory is freed and returns the context into its initial state.
    *  Will be removed later. Possible error codes are:
    *
    *      RPR_ERROR_INTERNAL_ERROR
    *
    *  @param  context     The context to wipe out
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextClearMemory(rpr_context context);


    /** @brief Create an image from memory data
    *
    *  Images are used as HDRI maps or inputs for various shading system nodes.
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context     The context to create image
    *  @param  format      Image format
    *  @param  image_desc  Image layout description
    *  @param  data        Image data in system memory, can be NULL in which case the memory is allocated
    *  @param  out_image   Pointer to image object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateImage(rpr_context context, rpr_image_format const format, rpr_image_desc const * image_desc, void const * data, rpr_image * out_image);


    /** @brief Create a buffer from memory data
    *
    *  Buffers are used as arbitrary input for other nodes
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context     The context to create image
    *  @param  buffer_desc Buffer layout description
    *  @param  data        Image data in system memory, can be NULL in which case the memory is allocated
    *  @param  out_buffer  Pointer to buffer object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateBuffer(rpr_context context, rpr_buffer_desc const * buffer_desc, void const * data, rpr_buffer * out_buffer);


    /** @brief Create an image from file
    *
    *   Images are used as HDRI maps or inputs for various shading system nodes.
    *
    *  The following image formats are supported:
    *      PNG, JPG, TGA, BMP, TIFF, TX(0-mip), HDR, EXR
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_IO_ERROR
    *
    *  @param  context     The context to create image
    *  @param  path        NULL terminated path to an image file (can be relative) (for UNICODE, supports UTF-8 encoding)
    *  @param  out_image   Pointer to image object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateImageFromFile(rpr_context context, rpr_char const * path, rpr_image * out_image);


    /** @brief  similar to rprContextCreateImageFromFile, except that the file input as a memory buffer
    *   extension must look like : ".png" , ".bmp" , ".hdr" , ".exr" , ".jpg" ....
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateImageFromFileMemory(rpr_context context, rpr_char const * extension, void const * data, size_t dataSizeByte, rpr_image * out_image);


    /** @brief Create a scene
    *
    *  Scene serves as a container for lights and objects.
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  out_scene   Pointer to scene object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateScene(rpr_context context, rpr_scene * out_scene);


    /** @brief Create an instance of an object
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context  The context to create an instance for
    *  @param  shape    Parent shape for an instance
    *  @param  out_instance   Pointer to instance object
    *  @return RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateInstance(rpr_context context, rpr_shape shape, rpr_shape * out_instance);


    /** @brief Create a mesh
    *
    *  Radeon ProRender supports mixed meshes consisting of triangles and quads.
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  vertices            Pointer to position data (each position is described with 3 rpr_float numbers)
    *  @param  num_vertices        Number of entries in position array
    *  @param  vertex_stride       Number of bytes between the beginnings of two successive position entries
    *  @param  normals             Pointer to normal data (each normal is described with 3 rpr_float numbers), can be NULL
    *  @param  num_normals         Number of entries in normal array
    *  @param  normal_stride       Number of bytes between the beginnings of two successive normal entries
    *  @param  texcoord            Pointer to texcoord data (each texcoord is described with 2 rpr_float numbers), can be NULL
    *  @param  num_texcoords       Number of entries in texcoord array
    *  @param  texcoord_stride     Number of bytes between the beginnings of two successive texcoord entries
    *  @param  vertex_indices      Pointer to an array of vertex indices
    *  @param  vidx_stride         Number of bytes between the beginnings of two successive vertex index entries
    *  @param  normal_indices      Pointer to an array of normal indices
    *  @param  nidx_stride         Number of bytes between the beginnings of two successive normal index entries
    *  @param  texcoord_indices    Pointer to an array of texcoord indices
    *  @param  tidx_stride         Number of bytes between the beginnings of two successive texcoord index entries
    *  @param  num_face_vertices   Pointer to an array of num_faces numbers describing number of vertices for each face (can be 3(triangle) or 4(quad))
    *  @param  num_faces           Number of faces in the mesh
    *  @param  out_mesh            Pointer to mesh object
    *  @return                     RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateMesh(rpr_context context, rpr_float const * vertices, size_t num_vertices, rpr_int vertex_stride, rpr_float const * normals, size_t num_normals, rpr_int normal_stride, rpr_float const * texcoords, size_t num_texcoords, rpr_int texcoord_stride, rpr_int const * vertex_indices, rpr_int vidx_stride, rpr_int const * normal_indices, rpr_int nidx_stride, rpr_int const * texcoord_indices, rpr_int tidx_stride, rpr_int const * num_face_vertices, size_t num_faces, rpr_shape * out_mesh);


    /*  @brief Create a mesh
    *
    *  @return                     RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateMeshEx(rpr_context context, rpr_float const * vertices, size_t num_vertices, rpr_int vertex_stride, rpr_float const * normals, size_t num_normals, rpr_int normal_stride, rpr_int const * perVertexFlag, size_t num_perVertexFlags, rpr_int perVertexFlag_stride, rpr_int numberOfTexCoordLayers, rpr_float const ** texcoords, size_t const * num_texcoords, rpr_int const * texcoord_stride, rpr_int const * vertex_indices, rpr_int vidx_stride, rpr_int const * normal_indices, rpr_int nidx_stride, rpr_int const ** texcoord_indices, rpr_int const * tidx_stride, rpr_int const * num_face_vertices, size_t num_faces, rpr_shape * out_mesh);


    /*  @brief Create a mesh
    *
    *  @return                     RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateMeshEx2(rpr_context context, rpr_float const * vertices, size_t num_vertices, rpr_int vertex_stride, rpr_float const * normals, size_t num_normals, rpr_int normal_stride, rpr_int const * perVertexFlag, size_t num_perVertexFlags, rpr_int perVertexFlag_stride, rpr_int numberOfTexCoordLayers, rpr_float const ** texcoords, size_t const * num_texcoords, rpr_int const * texcoord_stride, rpr_int const * vertex_indices, rpr_int vidx_stride, rpr_int const * normal_indices, rpr_int nidx_stride, rpr_int const ** texcoord_indices, rpr_int const * tidx_stride, rpr_int const * num_face_vertices, size_t num_faces, rpr_mesh_info const * mesh_properties, rpr_shape * out_mesh);


    /** @brief Create a camera
    *
    *  There are several camera types supported by a single rpr_camera type.
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  @param  context The context to create a camera for
    *  @param  out_camera Pointer to camera object
    *  @return RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateCamera(rpr_context context, rpr_camera * out_camera);


    /** @brief Create framebuffer object
    *
    *  Framebuffer is used to store final rendering result.
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  @param  context  The context to create framebuffer
    *  @param  format   Framebuffer format
    *  @param  fb_desc  Framebuffer layout description
    *  @param  status   Pointer to framebuffer object
    *  @return          RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateFrameBuffer(rpr_context context, rpr_framebuffer_format const format, rpr_framebuffer_desc const * fb_desc, rpr_framebuffer * out_fb);


      /** @brief Loads extension function from context
      */
  extern RPR_API_ENTRY rpr_status rprContextGetFunctionPtr(rpr_context context, rpr_char const * function_name, void ** out_function_ptr);

/* rpr_camera */
    /** @brief Query information about a camera
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data.
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  camera      The camera to query
    *  @param  camera_info The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraGetInfo(rpr_camera camera, rpr_camera_info camera_info, size_t size, void * data, size_t * size_ret);


    /** @brief Set camera focal length.
    *
    *  @param  camera  The camera to set focal length
    *  @param  flength Focal length in millimeters, default is 35mm
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFocalLength(rpr_camera camera, rpr_float flength);


    /* Number of motion matrices (set with rprCameraSetMotionTransform) to use.
    *  Set  transformCount=0  if you don't use Motion.
    *  For the moment, if you use motion in Northstar, only transformCount=1 is supported.
    *  example: to create a motion from matA to matB:
    *      rprCameraSetTransform(camera, false, matA) // matrix at time=0
    *      rprCameraSetMotionTransform(camera, false, matB, 1) // matrix at time=1
    *      rprCameraSetMotionTransformCount(camera,1) // use 1 motion matrix
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetMotionTransformCount(rpr_camera camera, rpr_uint transformCount);


    /* For Motion effect, set the transform of camera at different time index.
    * 'transform' is an array of 16 rpr_float values (row-major form).
    *  timeIndex=1 is camera position at camera exposure = 1.0
    *  For the moment, in Nortstar plugin only timeIndex=1 is implemented
    *  You also have to call  rprCameraSetMotionTransformCount, to define the number of indices to use.
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetMotionTransform(rpr_camera camera, rpr_bool transpose, rpr_float const * transform, rpr_uint timeIndex);


    /** @brief Set camera focus distance
    *
    *  @param  camera  The camera to set focus distance
    *  @param  fdist   Focus distance in meters, default is 1m
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFocusDistance(rpr_camera camera, rpr_float fdist);


    /** @brief Set world transform for the camera
    *
    *  @param  camera      The camera to set transform for
    *  @param  transpose   Determines whether the basis vectors are in columns(false) or in rows(true) of the matrix
    *  @param  transform   Array of 16 rpr_float values (row-major form)
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetTransform(rpr_camera camera, rpr_bool transpose, rpr_float const * transform);


    /** @brief Set sensor size for the camera
    *
    *  Default sensor size is the one corresponding to full frame 36x24mm sensor
    *
    *  @param  camera  The camera to set transform for
    *  @param  width   Sensor width in millimeters
    *  @param  height  Sensor height in millimeters
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetSensorSize(rpr_camera camera, rpr_float width, rpr_float height);


    /** @brief Set camera transform in lookat form
    *
    *  @param  camera  The camera to set transform for
    *  @param  posx    X component of the position
    *  @param  posy    Y component of the position
    *  @param  posz    Z component of the position
    *  @param  atx     X component of the center point
    *  @param  aty     Y component of the center point
    *  @param  atz     Z component of the center point
    *  @param  upx     X component of the up vector
    *  @param  upy     Y component of the up vector
    *  @param  upz     Z component of the up vector
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraLookAt(rpr_camera camera, rpr_float posx, rpr_float posy, rpr_float posz, rpr_float atx, rpr_float aty, rpr_float atz, rpr_float upx, rpr_float upy, rpr_float upz);


    /** @brief Set f-stop for the camera
    *
    *  @param  camera  The camera to set f-stop for
    *  @param  fstop   f-stop value in mm^-1, default is FLT_MAX
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFStop(rpr_camera camera, rpr_float fstop);


    /** @brief Set the number of aperture blades
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  camera      The camera to set aperture blades for
    *  @param  num_blades  Number of aperture blades 4 to 32
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetApertureBlades(rpr_camera camera, rpr_uint num_blades);


    /** @brief Set the exposure of a camera
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  camera    The camera to set aperture blades for
    *  @param  exposure  Represents a time length in the same time scale than rprShapeSetMotionTransform,rprCameraSetMotionTransform...
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetExposure(rpr_camera camera, rpr_float exposure);


    /** @brief Set camera mode
    *
    *  Camera modes include:
    *      RPR_CAMERA_MODE_PERSPECTIVE
    *      RPR_CAMERA_MODE_ORTHOGRAPHIC
    *      RPR_CAMERA_MODE_LATITUDE_LONGITUDE_360
    *      RPR_CAMERA_MODE_LATITUDE_LONGITUDE_STEREO
    *      RPR_CAMERA_MODE_CUBEMAP
    *      RPR_CAMERA_MODE_CUBEMAP_STEREO
    *      RPR_CAMERA_MODE_FISHEYE
    *
    *  @param  camera  The camera to set mode for
    *  @param  mode    Camera mode, default is RPR_CAMERA_MODE_PERSPECTIVE
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetMode(rpr_camera camera, rpr_camera_mode mode);


    /** @brief Set orthographic view volume width
    *
    *  @param  camera  The camera to set volume width for
    *  @param  width   View volume width in meters, default is 1 meter
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetOrthoWidth(rpr_camera camera, rpr_float width);
extern RPR_API_ENTRY rpr_status rprCameraSetFocalTilt(rpr_camera camera, rpr_float tilt);
extern RPR_API_ENTRY rpr_status rprCameraSetIPD(rpr_camera camera, rpr_float ipd);
extern RPR_API_ENTRY rpr_status rprCameraSetLensShift(rpr_camera camera, rpr_float shiftx, rpr_float shifty);
extern RPR_API_ENTRY rpr_status rprCameraSetTiltCorrection(rpr_camera camera, rpr_float tiltX, rpr_float tiltY);


    /** @brief Set orthographic view volume height
    *
    *  @param  camera  The camera to set volume height for
    *  @param  width   View volume height in meters, default is 1 meter
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetOrthoHeight(rpr_camera camera, rpr_float height);


    /** @brief Set near plane of a camera
    *
    *  @param  camera  The camera to set near plane for
    *  @param  near   Near plane distance in meters, default is 0.01f
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetNearPlane(rpr_camera camera, rpr_float near);


    /** @brief Set the post scale of camera ( 2D camera zoom )
    *
    *  @param  camera  The camera to set
    *  @param  scale   post scale value.
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetPostScale(rpr_camera camera, rpr_float scale);


    /** @brief Set far plane of a camera
    *
    *  @param  camera  The camera to set far plane for
    *  @param  far   Far plane distance in meters, default is 100000000.f
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFarPlane(rpr_camera camera, rpr_float far);


    /** @brief Set distorion image for camera
    *
    *  @param  camera          The camera to set UV Distortion for
    *  @param  distortionMap   distorion image
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetUVDistortion(rpr_camera camera, rpr_image distortionMap);

/* rpr_image*/
    /** @brief Query information about an image
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  image       An image object to query
    *  @param  image_info  The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprImageGetInfo(rpr_image image, rpr_image_info image_info, size_t size, void * data, size_t * size_ret);


    /** @brief
    * 
    * this is DEPRECATED in the Northstar plugin.
    * In this plugin, the wrapping is done inside the RPR_MATERIAL_NODE_IMAGE_TEXTURE owning the image, 
    * example: rprMaterialNodeSetInputUByKey(materialNodeTexture, RPR_MATERIAL_INPUT_WRAP_U, RPR_IMAGE_WRAP_TYPE_REPEAT);
    *
    *  @param  image       The image to set wrap for
    *  @param  type
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprImageSetWrap(rpr_image image, rpr_image_wrap_type type);


    /** @brief
    * 
    * ( Northstar-only feature )
    * By default, images are compressed by the Northstar renderer.
    * Setting 'compressionEnabled'=0 will disable the compression for the images.
    * For better performance, it's advised to only disable it for textures that need it.
    *
    */
  extern RPR_API_ENTRY rpr_status rprImageSetInternalCompression(rpr_image image, rpr_uint compressionEnabled);


    /** @brief Set the OCIO Color Space
    *
    */
  extern RPR_API_ENTRY rpr_status rprImageSetOcioColorspace(rpr_image image, rpr_char const * ocioColorspace);


    /** @brief  Set a tile to an UDIM image.
    *
    *  @param  imageUdimRoot   must be an UDIM image  ( created with no data:  rprContextCreateImage(context, {0,RPR_COMPONENT_TYPE_UINT8}, nullptr, nullptr, ); )
    *  @param  tileIndex       a valid UDIM index: 1001 , 1002, 1003 ... 1011, 1012, 1013 ... etc ...
    *  @param  imageTile       a valid classic rpr_image
    */
  extern RPR_API_ENTRY rpr_status rprImageSetUDIM(rpr_image imageUdimRoot, rpr_uint tileIndex, rpr_image imageTile);


    /** @brief
    *
    *
    *  @param  image       The image to set filter for
    *  @param  type
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprImageSetFilter(rpr_image image, rpr_image_filter_type type);

/** @brief
*
*  @param  image       The image to set gamma for
*  @param  type
*  @return             RPR_SUCCESS in case of success, error code otherwise
*/extern RPR_API_ENTRY rpr_status rprImageSetGamma(rpr_image image, rpr_float type);

/** @brief
*
*  @param  image       The image to set mipmap for
*  @param  enabled     true (enable) or false (disable)
*  @return             RPR_SUCCESS in case of success, error code otherwise
*/extern RPR_API_ENTRY rpr_status rprImageSetMipmapEnabled(rpr_image image, rpr_bool enabled);

/* rpr_shape */
    /** @brief Set shape world transform
    *
    *
    *  @param  shape       The shape to set transform for
    *  @param  transpose   Determines whether the basis vectors are in columns(false) or in rows(true) of the matrix
    *  @param  transform   Array of 16 rpr_float values (row-major form)
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetTransform(rpr_shape shape, rpr_bool transpose, rpr_float const * transform);


    /** @brief assign custom float value to some vertices of the mesh
    *
    * example : 
    *   // indicesSet and values must have the same size
    *   rpr_int indicesSet[] = {4,0,1,2,3};
    *   rpr_float values[] = { 0.8 , 0.1 , 0.0 , 1.0 , 1.0 };
    *   rprShapeSetVertexValue(meshC, 0 , indicesSet , values , sizeof(indicesSet)/sizeof(indicesSet[0]) );
    *   
    *  setIndex can be between  0 and 3  :  we can assign up to 4 floats for each vertex.
    *
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVertexValue(rpr_shape in_shape, rpr_int setIndex, rpr_int const * indices, rpr_float const * values, rpr_int indicesCount);


    /* @brief set primvars data for a specific 'key'
    * 
    * A shape can have several primvars data. Each primvar of the shape is identified with a 'key'
    * 'data' is a list of float
    * 'floatCount' is a number of float in the 'data' buffer
    * 'componentCount' specifies the number of float(s) per component.  For example if you want to attach an RGB color to vertices, you need 'componentCount'=3  and  'floatCount' = 3 * 'number of vertices'
    * 'interop' defines how the data is interpolated.
    * 
    * @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetPrimvar(rpr_shape in_shape, rpr_uint key, rpr_float const * data, rpr_uint floatCount, rpr_uint componentCount, rpr_primvar_interpolation_type  interop);


    /** @brief Set shape subdivision
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  factor	   Number of subdivision steps to do
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionFactor(rpr_shape shape, rpr_uint factor);


    /** @brief Enable or Disable the auto ratio cap for subdivision
    *
    * autoRatioCap is a value from 0.0 to 1.0.
    * autoRatioCap=1.0 means very large polygons, less tessellation. as it goes to 0.0, it does more tessellation.
    * This value is ratio of the largest edge in the screen.
    * Example: If you want to make an edge 10 pixels on 1080p, you need to set 10/1080.
    *
    *  @param  shape           The shape to set
    *  @param  autoRatioCap    0.0 to 1.0
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionAutoRatioCap(rpr_shape shape, rpr_float autoRatioCap);


    /** @brief
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  factor
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionCreaseWeight(rpr_shape shape, rpr_float factor);


    /** @brief
    *
    *  @param  shape               The shape to set 
    *  @param  renderLayerString   Render layer name to attach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeAttachRenderLayer(rpr_shape shape, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  shape               The shape to set 
    *  @param  renderLayerString   Render layer name to detach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeDetachRenderLayer(rpr_shape shape, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  light               The light to set 
    *  @param  renderLayerString   Render layer name to attach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightAttachRenderLayer(rpr_light light, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  light               The light to set 
    *  @param  renderLayerString   Render layer name to detach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightDetachRenderLayer(rpr_light light, rpr_char const * renderLayerString);


    /** @brief
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  type
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionBoundaryInterop(rpr_shape shape, rpr_subdiv_boundary_interfop_type type);


    /** @brief Call this function to automatically set the Subdivision Factor depending on the camera position, frame buffer size.
    *          You can retrieve the internally computed factor with rprShapeGetInfo(...,RPR_SHAPE_SUBDIVISION_FACTOR,...)
    *          You have to call this function each time you want to re-adapt the Subdivision Factor :
    *          internally the factor will NOT be automatically re-computed when camera/shape/framebuffer changes.
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  framebuffer frame buffer used for factor adaptation
    *  @param  camera      camera used for factor adaptation
    *  @param  factor      factor to regulate the intensity of adaptation
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeAutoAdaptSubdivisionFactor(rpr_shape shape, rpr_framebuffer framebuffer, rpr_camera camera, rpr_int factor);


    /** @brief Set displacement scale
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  scale	   The amount of displacement applied
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetDisplacementScale(rpr_shape shape, rpr_float minscale, rpr_float maxscale);


    /** @brief Set object group ID (mainly for debugging).
    *
    *
    *  @param  shape          The shape to set
    *  @param  objectGroupID  The ID
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetObjectGroupID(rpr_shape shape, rpr_uint objectGroupID);


    /** @brief Set object ID (mainly for debugging).
    *
    *
    *  @param  shape          The shape to set
    *  @param  objectID       The ID
    *  @return                RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetObjectID(rpr_shape shape, rpr_uint objectID);


    /** @brief Set light group ID when shape has an emissive material (mainly for debugging).
    *
    *  @param  shape          The shape to set
    *  @param  lightGroupID  The ID
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetLightGroupID(rpr_shape shape, rpr_uint lightGroupID);


    /** @brief Set object rendering layer mask
    *          then, use   rprContextSetParameter1u(context,"renderLayerMask",mask)
    *          in order to render only a group of shape
    *
    *  @param  shape       The shape to set
    *  @param  layerMask   The render mask
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    *
    * WARNING: this function is deprecated and will be removed in the future, 
    *          use   rprShapeAttachRenderLayer/rprShapeDetachRenderLayer   and   rprContextAttachRenderLayer/rprContextDetachRenderLayer   instead
    *
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetLayerMask(rpr_shape shape, rpr_uint layerMask);


    /** @brief Set displacement texture
    *
    *
    *  @param  shape         The shape to set subdivision for
    *  @param  materialNode  Displacement texture , as material.
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetDisplacementMaterial(rpr_shape shape, rpr_material_node materialNode);


    /** @brief Set shape material
    *
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMaterial(rpr_shape shape, rpr_material_node node);


    /** @brief Set shape materials for specific faces
    *
    *  @param  shape	The shape to set the material for
    *  @param  node 	The material to set
    *  @param  face_indices
    *  @return		RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMaterialFaces(rpr_shape shape, rpr_material_node node, rpr_int const * face_indices, size_t num_faces);





    /** @brief Set shape volume material
    *
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVolumeMaterial(rpr_shape shape, rpr_material_node node);


    /* Number of motion matrices (set with rprShapeSetMotionTransform) to use.
    *  Set  transformCount=0  if you don't use Motion.
    *  For the moment, if you use motion in Northstar, only transformCount=1 is supported.
    *  example: to create a motion from matA to matB:
    *      rprShapeSetTransform(shape, false, matA) // matrix at time=0
    *      rprShapeSetMotionTransform(shape, false, matB, 1) // matrix at time=1
    *      rprShapeSetMotionTransformCount(shape,1) // use 1 motion matrix
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMotionTransformCount(rpr_shape shape, rpr_uint transformCount);


    /* For Motion effect, set the transform of shape at different time index.
    * 'transform' is an array of 16 rpr_float values (row-major form).
    *  timeIndex=1 is shape position at camera exposure = 1.0
    *  For the moment, in Nortstar plugin only timeIndex=1 is implemented
    *  You also have to call  rprShapeSetMotionTransformCount, to define the number of indices to use.
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMotionTransform(rpr_shape shape, rpr_bool transpose, rpr_float const * transform, rpr_uint timeIndex);


    /** @brief Set visibility flag
    *
    *  @param  shape           The shape to set visibility for
    *  @param  visibilityFlag   . one of the visibility flags :
    *                             RPR_SHAPE_VISIBILITY_PRIMARY_ONLY_FLAG
    *                             RPR_SHAPE_VISIBILITY_SHADOW
    *                             RPR_SHAPE_VISIBILITY_REFLECTION
    *                             RPR_SHAPE_VISIBILITY_REFRACTION
    *                             RPR_SHAPE_VISIBILITY_TRANSPARENT
    *                             RPR_SHAPE_VISIBILITY_DIFFUSE
    *                             RPR_SHAPE_VISIBILITY_GLOSSY_REFLECTION
    *                             RPR_SHAPE_VISIBILITY_GLOSSY_REFRACTION
    *                             RPR_SHAPE_VISIBILITY_LIGHT
    *                             RPR_SHAPE_VISIBILITY_RECEIVE_SHADOW
    *  @param  visible          set the flag to TRUE or FALSE
    *  @return                  RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVisibilityFlag(rpr_shape shape, rpr_shape_info visibilityFlag, rpr_bool visible);


    /** @brief Set visibility flag
    *
    *  @param  curve           The curve to set visibility for
    *  @param  visibilityFlag   . one of the visibility flags :
    *                             RPR_CURVE_VISIBILITY_PRIMARY_ONLY_FLAG
    *                             RPR_CURVE_VISIBILITY_SHADOW
    *                             RPR_CURVE_VISIBILITY_REFLECTION
    *                             RPR_CURVE_VISIBILITY_REFRACTION
    *                             RPR_CURVE_VISIBILITY_TRANSPARENT
    *                             RPR_CURVE_VISIBILITY_DIFFUSE
    *                             RPR_CURVE_VISIBILITY_GLOSSY_REFLECTION
    *                             RPR_CURVE_VISIBILITY_GLOSSY_REFRACTION
    *                             RPR_CURVE_VISIBILITY_LIGHT
    *                             RPR_CURVE_VISIBILITY_RECEIVE_SHADOW
    *  @param  visible          set the flag to TRUE or FALSE
    *  @return                  RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCurveSetVisibilityFlag(rpr_curve curve, rpr_curve_parameter visibilityFlag, rpr_bool visible);


    /** @brief Set visibility flag
    *
    * This function sets all RPR_SHAPE_VISIBILITY_* flags to the 'visible' argument value
    * Calling rprShapeSetVisibilityFlag(xxx,visible); on each flags would lead to the same result.
    *
    *  @param  shape       The shape to set visibility for
    *  @param  visible     Determines if the shape is visible or not
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVisibility(rpr_shape shape, rpr_bool visible);


    /** @brief Set visibility flag for Light
    *
    *  @param  light           The light to set visibility for
    *  @param  visibilityFlag     one of the visibility flags :
    *                            - RPR_LIGHT_VISIBILITY_LIGHT
    *  @param  visible          set the flag to TRUE or FALSE
    *  @return                  RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightSetVisibilityFlag(rpr_light light, rpr_light_info visibilityFlag, rpr_bool visible);


    /** @brief Set visibility flag
    *
    * This function sets all RPR_CURVE_VISIBILITY_* flags to the 'visible' argument value
    * Calling rprCurveSetVisibilityFlag(xxx,visible); on each flags would lead to the same result.
    *
    *  @param  curve       The curve to set visibility for
    *  @param  visible     Determines if the curve is visible or not
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCurveSetVisibility(rpr_curve curve, rpr_bool visible);


    /** @brief Set visibility flag for specular refleacted\refracted rays
    *
    * This function sets both RPR_SHAPE_VISIBILITY_REFLECTION and RPR_SHAPE_VISIBILITY_REFRACTION flags to the 'visible' argument value
    * Calling rprShapeSetVisibilityFlag(xxx,visible); on those 2 flags would lead to the same result.
    *
    *  @param  shape       The shape to set visibility for
    *  @param  visible     Determines if the shape is visible or not
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVisibilityInSpecular(rpr_shape shape, rpr_bool visible);


    /** @brief Set shadow catcher flag
    *
    *  @param  shape         The shape to set shadow catcher flag for
    *  @param  shadowCatcher Determines if the shape behaves as shadow catcher
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetShadowCatcher(rpr_shape shape, rpr_bool shadowCatcher);


    /** @brief Set shadow color
    *
    *  @param  shape         The shape to set shadow color for
    *  @param  r             Red component of the color
    *  @param  g             Green component of the color
    *  @param  b             Blue component of the color
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetShadowColor(rpr_shape shape, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set Reflection catcher flag
    *
    *  @param  shape             The shape to set Reflection catcher flag for
    *  @param  reflectionCatcher Determines if the shape behaves as Reflection catcher
    *  @return                   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetReflectionCatcher(rpr_shape shape, rpr_bool reflectionCatcher);


    /** @brief Set 1 if ignore shape in the Contour rendering flag.
    *   ( This flag is used only if Contour is enabled )
    *
    *  @param  shape             The shape to set
    *  @param  ignoreInContour   0 or 1.
    *  @return                   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetContourIgnore(rpr_shape shape, rpr_bool ignoreInContour);


    /** @brief Set 1 if the shape should be treated as an environment light (finite sphere environment light).
    *
    *  @param  shape             The shape to set
    *  @param  envLight   0 or 1.
    *  @return                   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetEnvironmentLight(rpr_shape shape, rpr_bool envLight);


      /**
      * Sets static flag on shape.
      *
      * Setting such flag will result in marking object as static.
      * Such objects can be processed more efficiently but with some restrictions:
      * @li Static object can't change its properties.
      * @li Static object can't change its transformation.
      *
      * @note Static flag can be set only before first call to rprContextRender.
      * By default all objects created as dynamic.
      *
      * @param in_shape shape to set flag on
      * @param in_is_static is object static or not
      */
  extern RPR_API_ENTRY rpr_status rprShapeMarkStatic(rpr_shape in_shape, rpr_bool in_is_static);


    /** @brief Set light world transform
    *
    *
    *  @param  light       The light to set transform for
    *  @param  transpose   Determines whether the basis vectors are in columns(false) or in rows(true) of the matrix
    *  @param  transform   Array of 16 rpr_float values (row-major form)
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightSetTransform(rpr_light light, rpr_bool transpose, rpr_float const * transform);


    /** @brief Set light group ID. This parameter can be used with RPR_AOV_LIGHT_GROUP0, RPR_AOV_LIGHT_GROUP1, ...
    *
    *  @param  light       The light to set transform for
    *  @param  groupId     -1 to remove the group.  or a value between 0 and 3.
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightSetGroupId(rpr_light light, rpr_uint groupId);


    /** @brief Query information about a shape
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape           The shape object to query
    *  @param  material_info   The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeGetInfo(rpr_shape arg0, rpr_shape_info arg1, size_t arg2, void * arg3, size_t * arg4);

/* rpr_shape - mesh */
    /** @brief Query information about a mesh
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape       The mesh to query
    *  @param  mesh_info   The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprMeshGetInfo(rpr_shape mesh, rpr_mesh_info mesh_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a Curve
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape       The Curve to query
    *  @param  rpr_curve_parameter   The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCurveGetInfo(rpr_curve curve, rpr_curve_parameter curve_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a hetero volume
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  heteroVol       The heteroVolume to query
    *  @param  heteroVol_info  The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprHeteroVolumeGetInfo(rpr_hetero_volume heteroVol, rpr_hetero_volume_parameter heteroVol_info, size_t size, void * data, size_t * size_ret);
extern RPR_API_ENTRY rpr_status rprGridGetInfo(rpr_grid grid, rpr_grid_parameter grid_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a Buffer
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  buffer       The heteroVolume to query
    *  @param  buffer_info  The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprBufferGetInfo(rpr_buffer buffer, rpr_buffer_info buffer_info, size_t size, void * data, size_t * size_ret);


    /** @brief Get the parent shape for an instance
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape    The shape to get a parent shape from
    *  @param  status   RPR_SUCCESS in case of success, error code otherwise
    *  @return          Shape object
    */
  extern RPR_API_ENTRY rpr_status rprInstanceGetBaseShape(rpr_shape shape, rpr_shape * out_shape);

/* rpr_light - point */
    /** @brief Create point light
    *
    *  Create analytic point light represented by a point in space.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreatePointLight(rpr_context context, rpr_light * out_light);


    /** @brief Set radiant power of a point light source
    *
    *  @param  r       R component of a radiant power vector
    *  @param  g       G component of a radiant power vector
    *  @param  b       B component of a radiant power vector
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprPointLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);

/* rpr_light - spot */
    /** @brief Create spot light
    *
    *  Create analytic spot light
    *
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateSpotLight(rpr_context context, rpr_light * light);
extern RPR_API_ENTRY rpr_status rprContextCreateSphereLight(rpr_context context, rpr_light * light);
extern RPR_API_ENTRY rpr_status rprContextCreateDiskLight(rpr_context context, rpr_light * light);


    /** @brief Set radiant power of a spot light source
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSpotLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief turn this spot-light into a textured light.
    *
    * 'img' can be NULL to disable textured.
    */
  extern RPR_API_ENTRY rpr_status rprSpotLightSetImage(rpr_light light, rpr_image img);


    /** @brief Set Power for Sphere Light
    *
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSphereLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set Radius for Sphere Light
    *
    *
    *  @param radius  Radius to set
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSphereLightSetRadius(rpr_light light, rpr_float radius);


    /** @brief Set Power for Disk Light
    *
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set Radius for Disk Light
    *
    *
    *  @param radius  Radius to set
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetRadius(rpr_light light, rpr_float radius);


    /** @brief Set Outer Angle for Disk Light
    *
    *
    *  @param  angle Outer angle in radians
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetAngle(rpr_light light, rpr_float angle);


    /** @brief Set Inner Angle for Disk Light
    *
    *  @param  innerAngle Inner angle in radians
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetInnerAngle(rpr_light light, rpr_float innerAngle);


    /** @brief Set cone shape for a spot light
    *
    * Spot light produces smooth penumbra in a region between inner and outer circles,
    * the area inside the inner cicrle receives full power while the area outside the
    * outer one is fully in shadow.
    *
    *  @param  iangle Inner angle of a cone in radians
    *  @param  oangle Outer angle of a coner in radians, should be greater that or equal to inner angle
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSpotLightSetConeShape(rpr_light light, rpr_float iangle, rpr_float oangle);

/* rpr_light - directional */
    /** @brief Create directional light
    *
    *  Create analytic directional light.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return light id of a newly created light
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateDirectionalLight(rpr_context context, rpr_light * out_light);


    /** @brief Set radiant power of a directional light source
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDirectionalLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set softness of shadow produced by the light
    *
    *  @param  softnessAngle  (in Radian)  value should be between [ 0 ; pi/4 ]. 0.0 means sharp shadow
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDirectionalLightSetShadowSoftnessAngle(rpr_light light, rpr_float softnessAngle);

/* rpr_light - environment */
    /** @brief Create an environment light
    *
    *  Environment light is a light based on lightprobe.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateEnvironmentLight(rpr_context context, rpr_light * out_light);


    /** @brief Set image for an environment light
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *
    *  @param  env_light Environment light
    *  @param  image     Image object to set
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightSetImage(rpr_light env_light, rpr_image image);


    /** @brief Set intensity scale or an env light
    *
    *  @param  env_light       Environment light
    *  @param  intensity_scale Intensity scale
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightSetIntensityScale(rpr_light env_light, rpr_float intensity_scale);


    /** @brief Set portal for environment light to accelerate convergence of indoor scenes
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  env_light Environment light
    *  @param  portal    Portal mesh, might have multiple components
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightAttachPortal(rpr_scene scene, rpr_light env_light, rpr_shape portal);


    /** @brief Remove portal for environment light.
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  env_light Environment light
    *  @param  portal    Portal mesh, that have been added to light.
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightDetachPortal(rpr_scene scene, rpr_light env_light, rpr_shape portal);


      /**
      * Sets/Gets environment override on IBL
      *
      * This function sets overrides for different parts of IBL.
      * overrideType argument can take following values:
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFLECTION
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFRACTION
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_TRANSPARENCY
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_BACKGROUND
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_IRRADIANCE
      *
      * @param in_ibl image based light created with rprContextCreateEnvironmentLight
      * @param overrideType override parameter
      * @param in_iblOverride image based light created with rprContextCreateEnvironmentLight
      */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightSetEnvironmentLightOverride(rpr_light in_ibl, rpr_environment_override overrideType, rpr_light in_iblOverride);
extern RPR_API_ENTRY rpr_status rprEnvironmentLightGetEnvironmentLightOverride(rpr_light in_ibl, rpr_environment_override overrideType, rpr_light* out_iblOverride);

/* rpr_light - sky */
    /** @brief Create sky light
    *
    *  Analytical sky model
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateSkyLight(rpr_context context, rpr_light * out_light);


    /** @brief Set turbidity of a sky light
    *
    *  @param  skylight        Sky light
    *  @param  turbidity       Turbidity value
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetTurbidity(rpr_light skylight, rpr_float turbidity);


    /** @brief Set albedo of a sky light
    *
    *  @param  skylight        Sky light
    *  @param  albedo          Albedo value
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetAlbedo(rpr_light skylight, rpr_float albedo);


    /** @brief Set scale of a sky light
    *
    *  @param  skylight        Sky light
    *  @param  scale           Scale value
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetScale(rpr_light skylight, rpr_float scale);


    /** @brief Set the direction of the sky light
    *
    *  @param  skylight        Sky light
    *  @param  x               direction x
    *  @param  y               direction y
    *  @param  z               direction z
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetDirection(rpr_light skylight, rpr_float x, rpr_float y, rpr_float z);


    /** @brief Set portal for sky light to accelerate convergence of indoor scenes
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  skylight  Sky light
    *  @param  portal    Portal mesh, might have multiple components
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightAttachPortal(rpr_scene scene, rpr_light skylight, rpr_shape portal);


    /** @brief Remove portal for Sky light.
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  env_light Sky light
    *  @param  portal    Portal mesh, that have been added to light.
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightDetachPortal(rpr_scene scene, rpr_light skylight, rpr_shape portal);


    /** @brief Create IES light
    *
    *  Create IES light
    *
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateIESLight(rpr_context context, rpr_light * light);


    /** @brief Set radiant power of a IES light source
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprIESLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set image for an IES light
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT : If the format of the IES file is not supported by Radeon ProRender.
    *      RPR_ERROR_IO_ERROR : If the IES image path file doesn't exist.
    *
    *  @param  env_light     Environment light
    *  @param  imagePath     Image path to set (for UNICODE, supports UTF-8 encoding)
    *  @param  nx			  resolution X of the IES image
    *  @param  ny            resolution Y of the IES image
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprIESLightSetImageFromFile(rpr_light env_light, rpr_char const * imagePath, rpr_int nx, rpr_int ny);


    /** @brief Set image for an IES light
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT : If the format of the IES data is not supported by Radeon ProRender.
    *
    *  @param  env_light     Environment light
    *  @param  iesData       Image data string defining the IES. null terminated string. IES format.
    *  @param  nx			  resolution X of the IES image
    *  @param  ny            resolution Y of the IES image
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprIESLightSetImageFromIESdata(rpr_light env_light, rpr_char const * iesData, rpr_int nx, rpr_int ny);

/* rpr_light */
    /** @brief Query information about a light
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  light    The light to query
    *  @param  light_info The type of info to query
    *  @param  size     The size of the buffer pointed by data
    *  @param  data     The buffer to store queried info
    *  @param  size_ret Returns the size in bytes of the data being queried
    *  @return          RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightGetInfo(rpr_light light, rpr_light_info info, size_t size, void * data, size_t * size_ret);

/* rpr_scene */
    /** @brief Remove all objects from a scene
    *          Also detaches the camera
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene   The scene to clear
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneClear(rpr_scene scene);


    /** @brief Attach a shape to the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene  The scene to attach
    *  @param  shape  The shape to attach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneAttachShape(rpr_scene scene, rpr_shape shape);


    /** @brief Detach a shape from the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene   The scene to dettach from
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneDetachShape(rpr_scene scene, rpr_shape shape);


    /** @brief Attach a heteroVolume to the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene  The scene to attach
    *  @param  heteroVolume  The heteroVolume to attach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneAttachHeteroVolume(rpr_scene scene, rpr_hetero_volume heteroVolume);


    /** @brief Detach a heteroVolume from the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene   The scene to dettach from
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneDetachHeteroVolume(rpr_scene scene, rpr_hetero_volume heteroVolume);
extern RPR_API_ENTRY rpr_status rprSceneAttachCurve(rpr_scene scene, rpr_curve curve);
extern RPR_API_ENTRY rpr_status rprSceneDetachCurve(rpr_scene scene, rpr_curve curve);
extern RPR_API_ENTRY rpr_status rprCurveSetMaterial(rpr_curve curve, rpr_material_node material);
extern RPR_API_ENTRY rpr_status rprCurveSetTransform(rpr_curve curve, rpr_bool transpose, rpr_float const * transform);


/** @brief Create a set of curves
*
*  A rpr_curve is a set of curves
*  A curve is a set of segments
*  A segment is always composed of 4 3D points
*
*  @param controlPointsData  array of rpr_float[num_controlPoints*3]
*
*  @param controlPointsStride  in most of cases, for contiguous controlPointsData, should be set to 3*sizeof(float)
*
*  @param num_indices  should be set at : 4*(number of segments)
*
*  @param indicesData  array of rpr_uint[num_indices] .
*                      those are indices to the controlPointsData array.
*
*  @param radius  array of N float. 
*                 if curve is not tapered, N = curveCount.
*                 if curve is tapered, N = 2*(number of segments)
*
*  @param textureUV   array of float2[curveCount]. 
*
*  @param segmentPerCurve   array of rpr_int[curveCount]. 
*                           (number of segments) = sum of each element of this array.
*
*  @param  creationFlag_tapered  Set it to 0 by default.
*                                Set to 1 if using tapered radius.
*                                May be used for other bit field options in the future (so, don't set it to a value > 1 for now.)
*
*/
extern RPR_API_ENTRY rpr_status rprContextCreateCurve(rpr_context context, rpr_curve * out_curve, size_t num_controlPoints, rpr_float const * controlPointsData, rpr_int controlPointsStride, size_t num_indices, rpr_uint curveCount, rpr_uint const * indicesData, rpr_float const * radius, rpr_float const * textureUV, rpr_int const * segmentPerCurve, rpr_uint creationFlag_tapered);


    /** @brief Attach a light to the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions
    *
    *  @param  scene  The scene to attach
    *  @param  light  The light to attach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneAttachLight(rpr_scene scene, rpr_light light);


    /** @brief Detach a light from the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions
    *
    *  @param  scene  The scene to dettach from
    *  @param  light  The light to detach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneDetachLight(rpr_scene scene, rpr_light light);


      /**
      * Sets/gets environment override as active in scene
      *
      * @param in_scene scene
      * @param in_light ibl
      */
  extern RPR_API_ENTRY rpr_status rprSceneSetEnvironmentLight(rpr_scene in_scene, rpr_light in_light);
extern RPR_API_ENTRY rpr_status rprSceneGetEnvironmentLight(rpr_scene in_scene, rpr_light* out_light);


    /** @brief Query information about a scene
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  scene    The scene to query
    *  @param  info     The type of info to query
    *  @param  size     The size of the buffer pointed by data
    *  @param  data     The buffer to store queried info
    *  @param  size_ret Returns the size in bytes of the data being queried
    *  @return          RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetInfo(rpr_scene scene, rpr_scene_info info, size_t size, void * data, size_t * size_ret);


    /** @brief Set background image for the scene which does not affect the scene lighting,
    *    it is shown as view-independent rectangular background
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  scene  The scene to set background for
    *  @param  image  Background image
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneSetBackgroundImage(rpr_scene scene, rpr_image image);


    /** @brief Get background image
    *
    *  @param  scene  The scene to get background image from
    *  @param  status RPR_SUCCESS in case of success, error code otherwise
    *  @return        Image object
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetBackgroundImage(rpr_scene scene, rpr_image * out_image);


    /** @brief Set right camera for the scene
    *
    *  This is the main camera which for rays generation for the scene.
    *
    *  @param  scene  The scene to set camera for
    *  @param  camera Camera
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneSetCameraRight(rpr_scene scene, rpr_camera camera);


    /** @brief Get right camera for the scene
    *
    *  @param  scene  The scene to get camera for
    *  @param  status RPR_SUCCESS in case of success, error code otherwise
    *  @return camera id for the camera if any, NULL otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetCameraRight(rpr_scene scene, rpr_camera * out_camera);


    /** @brief Set camera for the scene
    *
    *  This is the main camera which for rays generation for the scene.
    *
    *  @param  scene  The scene to set camera for
    *  @param  camera Camera
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneSetCamera(rpr_scene scene, rpr_camera camera);


    /** @brief Get camera for the scene
    *
    *  @param  scene  The scene to get camera for
    *  @param  status RPR_SUCCESS in case of success, error code otherwise
    *  @return camera id for the camera if any, NULL otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetCamera(rpr_scene scene, rpr_camera * out_camera);


    /** @brief Query information about a framebuffer
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  framebuffer  Framebuffer object to query
    *  @param  info         The type of info to query
    *  @param  size         The size of the buffer pointed by data
    *  @param  data         The buffer to store queried info
    *  @param  size_ret     Returns the size in bytes of the data being queried
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferGetInfo(rpr_framebuffer framebuffer, rpr_framebuffer_info info, size_t size, void * data, size_t * size_ret);


    /** @brief Clear contents of a framebuffer to zero
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  The call is blocking and the image is ready when returned
    *
    *  @param  frame_buffer  Framebuffer to clear
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferClear(rpr_framebuffer frame_buffer);


    /** @brief Fill contents of a framebuffer with a single color
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  The call is blocking and the image is ready when returned.
    *  If you want to fill with zeros, it's advised to use rprFrameBufferClear.
    *
    *  @param  frame_buffer  Framebuffer to clear
    *  @param r,g,b,a : the color to fill
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferFillWithColor(rpr_framebuffer frame_buffer, rpr_float r, rpr_float g, rpr_float b, rpr_float a);


    /** @brief Save frame buffer to file. In case the file format is .bin, the header of the saved file contains
    * rpr_framebuffer_desc and rpr_framebuffer_format at very begining. The remaining data is raw data of saved framebuffer.
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  @param  frame_buffer Frame buffer to save
    *  @param  file_path    Path to file (for UNICODE, supports UTF-8 encoding)
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferSaveToFile(rpr_framebuffer frame_buffer, rpr_char const * file_path);


    /** @brief Save frame buffer to file
    *
    *  Same that rprFrameBufferSaveToFile, but more options.
    *  A list of frambuffers can be given, they will be saved to a multilayer EXR.
    *
    *  'extraOptions' is not used for now, but may be use in the future to define some export options, like channel configurations, compression...
    *                 It must be set to NULL for now.
    *
    *  For layer names, the framebuffer names ( from rprObjectSetName ) will be used if it exists.
    *
    *  As this function is new ( 2.01.6 SDK ) and still experimental, its arguments may change in the future.
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferSaveToFileEx(rpr_framebuffer * framebufferList, rpr_uint framebufferCount, rpr_char const * filePath, void const * extraOptions);


    /** @brief Resolve framebuffer
    *
    * Convert the input Renderer's native raw format 'src_frame_buffer' into an output 'dst_frame_buffer' that can be used for final rendering.
    *
    * src_frame_buffer and dst_frame_buffer should usually have the same dimension/format.
    * src_frame_buffer is the result of a rprContextRender and should be attached to an AOV with rprContextSetAOV before the rprContextRender call.
    * dst_frame_buffer should not be attached to any AOV.
    *
    * The post process that is applied to src_frame_buffer depends on the AOV it's attached to. So it's important to not modify its AOV ( with rprContextSetAOV )
    * between the rprContextRender and rprContextResolveFrameBuffer calls.
    *
    * If noDisplayGamma=FALSE, then RPR_CONTEXT_DISPLAY_GAMMA is applied to the dst_frame_buffer otherwise, display gamma is not used.
    * It's recommended to set it to FALSE for AOVs representing colors ( like RPR_AOV_COLOR ) and use TRUE for other AOVs.
    *
    */
  extern RPR_API_ENTRY rpr_status rprContextResolveFrameBuffer(rpr_context context, rpr_framebuffer src_frame_buffer, rpr_framebuffer dst_frame_buffer, rpr_bool noDisplayGamma);


    /** @brief Create material system
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialSystemGetInfo(rpr_material_system in_material_system, rpr_material_system_info type, size_t in_size, void * in_data, size_t * out_size);


      /** @brief Get material system information
      *
      *   Possible error codes:
      *      RPR_ERROR_INTERNAL_ERROR
      *
      */
  extern RPR_API_ENTRY rpr_status rprContextCreateMaterialSystem(rpr_context in_context, rpr_material_system_type type, rpr_material_system * out_matsys);


    /** @brief Create material node
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialSystemGetSize(rpr_context in_context, rpr_uint * out_size);


    /** @brief Returns the number of material nodes for a given material system
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialSystemCreateNode(rpr_material_system in_matsys, rpr_material_node_type in_type, rpr_material_node * out_node);


    /** @brief set the RPR_MATERIAL_NODE_ID of a material.
    *   this ID doesn't need to be unique.
    *   this ID can be rendered with the RPR_AOV_MATERIAL_ID AOV - color of this AOV can be customized with rprContextSetAOVindexLookup.
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetID(rpr_material_node in_node, rpr_uint id);


    /** @brief Connect nodes
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputNByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_material_node in_input_node);


    /** @brief Set float input value
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputFByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_float in_value_x, rpr_float in_value_y, rpr_float in_value_z, rpr_float in_value_w);


    /** @brief Set generic data input value: Some complex materials inputs may need more than 4-floats or int.
    *  This API can be used to set any generic input data.
    *  Use it only when documentation requests to do it for specific material inputs.
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, void const * data, size_t dataSizeByte);


    /** @brief Set uint input value
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputUByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_uint in_value);


    /** @brief Set image input value
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputImageDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_image image);


    /** @brief Set light input value
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputLightDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_light light);


    /** @brief Set Buffer input value
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputBufferDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_buffer buffer);


    /** @brief Set Grid input value
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputGridDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprMaterialNodeGetInfo(rpr_material_node in_node, rpr_material_node_info in_info, size_t in_size, void * in_data, size_t * out_size);
extern RPR_API_ENTRY rpr_status rprMaterialNodeGetInputInfo(rpr_material_node in_node, rpr_int in_input_idx, rpr_material_node_input_info in_info, size_t in_size, void * in_data, size_t * out_size);
extern RPR_API_ENTRY rpr_status rprContextCreateComposite(rpr_context context, rpr_composite_type in_type, rpr_composite * out_composite);
extern RPR_API_ENTRY rpr_status rprContextCreateLUTFromFile(rpr_context context, const rpr_char * fileLutPath, rpr_lut * out_lut);
extern RPR_API_ENTRY rpr_status rprContextCreateLUTFromData(rpr_context context, const rpr_char * lutData, rpr_lut * out_lut);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputFb(rpr_composite composite, const rpr_char * inputName, rpr_framebuffer input);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputC(rpr_composite composite, const rpr_char * inputName, rpr_composite input);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputLUT(rpr_composite composite, const rpr_char * inputName, rpr_lut input);
extern RPR_API_ENTRY rpr_status rprCompositeSetInput4f(rpr_composite composite, const rpr_char * inputName, float x, float y, float z, float w);
extern RPR_API_ENTRY rpr_status rprCompositeSetInput1u(rpr_composite composite, const rpr_char * inputName, rpr_uint value);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputOp(rpr_composite composite, const rpr_char * inputName, rpr_material_node_arithmetic_operation op);
extern RPR_API_ENTRY rpr_status rprCompositeCompute(rpr_composite composite, rpr_framebuffer fb);
extern RPR_API_ENTRY rpr_status rprCompositeGetInfo(rpr_composite composite, rpr_composite_info composite_info, size_t size, void *  data, size_t * size_ret);


    /** @brief Delete object
    *
    *  rprObjectDelete(obj) deletes 'obj' from memory.
    *  User has to make sure that 'obj' will not be used anymore after this call.
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprObjectDelete(void * obj);


    /** @brief Set material node name
    *
    *
    *  @param  node        Node to set the name for
    *  @param  name       NULL terminated string name
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprObjectSetName(void * node, rpr_char const * name);


    /** @brief Set a custom pointer to an RPR object ( rpr_shape, rpr_image ... )
    *          The custom pointer is not used internally by RPR. The API user only is responsible of it.
    *          An example of usage of this pointer is the C++ wrapper ( RadeonProRender.hpp )
    *
    *  @param  node        Node to set the 'custom pointer' for
    *  @param  customPtr   Any 8 bytes value decided by the API user.
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprObjectSetCustomPointer(void * node, void const * customPtr);


    /** @brief   outputs the 'custom pointer' set by rprObjectSetCustomPointer.
    *            Equivalent of the calls :
    *             rprImageGetInfo(image,RPR_IMAGE_CUSTOM_PTR,...) for rpr_image ,
    *             rprCameraGetInfo(camera,RPR_CAMERA_CUSTOM_PTR,...) for rpr_camera ,
    *             ...etc...
    *
    *  @return      RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprObjectGetCustomPointer(void * node, void const ** customPtr_out);

/* rpr_post_effect */
    /** @brief Create post effect
    *
    *  Create analytic point light represented by a point in space.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreatePostEffect(rpr_context context, rpr_post_effect_type type, rpr_post_effect * out_effect);
extern RPR_API_ENTRY rpr_status rprContextAttachPostEffect(rpr_context context, rpr_post_effect effect);
extern RPR_API_ENTRY rpr_status rprContextDetachPostEffect(rpr_context context, rpr_post_effect effect);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter1u(rpr_post_effect effect, rpr_char const * name, rpr_uint x);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter1f(rpr_post_effect effect, rpr_char const * name, rpr_float x);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter3f(rpr_post_effect effect, rpr_char const * name, rpr_float x, rpr_float y, rpr_float z);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter4f(rpr_post_effect effect, rpr_char const * name, rpr_float x, rpr_float y, rpr_float z, rpr_float w);
extern RPR_API_ENTRY rpr_status rprContextGetAttachedPostEffectCount(rpr_context context, rpr_uint *  nb);
extern RPR_API_ENTRY rpr_status rprContextGetAttachedPostEffect(rpr_context context, rpr_uint i, rpr_post_effect * out_effect);
extern RPR_API_ENTRY rpr_status rprPostEffectGetInfo(rpr_post_effect effect, rpr_post_effect_info info, size_t size,  void *  data, size_t *  size_ret);
extern RPR_API_ENTRY rpr_status rprContextCreateGrid(rpr_context context, rpr_grid * out_grid, size_t gridSizeX, size_t gridSizeY, size_t gridSizeZ, void const * indicesList, size_t numberOfIndices, rpr_grid_indices_topology indicesListTopology, void const * gridData, size_t gridDataSizeByte, rpr_uint gridDataTopology___unused);
extern RPR_API_ENTRY rpr_status rprContextCreateHeteroVolume(rpr_context context, rpr_hetero_volume * out_heteroVolume);
extern RPR_API_ENTRY rpr_status rprShapeSetHeteroVolume(rpr_shape shape, rpr_hetero_volume heteroVolume);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetTransform(rpr_hetero_volume heteroVolume, rpr_bool transpose, rpr_float const * transform);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetEmissionGrid(rpr_hetero_volume heteroVolume, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetDensityGrid(rpr_hetero_volume heteroVolume, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetAlbedoGrid(rpr_hetero_volume heteroVolume, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetEmissionLookup(rpr_hetero_volume heteroVolume, rpr_float const * ptr, rpr_uint n);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetDensityLookup(rpr_hetero_volume heteroVolume, rpr_float const * ptr, rpr_uint n);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetAlbedoLookup(rpr_hetero_volume heteroVolume, rpr_float const * ptr, rpr_uint n);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetAlbedoScale(rpr_hetero_volume heteroVolume, rpr_float scale);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetEmissionScale(rpr_hetero_volume heteroVolume, rpr_float scale);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetDensityScale(rpr_hetero_volume heteroVolume, rpr_float scale);




  #ifdef __cplusplus
}
#endif

#endif  /*__RADEONPRORENDER_V2_H  */
