/*****************************************************************************\
*
*  Module Name    RadeonProRender.h
*  Project        AMD Radeon ProRender
*
*  Description    Radeon ProRender Interface header
*
*  Copyright(C) 2017-2021 Advanced Micro Devices, Inc. All rights reserved.
*
\*****************************************************************************/

// RadeonProRender_v2 is an improved Radeon ProRender header : stricter and more secured.
// defining RPR_API_USE_HEADER_V2 in your project will automatically switch it to this new header.
#if defined(RPR_API_USE_HEADER_V2)
#include "RadeonProRender_v2.h"
#else

#ifndef __RADEONPRORENDER_H
#define __RADEONPRORENDER_H

#if defined(__APPLE__)
#include "stddef.h"
#else
#include "cstddef"
#endif

#define RPR_API_ENTRY

#ifdef __cplusplus
extern "C" {
#endif


#define RPR_VERSION_MAJOR 2 
#define RPR_VERSION_MINOR 2 
#define RPR_VERSION_REVISION 16 
#define RPR_VERSION_BUILD 0xb050a508 
#define RPR_VERSION_MAJOR_MINOR_REVISION 0x00200216 

// Deprecated version naming - will be removed in the future :
#define RPR_API_VERSION RPR_VERSION_MAJOR_MINOR_REVISION 
#define RPR_API_VERSION_MINOR RPR_VERSION_BUILD 

/*rpr_status*/
#define RPR_SUCCESS 0 
#define RPR_ERROR_COMPUTE_API_NOT_SUPPORTED -1 
#define RPR_ERROR_OUT_OF_SYSTEM_MEMORY -2 
#define RPR_ERROR_OUT_OF_VIDEO_MEMORY -3 
#define RPR_ERROR_INVALID_LIGHTPATH_EXPR -5 
#define RPR_ERROR_INVALID_IMAGE -6 
#define RPR_ERROR_INVALID_AA_METHOD -7 
#define RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT -8 
#define RPR_ERROR_INVALID_GL_TEXTURE -9 
#define RPR_ERROR_INVALID_CL_IMAGE -10 
#define RPR_ERROR_INVALID_OBJECT -11 
#define RPR_ERROR_INVALID_PARAMETER -12 
#define RPR_ERROR_INVALID_TAG -13 
#define RPR_ERROR_INVALID_LIGHT -14 
#define RPR_ERROR_INVALID_CONTEXT -15 
#define RPR_ERROR_UNIMPLEMENTED -16 
#define RPR_ERROR_INVALID_API_VERSION -17 
#define RPR_ERROR_INTERNAL_ERROR -18 
#define RPR_ERROR_IO_ERROR -19 
#define RPR_ERROR_UNSUPPORTED_SHADER_PARAMETER_TYPE -20 
#define RPR_ERROR_MATERIAL_STACK_OVERFLOW -21 
#define RPR_ERROR_INVALID_PARAMETER_TYPE -22 
#define RPR_ERROR_UNSUPPORTED -23 
#define RPR_ERROR_OPENCL_OUT_OF_HOST_MEMORY -24 
#define RPR_ERROR_OPENGL -25 
#define RPR_ERROR_OPENCL -26 
#define RPR_ERROR_NULLPTR -27 
#define RPR_ERROR_NODETYPE -28 
#define RPR_ERROR_ABORTED -29 
/*rpr_parameter_type*/
#define RPR_PARAMETER_TYPE_UNDEF 0x0 
#define RPR_PARAMETER_TYPE_FLOAT 0x1 
#define RPR_PARAMETER_TYPE_FLOAT2 0x2 
#define RPR_PARAMETER_TYPE_FLOAT3 0x3 
#define RPR_PARAMETER_TYPE_FLOAT4 0x4 
#define RPR_PARAMETER_TYPE_IMAGE 0x5 
#define RPR_PARAMETER_TYPE_STRING 0x6 
#define RPR_PARAMETER_TYPE_SHADER 0x7 
#define RPR_PARAMETER_TYPE_UINT 0x8 
#define RPR_PARAMETER_TYPE_ULONG 0x9 
#define RPR_PARAMETER_TYPE_LONGLONG 0xa 
/*rpr_creation_flags*/
#define RPR_CREATION_FLAGS_ENABLE_GPU0 (1 << 0) 
#define RPR_CREATION_FLAGS_ENABLE_GPU1 (1 << 1) 
#define RPR_CREATION_FLAGS_ENABLE_GPU2 (1 << 2) 
#define RPR_CREATION_FLAGS_ENABLE_GPU3 (1 << 3) 
#define RPR_CREATION_FLAGS_ENABLE_CPU (1 << 4) 
#define RPR_CREATION_FLAGS_ENABLE_GL_INTEROP (1 << 5) 
#define RPR_CREATION_FLAGS_ENABLE_GPU4 (1 << 6) 
#define RPR_CREATION_FLAGS_ENABLE_GPU5 (1 << 7) 
#define RPR_CREATION_FLAGS_ENABLE_GPU6 (1 << 8) 
#define RPR_CREATION_FLAGS_ENABLE_GPU7 (1 << 9) 
#define RPR_CREATION_FLAGS_ENABLE_METAL (1 << 10) 
#define RPR_CREATION_FLAGS_ENABLE_GPU8 (1 << 11) 
#define RPR_CREATION_FLAGS_ENABLE_GPU9 (1 << 12) 
#define RPR_CREATION_FLAGS_ENABLE_GPU10 (1 << 13) 
#define RPR_CREATION_FLAGS_ENABLE_GPU11 (1 << 14) 
#define RPR_CREATION_FLAGS_ENABLE_GPU12 (1 << 15) 
#define RPR_CREATION_FLAGS_ENABLE_GPU13 (1 << 16) 
#define RPR_CREATION_FLAGS_ENABLE_GPU14 (1 << 17) 
#define RPR_CREATION_FLAGS_ENABLE_GPU15 (1 << 18) 
#define RPR_CREATION_FLAGS_ENABLE_HIP (1 << 19) 
#define RPR_CREATION_FLAGS_ENABLE_DEBUG (1 << 31) 
/*rpr_aa_filter*/
#define RPR_FILTER_NONE 0x0 
#define RPR_FILTER_BOX 0x1 
#define RPR_FILTER_TRIANGLE 0x2 
#define RPR_FILTER_GAUSSIAN 0x3 
#define RPR_FILTER_MITCHELL 0x4 
#define RPR_FILTER_LANCZOS 0x5 
#define RPR_FILTER_BLACKMANHARRIS 0x6 
/*rpr_context_sampler_type*/
#define RPR_CONTEXT_SAMPLER_TYPE_SOBOL 0x1 
#define RPR_CONTEXT_SAMPLER_TYPE_RANDOM 0x2 
#define RPR_CONTEXT_SAMPLER_TYPE_CMJ 0x3 
/*rpr_primvar_interpolation_type*/
#define RPR_PRIMVAR_INTERPOLATION_CONSTANT 0x1 
#define RPR_PRIMVAR_INTERPOLATION_UNIFORM 0x2 
#define RPR_PRIMVAR_INTERPOLATION_VERTEX 0x3 
#define RPR_PRIMVAR_INTERPOLATION_FACEVARYING_NORMAL 0x4 
#define RPR_PRIMVAR_INTERPOLATION_FACEVARYING_UV 0x5 
/*rpr_shape_type*/
#define RPR_SHAPE_TYPE_MESH 0x1 
#define RPR_SHAPE_TYPE_INSTANCE 0x2 
/*rpr_light_type*/
#define RPR_LIGHT_TYPE_POINT 0x1 
#define RPR_LIGHT_TYPE_DIRECTIONAL 0x2 
#define RPR_LIGHT_TYPE_SPOT 0x3 
#define RPR_LIGHT_TYPE_ENVIRONMENT 0x4 
#define RPR_LIGHT_TYPE_SKY 0x5 
#define RPR_LIGHT_TYPE_IES 0x6 
#define RPR_LIGHT_TYPE_SPHERE 0x7 
#define RPR_LIGHT_TYPE_DISK 0x8 

#define RPR_OBJECT_NAME 0x777777 
#define RPR_OBJECT_UNIQUE_ID 0x777778 
#define RPR_OBJECT_CUSTOM_PTR 0x777779 

/*rpr_context_info*/
#define RPR_CONTEXT_CREATION_FLAGS 0x102 
#define RPR_CONTEXT_CACHE_PATH 0x103 
#define RPR_CONTEXT_RENDER_STATUS 0x104 
#define RPR_CONTEXT_RENDER_STATISTICS 0x105 
#define RPR_CONTEXT_DEVICE_COUNT 0x106 
#define RPR_CONTEXT_PARAMETER_COUNT 0x107 
#define RPR_CONTEXT_ACTIVE_PLUGIN 0x108 
#define RPR_CONTEXT_SCENE 0x109 
#define RPR_CONTEXT_ITERATIONS 0x10B 
#define RPR_CONTEXT_IMAGE_FILTER_TYPE 0x10C 
#define RPR_CONTEXT_TONE_MAPPING_TYPE 0x113 
#define RPR_CONTEXT_TONE_MAPPING_LINEAR_SCALE 0x114 
#define RPR_CONTEXT_TONE_MAPPING_PHOTO_LINEAR_SENSITIVITY 0x115 
#define RPR_CONTEXT_TONE_MAPPING_PHOTO_LINEAR_EXPOSURE 0x116 
#define RPR_CONTEXT_TONE_MAPPING_PHOTO_LINEAR_FSTOP 0x117 
#define RPR_CONTEXT_TONE_MAPPING_REINHARD02_PRE_SCALE 0x118 
#define RPR_CONTEXT_TONE_MAPPING_REINHARD02_POST_SCALE 0x119 
#define RPR_CONTEXT_TONE_MAPPING_REINHARD02_BURN 0x11A 
#define RPR_CONTEXT_MAX_RECURSION 0x11B 
#define RPR_CONTEXT_RAY_CAST_EPSILON 0x11C 
#define RPR_CONTEXT_RADIANCE_CLAMP 0x11D 
#define RPR_CONTEXT_X_FLIP 0x11E 
#define RPR_CONTEXT_Y_FLIP 0x11F 
#define RPR_CONTEXT_TEXTURE_GAMMA 0x120 
#define RPR_CONTEXT_PDF_THRESHOLD 0x121 
#define RPR_CONTEXT_RENDER_MODE 0x122 
#define RPR_CONTEXT_ROUGHNESS_CAP 0x123 
#define RPR_CONTEXT_DISPLAY_GAMMA 0x124 
#define RPR_CONTEXT_MATERIAL_STACK_SIZE 0x125 
#define RPR_CONTEXT_CUTTING_PLANES 0x126 
#define RPR_CONTEXT_GPU0_NAME 0x127 
#define RPR_CONTEXT_GPU1_NAME 0x128 
#define RPR_CONTEXT_GPU2_NAME 0x129 
#define RPR_CONTEXT_GPU3_NAME 0x12A 
#define RPR_CONTEXT_CPU_NAME 0x12B 
#define RPR_CONTEXT_GPU4_NAME 0x12C 
#define RPR_CONTEXT_GPU5_NAME 0x12D 
#define RPR_CONTEXT_GPU6_NAME 0x12E 
#define RPR_CONTEXT_GPU7_NAME 0x12F 
#define RPR_CONTEXT_TONE_MAPPING_EXPONENTIAL_INTENSITY 0x130 
#define RPR_CONTEXT_FRAMECOUNT 0x131 
#define RPR_CONTEXT_TEXTURE_COMPRESSION 0x132 
#define RPR_CONTEXT_AO_RAY_LENGTH 0x133 
#define RPR_CONTEXT_OOC_TEXTURE_CACHE 0x134 
#define RPR_CONTEXT_PREVIEW 0x135 
#define RPR_CONTEXT_CPU_THREAD_LIMIT 0x136 
#define RPR_CONTEXT_LAST_ERROR_MESSAGE 0x137 
#define RPR_CONTEXT_MAX_DEPTH_DIFFUSE 0x138 
#define RPR_CONTEXT_MAX_DEPTH_GLOSSY 0x139 
#define RPR_CONTEXT_OOC_CACHE_PATH 0x13a 
#define RPR_CONTEXT_MAX_DEPTH_REFRACTION 0x13B 
#define RPR_CONTEXT_MAX_DEPTH_GLOSSY_REFRACTION 0x13C 
#define RPR_CONTEXT_RENDER_LAYER_MASK 0x13D 
#define RPR_CONTEXT_SINGLE_LEVEL_BVH_ENABLED 0x13E 
#define RPR_CONTEXT_TRANSPARENT_BACKGROUND 0x13F 
#define RPR_CONTEXT_MAX_DEPTH_SHADOW 0x140 
#define RPR_CONTEXT_API_VERSION 0x141 
#define RPR_CONTEXT_GPU8_NAME 0x142 
#define RPR_CONTEXT_GPU9_NAME 0x143 
#define RPR_CONTEXT_GPU10_NAME 0x144 
#define RPR_CONTEXT_GPU11_NAME 0x145 
#define RPR_CONTEXT_GPU12_NAME 0x146 
#define RPR_CONTEXT_GPU13_NAME 0x147 
#define RPR_CONTEXT_GPU14_NAME 0x148 
#define RPR_CONTEXT_GPU15_NAME 0x149 
#define RPR_CONTEXT_API_VERSION_MINOR 0x14A 
#define RPR_CONTEXT_METAL_PERFORMANCE_SHADER 0x14B 
#define RPR_CONTEXT_USER_TEXTURE_0 0x14C 
#define RPR_CONTEXT_USER_TEXTURE_1 0x14D 
#define RPR_CONTEXT_USER_TEXTURE_2 0x14E 
#define RPR_CONTEXT_USER_TEXTURE_3 0x14F 
#define RPR_CONTEXT_MIPMAP_LOD_OFFSET 0x150 
#define RPR_CONTEXT_AO_RAY_COUNT 0x151 
#define RPR_CONTEXT_SAMPLER_TYPE 0x152 
#define RPR_CONTEXT_ADAPTIVE_SAMPLING_TILE_SIZE 0x153 
#define RPR_CONTEXT_ADAPTIVE_SAMPLING_MIN_SPP 0x154 
#define RPR_CONTEXT_ADAPTIVE_SAMPLING_THRESHOLD 0x155 
#define RPR_CONTEXT_TILE_SIZE 0x156 
#define RPR_CONTEXT_LIST_CREATED_CAMERAS 0x157 
#define RPR_CONTEXT_LIST_CREATED_MATERIALNODES 0x158 
#define RPR_CONTEXT_LIST_CREATED_LIGHTS 0x159 
#define RPR_CONTEXT_LIST_CREATED_SHAPES 0x15A 
#define RPR_CONTEXT_LIST_CREATED_POSTEFFECTS 0x15B 
#define RPR_CONTEXT_LIST_CREATED_HETEROVOLUMES 0x15C 
#define RPR_CONTEXT_LIST_CREATED_GRIDS 0x15D 
#define RPR_CONTEXT_LIST_CREATED_BUFFERS 0x15E 
#define RPR_CONTEXT_LIST_CREATED_IMAGES 0x15F 
#define RPR_CONTEXT_LIST_CREATED_FRAMEBUFFERS 0x160 
#define RPR_CONTEXT_LIST_CREATED_SCENES 0x161 
#define RPR_CONTEXT_LIST_CREATED_CURVES 0x162 
#define RPR_CONTEXT_LIST_CREATED_MATERIALSYSTEM 0x163 
#define RPR_CONTEXT_LIST_CREATED_COMPOSITE 0x164 
#define RPR_CONTEXT_LIST_CREATED_LUT 0x165 
#define RPR_CONTEXT_AA_ENABLED 0x166 
#define RPR_CONTEXT_ACTIVE_PIXEL_COUNT 0x167 
#define RPR_CONTEXT_TRACING_ENABLED 0x168 
#define RPR_CONTEXT_TRACING_PATH 0x169 
#define RPR_CONTEXT_TILE_RECT 0x16A 
#define RPR_CONTEXT_PLUGIN_VERSION 0x16B 
#define RPR_CONTEXT_RUSSIAN_ROULETTE_DEPTH 0x16C 
#define RPR_CONTEXT_SHADOW_CATCHER_BAKING 0x16D 
#define RPR_CONTEXT_RENDER_UPDATE_CALLBACK_FUNC 0x16E 
#define RPR_CONTEXT_RENDER_UPDATE_CALLBACK_DATA 0x16F 
#define RPR_CONTEXT_COMPILE_CALLBACK_FUNC 0x601 
#define RPR_CONTEXT_COMPILE_CALLBACK_DATA 0x602 
#define RPR_CONTEXT_TEXTURE_CACHE_PATH 0x170 
#define RPR_CONTEXT_OCIO_CONFIG_PATH 0x171 
#define RPR_CONTEXT_OCIO_RENDERING_COLOR_SPACE 0x172 
#define RPR_CONTEXT_CONTOUR_USE_OBJECTID 0x173 
#define RPR_CONTEXT_CONTOUR_USE_MATERIALID 0x174 
#define RPR_CONTEXT_CONTOUR_USE_NORMAL 0x175 
#define RPR_CONTEXT_CONTOUR_USE_UV 0x186 
#define RPR_CONTEXT_CONTOUR_NORMAL_THRESHOLD 0x176 
#define RPR_CONTEXT_CONTOUR_UV_THRESHOLD 0x187 
#define RPR_CONTEXT_CONTOUR_UV_SECONDARY 0x194 
#define RPR_CONTEXT_CONTOUR_LINEWIDTH_OBJECTID 0x177 
#define RPR_CONTEXT_CONTOUR_LINEWIDTH_MATERIALID 0x178 
#define RPR_CONTEXT_CONTOUR_LINEWIDTH_NORMAL 0x179 
#define RPR_CONTEXT_CONTOUR_LINEWIDTH_UV 0x188 
#define RPR_CONTEXT_CONTOUR_ANTIALIASING 0x17A 
#define RPR_CONTEXT_CONTOUR_DEBUG_ENABLED 0x17F 
#define RPR_CONTEXT_GPUINTEGRATOR 0x17B 
#define RPR_CONTEXT_CPUINTEGRATOR 0x17C 
#define RPR_CONTEXT_BEAUTY_MOTION_BLUR 0x17D 
#define RPR_CONTEXT_CAUSTICS_REDUCTION 0x17E 
#define RPR_CONTEXT_GPU_MEMORY_LIMIT 0x180 
#define RPR_CONTEXT_RENDER_LAYER_LIST 0x181 
#define RPR_CONTEXT_WINDING_ORDER_CORRECTION 0x182 
#define RPR_CONTEXT_DEEP_SUBPIXEL_MERGE_Z_THRESHOLD 0x183 
#define RPR_CONTEXT_DEEP_GPU_ALLOCATION_LEVEL 0x184 
#define RPR_CONTEXT_DEEP_COLOR_ENABLED 0x185 
#define RPR_CONTEXT_FOG_COLOR 0x189 
#define RPR_CONTEXT_FOG_DISTANCE 0x18A 
#define RPR_CONTEXT_FOG_HEIGHT 0x18B 
#define RPR_CONTEXT_ATMOSPHERE_VOLUME_COLOR 0x18C 
#define RPR_CONTEXT_ATMOSPHERE_VOLUME_DENSITY 0x18D 
#define RPR_CONTEXT_ATMOSPHERE_VOLUME_RADIANCE_CLAMP 0x18F 
#define RPR_CONTEXT_FOG_HEIGHT_OFFSET 0x18E 
#define RPR_CONTEXT_INDIRECT_DOWNSAMPLE 0x190 
#define RPR_CONTEXT_CRYPTOMATTE_EXTENDED 0x191 
#define RPR_CONTEXT_CRYPTOMATTE_SPLIT_INDIRECT 0x192 
#define RPR_CONTEXT_FOG_DIRECTION 0x193 
#define RPR_CONTEXT_RANDOM_SEED 0x1000 
#define RPR_CONTEXT_IBL_DISPLAY 0x195 
#define RPR_CONTEXT_FRAMEBUFFER_SAVE_FLOAT32 0x196 
#define RPR_CONTEXT_UPDATE_TIME_CALLBACK_FUNC 0x197 
#define RPR_CONTEXT_UPDATE_TIME_CALLBACK_DATA 0x198 
#define RPR_CONTEXT_RENDER_TIME_CALLBACK_FUNC 0x199 
#define RPR_CONTEXT_RENDER_TIME_CALLBACK_DATA 0x19A 
#define RPR_CONTEXT_FIRST_ITERATION_TIME_CALLBACK_FUNC 0x19B 
#define RPR_CONTEXT_FIRST_ITERATION_TIME_CALLBACK_DATA 0x19C 
#define RPR_CONTEXT_IMAGE_FILTER_RADIUS 0x19D 
#define RPR_CONTEXT_NAME RPR_OBJECT_NAME
#define RPR_CONTEXT_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_CONTEXT_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR

/* last of the RPR_CONTEXT_* */
  /*rpr_camera_info*/
#define RPR_CAMERA_TRANSFORM 0x201 
#define RPR_CAMERA_FSTOP 0x202 
#define RPR_CAMERA_APERTURE_BLADES 0x203 
#define RPR_CAMERA_RESPONSE 0x204 
#define RPR_CAMERA_EXPOSURE 0x205 
#define RPR_CAMERA_FOCAL_LENGTH 0x206 
#define RPR_CAMERA_SENSOR_SIZE 0x207 
#define RPR_CAMERA_MODE 0x208 
#define RPR_CAMERA_ORTHO_WIDTH 0x209 
#define RPR_CAMERA_ORTHO_HEIGHT 0x20A 
#define RPR_CAMERA_FOCUS_DISTANCE 0x20B 
#define RPR_CAMERA_POSITION 0x20C 
#define RPR_CAMERA_LOOKAT 0x20D 
#define RPR_CAMERA_UP 0x20E 
#define RPR_CAMERA_FOCAL_TILT 0x20F 
#define RPR_CAMERA_LENS_SHIFT 0x210 
#define RPR_CAMERA_IPD 0x211 
#define RPR_CAMERA_TILT_CORRECTION 0x212 
#define RPR_CAMERA_NEAR_PLANE 0x213 
#define RPR_CAMERA_FAR_PLANE 0x214 
#define RPR_CAMERA_LINEAR_MOTION 0x215 
#define RPR_CAMERA_ANGULAR_MOTION 0x216 
#define RPR_CAMERA_MOTION_TRANSFORMS_COUNT 0x217 
#define RPR_CAMERA_MOTION_TRANSFORMS 0x218 
#define RPR_CAMERA_POST_SCALE 0x219 
#define RPR_CAMERA_NAME RPR_OBJECT_NAME
#define RPR_CAMERA_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_CAMERA_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_image_info*/
#define RPR_IMAGE_FORMAT 0x301 
#define RPR_IMAGE_DESC 0x302 
#define RPR_IMAGE_DATA 0x303 
#define RPR_IMAGE_DATA_SIZEBYTE 0x304 
#define RPR_IMAGE_WRAP 0x305 
#define RPR_IMAGE_FILTER 0x306 
#define RPR_IMAGE_GAMMA 0x307 
#define RPR_IMAGE_MIPMAP_ENABLED 0x308 
#define RPR_IMAGE_MIP_COUNT 0x309 
#define RPR_IMAGE_GAMMA_FROM_FILE 0x30A 
#define RPR_IMAGE_UDIM 0x30B 
#define RPR_IMAGE_OCIO_COLORSPACE 0x30C 
#define RPR_IMAGE_INTERNAL_COMPRESSION 0x30D 
#define RPR_IMAGE_NAME RPR_OBJECT_NAME
#define RPR_IMAGE_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_IMAGE_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_buffer_info*/
#define RPR_BUFFER_DESC 0x350 
#define RPR_BUFFER_DATA 0x351 
#define RPR_BUFFER_NAME RPR_OBJECT_NAME
#define RPR_BUFFER_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_BUFFER_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_shape_info*/
#define RPR_SHAPE_TYPE 0x401 
#define RPR_SHAPE_VIDMEM_USAGE 0x402 
#define RPR_SHAPE_TRANSFORM 0x403 
#define RPR_SHAPE_MATERIAL 0x404 
#define RPR_SHAPE_LINEAR_MOTION 0x405 
#define RPR_SHAPE_ANGULAR_MOTION 0x406 
#define RPR_SHAPE_SHADOW_FLAG 0x408
#define RPR_SHAPE_SUBDIVISION_FACTOR 0x409 
#define RPR_SHAPE_DISPLACEMENT_SCALE 0x40A 
#define RPR_SHAPE_SHADOW_CATCHER_FLAG 0x40E 
#define RPR_SHAPE_VOLUME_MATERIAL 0x40F 
#define RPR_SHAPE_OBJECT_GROUP_ID 0x410 
#define RPR_SHAPE_SUBDIVISION_CREASEWEIGHT 0x411 
#define RPR_SHAPE_SUBDIVISION_BOUNDARYINTEROP 0x412 
#define RPR_SHAPE_DISPLACEMENT_MATERIAL 0x413 
#define RPR_SHAPE_MATERIALS_PER_FACE 0x415 
#define RPR_SHAPE_SCALE_MOTION 0x416 
#define RPR_SHAPE_HETERO_VOLUME 0x417 
#define RPR_SHAPE_LAYER_MASK 0x418 
#define RPR_SHAPE_VISIBILITY_PRIMARY_ONLY_FLAG 0x40C 
#define RPR_SHAPE_VISIBILITY_SHADOW 0x41A 
#define RPR_SHAPE_VISIBILITY_REFLECTION 0x41B 
#define RPR_SHAPE_VISIBILITY_REFRACTION 0x41C 
#define RPR_SHAPE_VISIBILITY_TRANSPARENT 0x41D 
#define RPR_SHAPE_VISIBILITY_DIFFUSE 0x41E 
#define RPR_SHAPE_VISIBILITY_GLOSSY_REFLECTION 0x41F 
#define RPR_SHAPE_VISIBILITY_GLOSSY_REFRACTION 0x420 
#define RPR_SHAPE_VISIBILITY_LIGHT 0x421 
#define RPR_SHAPE_LIGHT_GROUP_ID 0x422 
#define RPR_SHAPE_STATIC 0x423
#define RPR_SHAPE_PER_VERTEX_VALUE0 0x424
#define RPR_SHAPE_PER_VERTEX_VALUE1 0x425
#define RPR_SHAPE_PER_VERTEX_VALUE2 0x426
#define RPR_SHAPE_PER_VERTEX_VALUE3 0x427
#define RPR_SHAPE_REFLECTION_CATCHER_FLAG 0x428 
#define RPR_SHAPE_OBJECT_ID 0x429 
#define RPR_SHAPE_SUBDIVISION_AUTO_RATIO_CAP 0x42A 
#define RPR_SHAPE_MOTION_TRANSFORMS_COUNT 0x42B 
#define RPR_SHAPE_MOTION_TRANSFORMS 0x42C 
#define RPR_SHAPE_CONTOUR_IGNORE 0x42D 
#define RPR_SHAPE_RENDER_LAYER_LIST 0x42E 
#define RPR_SHAPE_SHADOW_COLOR 0x42F 
#define RPR_SHAPE_VISIBILITY_RECEIVE_SHADOW 0x430 
#define RPR_SHAPE_PRIMVARS 0x431
#define RPR_SHAPE_ENVIRONMENT_LIGHT 0x432
#define RPR_SHAPE_NAME RPR_OBJECT_NAME
#define RPR_SHAPE_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_SHAPE_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_mesh_info*/
#define RPR_MESH_POLYGON_COUNT 0x501 
#define RPR_MESH_VERTEX_COUNT 0x502 
#define RPR_MESH_NORMAL_COUNT 0x503 
#define RPR_MESH_UV_COUNT 0x504 
#define RPR_MESH_VERTEX_ARRAY 0x505 
#define RPR_MESH_NORMAL_ARRAY 0x506 
#define RPR_MESH_UV_ARRAY 0x507 
#define RPR_MESH_VERTEX_INDEX_ARRAY 0x508 
#define RPR_MESH_NORMAL_INDEX_ARRAY 0x509 
#define RPR_MESH_UV_INDEX_ARRAY 0x50A 
#define RPR_MESH_VERTEX_STRIDE 0x50C 
#define RPR_MESH_NORMAL_STRIDE 0x50D 
#define RPR_MESH_UV_STRIDE 0x50E 
#define RPR_MESH_VERTEX_INDEX_STRIDE 0x50F 
#define RPR_MESH_NORMAL_INDEX_STRIDE 0x510 
#define RPR_MESH_UV_INDEX_STRIDE 0x511 
#define RPR_MESH_NUM_FACE_VERTICES_ARRAY 0x512 
#define RPR_MESH_UV2_COUNT 0x513 
#define RPR_MESH_UV2_ARRAY 0x514 
#define RPR_MESH_UV2_INDEX_ARRAY 0x515 
#define RPR_MESH_UV2_STRIDE 0x516 
#define RPR_MESH_UV2_INDEX_STRIDE 0x517 
#define RPR_MESH_UV_DIM 0x518 
#define RPR_MESH_MOTION_DIMENSION 0x519 
#define RPR_MESH_VOLUME_FLAG 0x51A 
/*rpr_scene_info*/
#define RPR_SCENE_SHAPE_COUNT 0x701 
#define RPR_SCENE_LIGHT_COUNT 0x702 
#define RPR_SCENE_SHAPE_LIST 0x704 
#define RPR_SCENE_LIGHT_LIST 0x705 
#define RPR_SCENE_CAMERA 0x706 
#define RPR_SCENE_CAMERA_RIGHT 0x707 
#define RPR_SCENE_BACKGROUND_IMAGE 0x708 
#define RPR_SCENE_AABB 0x70D 
#define RPR_SCENE_HETEROVOLUME_LIST 0x70E 
#define RPR_SCENE_HETEROVOLUME_COUNT 0x70F 
#define RPR_SCENE_CURVE_LIST 0x710 
#define RPR_SCENE_CURVE_COUNT 0x711 
#define RPR_SCENE_ENVIRONMENT_LIGHT 0x712 
#define RPR_SCENE_NAME RPR_OBJECT_NAME
#define RPR_SCENE_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_SCENE_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_lut_info*/
#define RPR_LUT_FILENAME 0x850 
#define RPR_LUT_DATA 0x851 
/*rpr_light_info*/
#define RPR_LIGHT_TYPE 0x801 
#define RPR_LIGHT_TRANSFORM 0x803 
#define RPR_LIGHT_GROUP_ID 0x805 
#define RPR_LIGHT_RENDER_LAYER_LIST 0x806 
#define RPR_LIGHT_VISIBILITY_LIGHT 0x807 
#define RPR_LIGHT_NAME RPR_OBJECT_NAME
#define RPR_LIGHT_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_LIGHT_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR

    
#define RPR_POINT_LIGHT_RADIANT_POWER 0x804 

    
#define RPR_DIRECTIONAL_LIGHT_RADIANT_POWER 0x808 
#define RPR_DIRECTIONAL_LIGHT_SHADOW_SOFTNESS_ANGLE 0x80A 

    
#define RPR_SPOT_LIGHT_RADIANT_POWER 0x80B 
#define RPR_SPOT_LIGHT_CONE_SHAPE 0x80C 
#define RPR_SPOT_LIGHT_IMAGE 0x80D 

    
#define RPR_ENVIRONMENT_LIGHT_IMAGE 0x80F 
#define RPR_ENVIRONMENT_LIGHT_INTENSITY_SCALE 0x810 
#define RPR_ENVIRONMENT_LIGHT_PORTAL_LIST 0x818 
#define RPR_ENVIRONMENT_LIGHT_PORTAL_COUNT 0x819 
#define RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFLECTION 0x81A 
#define RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFRACTION 0x81B 
#define RPR_ENVIRONMENT_LIGHT_OVERRIDE_TRANSPARENCY 0x81C 
#define RPR_ENVIRONMENT_LIGHT_OVERRIDE_BACKGROUND 0x81D 
#define RPR_ENVIRONMENT_LIGHT_OVERRIDE_IRRADIANCE 0x81E 

    
#define RPR_SKY_LIGHT_TURBIDITY 0x812 
#define RPR_SKY_LIGHT_ALBEDO 0x813 
#define RPR_SKY_LIGHT_SCALE 0x814 
#define RPR_SKY_LIGHT_DIRECTION 0x815 
#define RPR_SKY_LIGHT_PORTAL_LIST 0x820 
#define RPR_SKY_LIGHT_PORTAL_COUNT 0x821 

    
#define RPR_IES_LIGHT_RADIANT_POWER 0x816 
#define RPR_IES_LIGHT_IMAGE_DESC 0x817 

    
#define RPR_SPHERE_LIGHT_RADIANT_POWER 0x822 
#define RPR_SPHERE_LIGHT_RADIUS 0x824 

    
#define RPR_DISK_LIGHT_RADIANT_POWER 0x823 
#define RPR_DISK_LIGHT_RADIUS 0x825 
#define RPR_DISK_LIGHT_ANGLE 0x826 
#define RPR_DISK_LIGHT_INNER_ANGLE 0x827 
/*rpr_parameter_info*/
#define RPR_PARAMETER_NAME 0x1201 
#define RPR_PARAMETER_TYPE 0x1203 
#define RPR_PARAMETER_DESCRIPTION 0x1204 
#define RPR_PARAMETER_VALUE 0x1205 

// RPR_PARAMETER_NAME_STRING 0x1202   not used anymore  you can only set/get parameters using  RPR_CONTEXT_*

/*rpr_framebuffer_info*/
#define RPR_FRAMEBUFFER_FORMAT 0x1301 
#define RPR_FRAMEBUFFER_DESC 0x1302 
#define RPR_FRAMEBUFFER_DATA 0x1303 
#define RPR_FRAMEBUFFER_GL_TARGET 0x1304 
#define RPR_FRAMEBUFFER_GL_MIPLEVEL 0x1305 
#define RPR_FRAMEBUFFER_GL_TEXTURE 0x1306 
#define RPR_FRAMEBUFFER_LPE 0x1307 
#define RPR_FRAMEBUFFER_NAME RPR_OBJECT_NAME
#define RPR_FRAMEBUFFER_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_FRAMEBUFFER_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR

/* rpr_instance_info */
#define RPR_INSTANCE_PARENT_SHAPE 0x1601 

/*rpr_component_type*/
#define RPR_COMPONENT_TYPE_UINT8 0x1 
#define RPR_COMPONENT_TYPE_FLOAT16 0x2
#define RPR_COMPONENT_TYPE_FLOAT32 0x3
#define RPR_COMPONENT_TYPE_UNKNOWN 0x4
#define RPR_COMPONENT_TYPE_DEEP 0x5
#define RPR_COMPONENT_TYPE_UINT32 0x6
/*rpr_buffer_element_type*/
#define RPR_BUFFER_ELEMENT_TYPE_INT32 0x1 
#define RPR_BUFFER_ELEMENT_TYPE_FLOAT32 0x2 
/*rpr_render_mode*/
#define RPR_RENDER_MODE_GLOBAL_ILLUMINATION 0x1 
#define RPR_RENDER_MODE_DIRECT_ILLUMINATION 0x2 
#define RPR_RENDER_MODE_DIRECT_ILLUMINATION_NO_SHADOW 0x3 
#define RPR_RENDER_MODE_WIREFRAME 0x4 
#define RPR_RENDER_MODE_MATERIAL_INDEX 0x5 
#define RPR_RENDER_MODE_POSITION 0x6 
#define RPR_RENDER_MODE_NORMAL 0x7 
#define RPR_RENDER_MODE_TEXCOORD 0x8 
#define RPR_RENDER_MODE_AMBIENT_OCCLUSION 0x9 
#define RPR_RENDER_MODE_DIFFUSE 0x0a 
/*rpr_camera_mode*/
#define RPR_CAMERA_MODE_PERSPECTIVE 0x1 
#define RPR_CAMERA_MODE_ORTHOGRAPHIC 0x2 
#define RPR_CAMERA_MODE_LATITUDE_LONGITUDE_360 0x3 
#define RPR_CAMERA_MODE_LATITUDE_LONGITUDE_STEREO 0x4 
#define RPR_CAMERA_MODE_CUBEMAP 0x5 
#define RPR_CAMERA_MODE_CUBEMAP_STEREO 0x6 
#define RPR_CAMERA_MODE_FISHEYE 0x7 
/*rpr_tonemapping_operator*/
#define RPR_TONEMAPPING_OPERATOR_NONE 0x0 
#define RPR_TONEMAPPING_OPERATOR_LINEAR 0x1 
#define RPR_TONEMAPPING_OPERATOR_PHOTOLINEAR 0x2 
#define RPR_TONEMAPPING_OPERATOR_AUTOLINEAR 0x3 
#define RPR_TONEMAPPING_OPERATOR_MAXWHITE 0x4 
#define RPR_TONEMAPPING_OPERATOR_REINHARD02 0x5 
#define RPR_TONEMAPPING_OPERATOR_EXPONENTIAL 0x6 
/*rpr_volume_type*/
#define RPR_VOLUME_TYPE_NONE 0xFFFF 
#define RPR_VOLUME_TYPE_HOMOGENEOUS 0x0 
#define RPR_VOLUME_TYPE_HETEROGENEOUS 0x1 
/*rpr_material_system_info*/
#define RPR_MATERIAL_SYSTEM_NODE_LIST 0x1100
/*rpr_material_node_info*/
#define RPR_MATERIAL_NODE_TYPE 0x1101 
#define RPR_MATERIAL_NODE_SYSTEM 0x1102 
#define RPR_MATERIAL_NODE_INPUT_COUNT 0x1103 
#define RPR_MATERIAL_NODE_ID 0x1104 
#define RPR_MATERIAL_NODE_NAME RPR_OBJECT_NAME
#define RPR_MATERIAL_NODE_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_MATERIAL_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_material_node_input_info*/
#define RPR_MATERIAL_NODE_INPUT_NAME 0x1103 
#define RPR_MATERIAL_NODE_INPUT_DESCRIPTION 0x1105 
#define RPR_MATERIAL_NODE_INPUT_VALUE 0x1106 
#define RPR_MATERIAL_NODE_INPUT_TYPE 0x1107 

// RPR_MATERIAL_NODE_INPUT_NAME_STRING 0x1104  not used anymore  you can only set/get parameters using  RPR_MATERIAL_INPUT_*

/*rpr_material_node_type*/
#define RPR_MATERIAL_NODE_DIFFUSE 0x1 
#define RPR_MATERIAL_NODE_MICROFACET 0x2 
#define RPR_MATERIAL_NODE_REFLECTION 0x3 
#define RPR_MATERIAL_NODE_REFRACTION 0x4 
#define RPR_MATERIAL_NODE_MICROFACET_REFRACTION 0x5 
#define RPR_MATERIAL_NODE_TRANSPARENT 0x6 
#define RPR_MATERIAL_NODE_EMISSIVE 0x7 
#define RPR_MATERIAL_NODE_WARD 0x8 
#define RPR_MATERIAL_NODE_ADD 0x9 
#define RPR_MATERIAL_NODE_BLEND 0xA 
#define RPR_MATERIAL_NODE_ARITHMETIC 0xB 
#define RPR_MATERIAL_NODE_FRESNEL 0xC 
#define RPR_MATERIAL_NODE_NORMAL_MAP 0xD 
#define RPR_MATERIAL_NODE_IMAGE_TEXTURE 0xE 
#define RPR_MATERIAL_NODE_NOISE2D_TEXTURE 0xF 
#define RPR_MATERIAL_NODE_DOT_TEXTURE 0x10 
#define RPR_MATERIAL_NODE_GRADIENT_TEXTURE 0x11 
#define RPR_MATERIAL_NODE_CHECKER_TEXTURE 0x12 
#define RPR_MATERIAL_NODE_CONSTANT_TEXTURE 0x13 
#define RPR_MATERIAL_NODE_INPUT_LOOKUP 0x14 
#define RPR_MATERIAL_NODE_BLEND_VALUE 0x16 
#define RPR_MATERIAL_NODE_PASSTHROUGH 0x17 
#define RPR_MATERIAL_NODE_ORENNAYAR 0x18 
#define RPR_MATERIAL_NODE_FRESNEL_SCHLICK 0x19 
#define RPR_MATERIAL_NODE_DIFFUSE_REFRACTION 0x1B 
#define RPR_MATERIAL_NODE_BUMP_MAP 0x1C 
#define RPR_MATERIAL_NODE_VOLUME 0x1D 
#define RPR_MATERIAL_NODE_MICROFACET_ANISOTROPIC_REFLECTION 0x1E 
#define RPR_MATERIAL_NODE_MICROFACET_ANISOTROPIC_REFRACTION 0x1F 
#define RPR_MATERIAL_NODE_TWOSIDED 0x20 
#define RPR_MATERIAL_NODE_UV_PROCEDURAL 0x21 
#define RPR_MATERIAL_NODE_MICROFACET_BECKMANN 0x22 
#define RPR_MATERIAL_NODE_PHONG 0x23 
#define RPR_MATERIAL_NODE_BUFFER_SAMPLER 0x24 
#define RPR_MATERIAL_NODE_UV_TRIPLANAR 0x25 
#define RPR_MATERIAL_NODE_AO_MAP 0x26 
#define RPR_MATERIAL_NODE_USER_TEXTURE_0 0x27 
#define RPR_MATERIAL_NODE_USER_TEXTURE_1 0x28 
#define RPR_MATERIAL_NODE_USER_TEXTURE_2 0x29 
#define RPR_MATERIAL_NODE_USER_TEXTURE_3 0x2a 
#define RPR_MATERIAL_NODE_UBERV2 0x2b
#define RPR_MATERIAL_NODE_TRANSFORM 0x2c
#define RPR_MATERIAL_NODE_RGB_TO_HSV 0x2d
#define RPR_MATERIAL_NODE_HSV_TO_RGB 0x2e
#define RPR_MATERIAL_NODE_USER_TEXTURE 0x2f
#define RPR_MATERIAL_NODE_TOON_CLOSURE 0x30
#define RPR_MATERIAL_NODE_TOON_RAMP 0x31
#define RPR_MATERIAL_NODE_VORONOI_TEXTURE 0x32 
#define RPR_MATERIAL_NODE_GRID_SAMPLER 0x33 
#define RPR_MATERIAL_NODE_BLACKBODY 0x34 
#define RPR_MATERIAL_NODE_RAMP 0x35 
#define RPR_MATERIAL_NODE_PRIMVAR_LOOKUP 0x36 
#define RPR_MATERIAL_NODE_ROUNDED_CORNER 0x37 

    
#define RPR_MATERIAL_NODE_MATX_DIFFUSE_BRDF 0x1000
#define RPR_MATERIAL_NODE_MATX_DIELECTRIC_BRDF 0x1001
#define RPR_MATERIAL_NODE_MATX_GENERALIZED_SCHLICK_BRDF 0x1002
#define RPR_MATERIAL_NODE_MATX_NOISE3D 0x1003
#define RPR_MATERIAL_NODE_MATX_TANGENT 0x1004
#define RPR_MATERIAL_NODE_MATX_NORMAL 0x1005
#define RPR_MATERIAL_NODE_MATX_POSITION 0x1006
#define RPR_MATERIAL_NODE_MATX_ROUGHNESS_ANISOTROPY 0x1007
#define RPR_MATERIAL_NODE_MATX_ROTATE3D 0x1008
#define RPR_MATERIAL_NODE_MATX_NORMALIZE 0x1009
#define RPR_MATERIAL_NODE_MATX_IFGREATER 0x100A
#define RPR_MATERIAL_NODE_MATX_SHEEN_BRDF 0x100B
#define RPR_MATERIAL_NODE_MATX_DIFFUSE_BTDF 0x100C
#define RPR_MATERIAL_NODE_MATX_CONVERT 0x100D
#define RPR_MATERIAL_NODE_MATX_SUBSURFACE_BRDF 0x100E
#define RPR_MATERIAL_NODE_MATX_DIELECTRIC_BTDF 0x100F
#define RPR_MATERIAL_NODE_MATX_CONDUCTOR_BRDF 0x1010
#define RPR_MATERIAL_NODE_MATX_FRESNEL 0x1011
#define RPR_MATERIAL_NODE_MATX_LUMINANCE 0x1012
#define RPR_MATERIAL_NODE_MATX_FRACTAL3D 0x1013
#define RPR_MATERIAL_NODE_MATX_MIX 0x1014
#define RPR_MATERIAL_NODE_MATX 0x1015
#define RPR_MATERIAL_NODE_MATX_ARTISTIC_IOR 0x1016
#define RPR_MATERIAL_NODE_MATX_GENERALIZED_SCHLICK_BTDF 0x1017
#define RPR_MATERIAL_NODE_MATX_LAYER 0x1018
#define RPR_MATERIAL_NODE_MATX_THIN_FILM 0x1019
#define RPR_MATERIAL_NODE_MATX_BITANGENT 0x101A
#define RPR_MATERIAL_NODE_MATX_TEXCOORD 0x101B
#define RPR_MATERIAL_NODE_MATX_MODULO 0x101C
#define RPR_MATERIAL_NODE_MATX_ABSVAL 0x101D
#define RPR_MATERIAL_NODE_MATX_SIGN 0x101E
#define RPR_MATERIAL_NODE_MATX_FLOOR 0x101F
#define RPR_MATERIAL_NODE_MATX_CEIL 0x1020
#define RPR_MATERIAL_NODE_MATX_ATAN2 0x1021
#define RPR_MATERIAL_NODE_MATX_SQRT 0x1022
#define RPR_MATERIAL_NODE_MATX_LN 0x1023
#define RPR_MATERIAL_NODE_MATX_EXP 0x1024
#define RPR_MATERIAL_NODE_MATX_CLAMP 0x1025
#define RPR_MATERIAL_NODE_MATX_MIN 0x1026
#define RPR_MATERIAL_NODE_MATX_MAX 0x1027
#define RPR_MATERIAL_NODE_MATX_MAGNITUDE 0x1028
#define RPR_MATERIAL_NODE_MATX_CROSSPRODUCT 0x1029
#define RPR_MATERIAL_NODE_MATX_REMAP 0x102A
#define RPR_MATERIAL_NODE_MATX_SMOOTHSTEP 0x102B
#define RPR_MATERIAL_NODE_MATX_RGBTOHSV 0x102C
#define RPR_MATERIAL_NODE_MATX_HSVTORGB 0x102D
#define RPR_MATERIAL_NODE_MATX_IFGREATEREQ 0x102E
#define RPR_MATERIAL_NODE_MATX_IFEQUAL 0x102F
#define RPR_MATERIAL_NODE_MATX_SWIZZLE 0x1030
#define RPR_MATERIAL_NODE_MATX_NOISE2D 0x1031
#define RPR_MATERIAL_NODE_MATX_PLUS 0x1032
#define RPR_MATERIAL_NODE_MATX_MINUS 0x1033
#define RPR_MATERIAL_NODE_MATX_DIFFERENCE 0x1034
#define RPR_MATERIAL_NODE_MATX_BURN 0x1035
#define RPR_MATERIAL_NODE_MATX_DODGE 0x1036
#define RPR_MATERIAL_NODE_MATX_SCREEN 0x1037
#define RPR_MATERIAL_NODE_MATX_OVERLAY 0x1038
#define RPR_MATERIAL_NODE_MATX_INSIDE 0x1039
#define RPR_MATERIAL_NODE_MATX_OUTSIDE 0x103A
#define RPR_MATERIAL_NODE_MATX_RAMPLR 0x103B
#define RPR_MATERIAL_NODE_MATX_RAMPTB 0x103C
#define RPR_MATERIAL_NODE_MATX_SPLITLR 0x103D
#define RPR_MATERIAL_NODE_MATX_SPLITTB 0x103E
#define RPR_MATERIAL_NODE_MATX_CELLNOISE2D 0x103F
#define RPR_MATERIAL_NODE_MATX_CELLNOISE3D 0x1040
#define RPR_MATERIAL_NODE_MATX_ROTATE2D 0x1041
#define RPR_MATERIAL_NODE_MATX_DOT 0x1042
#define RPR_MATERIAL_NODE_MATX_RANGE 0x1043
#define RPR_MATERIAL_NODE_MATX_SWITCH 0x1044
#define RPR_MATERIAL_NODE_MATX_EXTRACT 0x1045
#define RPR_MATERIAL_NODE_MATX_COMBINE2 0x1046
#define RPR_MATERIAL_NODE_MATX_COMBINE3 0x1047
#define RPR_MATERIAL_NODE_MATX_COMBINE4 0x1048
#define RPR_MATERIAL_NODE_MATX_TRIPLANARPROJECTION 0x1049
#define RPR_MATERIAL_NODE_MATX_MULTIPLY 0x104A
/*rpr_material_node_input*/
#define RPR_MATERIAL_INPUT_COLOR 0x0 
#define RPR_MATERIAL_INPUT_COLOR0 0x1 
#define RPR_MATERIAL_INPUT_COLOR1 0x2 
#define RPR_MATERIAL_INPUT_NORMAL 0x3 
#define RPR_MATERIAL_INPUT_UV 0x4 
#define RPR_MATERIAL_INPUT_DATA 0x5 
#define RPR_MATERIAL_INPUT_ROUGHNESS 0x6 
#define RPR_MATERIAL_INPUT_IOR 0x7 
#define RPR_MATERIAL_INPUT_ROUGHNESS_X 0x8 
#define RPR_MATERIAL_INPUT_ROUGHNESS_Y 0x9 
#define RPR_MATERIAL_INPUT_ROTATION 0xA 
#define RPR_MATERIAL_INPUT_WEIGHT 0xB 
#define RPR_MATERIAL_INPUT_OP 0xC 
#define RPR_MATERIAL_INPUT_INVEC 0xD 
#define RPR_MATERIAL_INPUT_UV_SCALE 0xE 
#define RPR_MATERIAL_INPUT_VALUE 0xF 
#define RPR_MATERIAL_INPUT_REFLECTANCE 0x10 
#define RPR_MATERIAL_INPUT_SCALE 0x11 
#define RPR_MATERIAL_INPUT_SCATTERING 0x12 
#define RPR_MATERIAL_INPUT_ABSORBTION 0x13 
#define RPR_MATERIAL_INPUT_EMISSION 0x14 
#define RPR_MATERIAL_INPUT_G 0x15 
#define RPR_MATERIAL_INPUT_MULTISCATTER 0x16 
#define RPR_MATERIAL_INPUT_COLOR2 0x17 
#define RPR_MATERIAL_INPUT_COLOR3 0x18 
#define RPR_MATERIAL_INPUT_ANISOTROPIC 0x19 
#define RPR_MATERIAL_INPUT_FRONTFACE 0x1a 
#define RPR_MATERIAL_INPUT_BACKFACE 0x1b 
#define RPR_MATERIAL_INPUT_ORIGIN 0x1c 
#define RPR_MATERIAL_INPUT_ZAXIS 0x1d 
#define RPR_MATERIAL_INPUT_XAXIS 0x1e 
#define RPR_MATERIAL_INPUT_THRESHOLD 0x1f 
#define RPR_MATERIAL_INPUT_OFFSET 0x20 
#define RPR_MATERIAL_INPUT_UV_TYPE 0x21 
#define RPR_MATERIAL_INPUT_RADIUS 0x22 
#define RPR_MATERIAL_INPUT_SIDE 0x23 
#define RPR_MATERIAL_INPUT_CAUSTICS 0x24 
#define RPR_MATERIAL_INPUT_TRANSMISSION_COLOR 0x25 
#define RPR_MATERIAL_INPUT_THICKNESS 0x26 
#define RPR_MATERIAL_INPUT_0 0x27 
#define RPR_MATERIAL_INPUT_1 0x28 
#define RPR_MATERIAL_INPUT_2 0x29 
#define RPR_MATERIAL_INPUT_3 0x2a 
#define RPR_MATERIAL_INPUT_4 0x2b 
#define RPR_MATERIAL_INPUT_SCHLICK_APPROXIMATION 0x2c 
#define RPR_MATERIAL_INPUT_APPLYSURFACE 0x2d 
#define RPR_MATERIAL_INPUT_TANGENT 0x2e 
#define RPR_MATERIAL_INPUT_DISTRIBUTION 0x2f 
#define RPR_MATERIAL_INPUT_BASE 0x30 
#define RPR_MATERIAL_INPUT_TINT 0x31 
#define RPR_MATERIAL_INPUT_EXPONENT 0x32 
#define RPR_MATERIAL_INPUT_AMPLITUDE 0x33 
#define RPR_MATERIAL_INPUT_PIVOT 0x34 
#define RPR_MATERIAL_INPUT_POSITION 0x35 
#define RPR_MATERIAL_INPUT_AMOUNT 0x36 
#define RPR_MATERIAL_INPUT_AXIS 0x37 
#define RPR_MATERIAL_INPUT_LUMACOEFF 0x38 
#define RPR_MATERIAL_INPUT_REFLECTIVITY 0x39 
#define RPR_MATERIAL_INPUT_EDGE_COLOR 0x3a 
#define RPR_MATERIAL_INPUT_VIEW_DIRECTION 0x3b 
#define RPR_MATERIAL_INPUT_INTERIOR 0x3c 
#define RPR_MATERIAL_INPUT_OCTAVES 0x3d 
#define RPR_MATERIAL_INPUT_LACUNARITY 0x3e 
#define RPR_MATERIAL_INPUT_DIMINISH 0x3f 
#define RPR_MATERIAL_INPUT_WRAP_U 0x40 
#define RPR_MATERIAL_INPUT_WRAP_V 0x41 
#define RPR_MATERIAL_INPUT_WRAP_W 0x42 
#define RPR_MATERIAL_INPUT_5 0x43 
#define RPR_MATERIAL_INPUT_6 0x44 
#define RPR_MATERIAL_INPUT_7 0x45 
#define RPR_MATERIAL_INPUT_8 0x46 
#define RPR_MATERIAL_INPUT_9 0x47 
#define RPR_MATERIAL_INPUT_10 0x48 
#define RPR_MATERIAL_INPUT_11 0x49 
#define RPR_MATERIAL_INPUT_12 0x4a 
#define RPR_MATERIAL_INPUT_13 0x4b 
#define RPR_MATERIAL_INPUT_14 0x4c 
#define RPR_MATERIAL_INPUT_15 0x4d 
#define RPR_MATERIAL_INPUT_DIFFUSE_RAMP 0x4e 
#define RPR_MATERIAL_INPUT_SHADOW 0x4f 
#define RPR_MATERIAL_INPUT_MID 0x50 
#define RPR_MATERIAL_INPUT_HIGHLIGHT 0x51 
#define RPR_MATERIAL_INPUT_POSITION1 0x52 
#define RPR_MATERIAL_INPUT_POSITION2 0x53 
#define RPR_MATERIAL_INPUT_RANGE1 0x54 
#define RPR_MATERIAL_INPUT_RANGE2 0x55 
#define RPR_MATERIAL_INPUT_INTERPOLATION 0x56 
#define RPR_MATERIAL_INPUT_RANDOMNESS 0x57 
#define RPR_MATERIAL_INPUT_DIMENSION 0x58 
#define RPR_MATERIAL_INPUT_OUTTYPE 0x59 
#define RPR_MATERIAL_INPUT_DENSITY 0x5a 
#define RPR_MATERIAL_INPUT_DENSITYGRID 0x5b 
#define RPR_MATERIAL_INPUT_DISPLACEMENT 0x5c 
#define RPR_MATERIAL_INPUT_TEMPERATURE 0x5d 
#define RPR_MATERIAL_INPUT_KELVIN 0x5e 
#define RPR_MATERIAL_INPUT_EXTINCTION 0x5f 
#define RPR_MATERIAL_INPUT_THIN_FILM 0x60 
#define RPR_MATERIAL_INPUT_TOP 0x61 
#define RPR_MATERIAL_INPUT_HIGHLIGHT2 0x62 
#define RPR_MATERIAL_INPUT_SHADOW2 0x63 
#define RPR_MATERIAL_INPUT_POSITION_SHADOW 0x64 
#define RPR_MATERIAL_INPUT_POSITION_HIGHLIGHT 0x65 
#define RPR_MATERIAL_INPUT_RANGE_SHADOW 0x66 
#define RPR_MATERIAL_INPUT_RANGE_HIGHLIGHT 0x67 
#define RPR_MATERIAL_INPUT_TOON_5_COLORS 0x68 
#define RPR_MATERIAL_INPUT_X 0x69 
#define RPR_MATERIAL_INPUT_Y 0x6a 
#define RPR_MATERIAL_INPUT_Z 0x6b 
#define RPR_MATERIAL_INPUT_W 0x6c 
#define RPR_MATERIAL_INPUT_LIGHT 0x6d 
#define RPR_MATERIAL_INPUT_MID_IS_ALBEDO 0x6e 
#define RPR_MATERIAL_INPUT_SAMPLES 0x6f 
#define RPR_MATERIAL_INPUT_BASE_NORMAL 0x70 
#define RPR_MATERIAL_INPUT_UBER_DIFFUSE_COLOR 0x910
#define RPR_MATERIAL_INPUT_UBER_DIFFUSE_WEIGHT 0x927
#define RPR_MATERIAL_INPUT_UBER_DIFFUSE_ROUGHNESS 0x911
#define RPR_MATERIAL_INPUT_UBER_DIFFUSE_NORMAL 0x912
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_COLOR 0x913
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_WEIGHT 0x928
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_ROUGHNESS 0x914
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_ANISOTROPY 0x915
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_ANISOTROPY_ROTATION 0x916
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_MODE 0x917
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_IOR 0x918
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_METALNESS 0x919
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_NORMAL 0x929
#define RPR_MATERIAL_INPUT_UBER_REFLECTION_DIELECTRIC_REFLECTANCE 0x93e
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_COLOR 0x91A
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_WEIGHT 0x92a
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_ROUGHNESS 0x91B
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_IOR 0x91C
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_NORMAL 0x92b
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_THIN_SURFACE 0x91D
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_ABSORPTION_COLOR 0x92c
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_ABSORPTION_DISTANCE 0x92d
#define RPR_MATERIAL_INPUT_UBER_REFRACTION_CAUSTICS 0x92e
#define RPR_MATERIAL_INPUT_UBER_COATING_COLOR 0x91E
#define RPR_MATERIAL_INPUT_UBER_COATING_WEIGHT 0x92f
#define RPR_MATERIAL_INPUT_UBER_COATING_ROUGHNESS 0x91F
#define RPR_MATERIAL_INPUT_UBER_COATING_MODE 0x920
#define RPR_MATERIAL_INPUT_UBER_COATING_IOR 0x921
#define RPR_MATERIAL_INPUT_UBER_COATING_METALNESS 0x922
#define RPR_MATERIAL_INPUT_UBER_COATING_NORMAL 0x923
#define RPR_MATERIAL_INPUT_UBER_COATING_TRANSMISSION_COLOR 0x930
#define RPR_MATERIAL_INPUT_UBER_COATING_THICKNESS 0x931
#define RPR_MATERIAL_INPUT_UBER_SHEEN 0x932
#define RPR_MATERIAL_INPUT_UBER_SHEEN_TINT 0x933
#define RPR_MATERIAL_INPUT_UBER_SHEEN_WEIGHT 0x934
#define RPR_MATERIAL_INPUT_UBER_EMISSION_COLOR 0x924
#define RPR_MATERIAL_INPUT_UBER_EMISSION_WEIGHT 0x925
#define RPR_MATERIAL_INPUT_UBER_EMISSION_MODE 0x935
#define RPR_MATERIAL_INPUT_UBER_TRANSPARENCY 0x926
#define RPR_MATERIAL_INPUT_UBER_SSS_SCATTER_COLOR 0x937
#define RPR_MATERIAL_INPUT_UBER_SSS_SCATTER_DISTANCE 0x938
#define RPR_MATERIAL_INPUT_UBER_SSS_SCATTER_DIRECTION 0x939
#define RPR_MATERIAL_INPUT_UBER_SSS_WEIGHT 0x93a
#define RPR_MATERIAL_INPUT_UBER_SSS_MULTISCATTER 0x93b
#define RPR_MATERIAL_INPUT_UBER_BACKSCATTER_WEIGHT 0x93c
#define RPR_MATERIAL_INPUT_UBER_BACKSCATTER_COLOR 0x93d
#define RPR_MATERIAL_INPUT_ADDRESS 0x93e
#define RPR_MATERIAL_INPUT_TYPE 0x93f
#define RPR_MATERIAL_INPUT_UBER_FRESNEL_SCHLICK_APPROXIMATION RPR_MATERIAL_INPUT_SCHLICK_APPROXIMATION
/*rpr_material_input_raster*/
#define RPR_MATERIAL_INPUT_RASTER_METALLIC 0x901 
#define RPR_MATERIAL_INPUT_RASTER_ROUGHNESS 0x902 
#define RPR_MATERIAL_INPUT_RASTER_SUBSURFACE 0x903 
#define RPR_MATERIAL_INPUT_RASTER_ANISOTROPIC 0x904 
#define RPR_MATERIAL_INPUT_RASTER_SPECULAR 0x905 
#define RPR_MATERIAL_INPUT_RASTER_SPECULARTINT 0x906 
#define RPR_MATERIAL_INPUT_RASTER_SHEEN 0x907 
#define RPR_MATERIAL_INPUT_RASTER_SHEENTINT 0x908 
#define RPR_MATERIAL_INPUT_RASTER_CLEARCOAT 0x90A 
#define RPR_MATERIAL_INPUT_RASTER_CLEARCOATGLOSS 0x90B 
#define RPR_MATERIAL_INPUT_RASTER_COLOR 0x90C 
#define RPR_MATERIAL_INPUT_RASTER_NORMAL 0x90D 
/*rpr_interpolation_mode*/
#define RPR_INTERPOLATION_MODE_NONE 0x0
#define RPR_INTERPOLATION_MODE_LINEAR 0x1
/*rpr_ubermaterial_ior_mode*/
#define RPR_UBER_MATERIAL_IOR_MODE_PBR 0x1
#define RPR_UBER_MATERIAL_IOR_MODE_METALNESS 0x2
/*rpr_ubermaterial_emission_mode*/
#define RPR_UBER_MATERIAL_EMISSION_MODE_SINGLESIDED 0x1
#define RPR_UBER_MATERIAL_EMISSION_MODE_DOUBLESIDED 0x2
/*rpr_material_node_arithmetic_operation*/
#define RPR_MATERIAL_NODE_OP_ADD 0x00 
#define RPR_MATERIAL_NODE_OP_SUB 0x01 
#define RPR_MATERIAL_NODE_OP_MUL 0x02 
#define RPR_MATERIAL_NODE_OP_DIV 0x03 
#define RPR_MATERIAL_NODE_OP_SIN 0x04 
#define RPR_MATERIAL_NODE_OP_COS 0x05 
#define RPR_MATERIAL_NODE_OP_TAN 0x06 
#define RPR_MATERIAL_NODE_OP_SELECT_X 0x07 
#define RPR_MATERIAL_NODE_OP_SELECT_Y 0x08 
#define RPR_MATERIAL_NODE_OP_SELECT_Z 0x09 
#define RPR_MATERIAL_NODE_OP_COMBINE 0x0A 
#define RPR_MATERIAL_NODE_OP_DOT3 0x0B 
#define RPR_MATERIAL_NODE_OP_CROSS3 0x0C 
#define RPR_MATERIAL_NODE_OP_LENGTH3 0x0D 
#define RPR_MATERIAL_NODE_OP_NORMALIZE3 0x0E 
#define RPR_MATERIAL_NODE_OP_POW 0x0F 
#define RPR_MATERIAL_NODE_OP_ACOS 0x10 
#define RPR_MATERIAL_NODE_OP_ASIN 0x11 
#define RPR_MATERIAL_NODE_OP_ATAN 0x12 
#define RPR_MATERIAL_NODE_OP_AVERAGE_XYZ 0x13 
#define RPR_MATERIAL_NODE_OP_AVERAGE 0x14 
#define RPR_MATERIAL_NODE_OP_MIN 0x15 
#define RPR_MATERIAL_NODE_OP_MAX 0x16 
#define RPR_MATERIAL_NODE_OP_FLOOR 0x17 
#define RPR_MATERIAL_NODE_OP_MOD 0x18 
#define RPR_MATERIAL_NODE_OP_ABS 0x19 
#define RPR_MATERIAL_NODE_OP_SHUFFLE_YZWX 0x1a 
#define RPR_MATERIAL_NODE_OP_SHUFFLE_ZWXY 0x1b 
#define RPR_MATERIAL_NODE_OP_SHUFFLE_WXYZ 0x1c 
#define RPR_MATERIAL_NODE_OP_MAT_MUL 0x1d 
#define RPR_MATERIAL_NODE_OP_SELECT_W 0x1e 
#define RPR_MATERIAL_NODE_OP_DOT4 0x1f 
#define RPR_MATERIAL_NODE_OP_LOG 0x20 
#define RPR_MATERIAL_NODE_OP_LOWER_OR_EQUAL 0x21 
#define RPR_MATERIAL_NODE_OP_LOWER 0x22 
#define RPR_MATERIAL_NODE_OP_GREATER_OR_EQUAL 0x23 
#define RPR_MATERIAL_NODE_OP_GREATER 0x24 
#define RPR_MATERIAL_NODE_OP_EQUAL 0x25 
#define RPR_MATERIAL_NODE_OP_NOT_EQUAL 0x26 
#define RPR_MATERIAL_NODE_OP_AND 0x27 
#define RPR_MATERIAL_NODE_OP_OR 0x28 
#define RPR_MATERIAL_NODE_OP_TERNARY 0x29 
/*rpr_material_node_lookup_value*/
#define RPR_MATERIAL_NODE_LOOKUP_UV 0x0 
#define RPR_MATERIAL_NODE_LOOKUP_N 0x1 
#define RPR_MATERIAL_NODE_LOOKUP_P 0x2 
#define RPR_MATERIAL_NODE_LOOKUP_INVEC 0x3 
#define RPR_MATERIAL_NODE_LOOKUP_OUTVEC 0x4 
#define RPR_MATERIAL_NODE_LOOKUP_UV1 0x5 
#define RPR_MATERIAL_NODE_LOOKUP_P_LOCAL 0x6 
#define RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE0 0x7 
#define RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE1 0x8 
#define RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE2 0x9 
#define RPR_MATERIAL_NODE_LOOKUP_VERTEX_VALUE3 0xa 
#define RPR_MATERIAL_NODE_LOOKUP_SHAPE_RANDOM_COLOR 0xb 
#define RPR_MATERIAL_NODE_LOOKUP_OBJECT_ID 0xc 
#define RPR_MATERIAL_NODE_LOOKUP_PRIMITIVE_RANDOM_COLOR 0xd 
/*rpr_material_gradient_procedural_type*/
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_LINEAR 0x1 
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_QUADRATIC 0x2 
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_EASING 0x3 
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_DIAGONAL 0x4 
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_SPHERICAL 0x5 
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_QUAD_SPHERE 0x6 
#define RPR_MATERIAL_GRADIENT_PROCEDURAL_TYPE_RADIAL 0x7 
/*rpr_material_node_uvtype_value*/
#define RPR_MATERIAL_NODE_UVTYPE_PLANAR 0x0 
#define RPR_MATERIAL_NODE_UVTYPE_CYLINDICAL 0x1 
#define RPR_MATERIAL_NODE_UVTYPE_SPHERICAL 0x2 
#define RPR_MATERIAL_NODE_UVTYPE_PROJECT 0x3 
/*rpr_material_node_transform_op*/
#define RPR_MATERIAL_NODE_TRANSFORM_ROTATE_LOCAL_TO_WORLD 0x1 
/*rpr_post_effect_info*/
#define RPR_POST_EFFECT_TYPE 0x0 
#define RPR_POST_EFFECT_WHITE_BALANCE_COLOR_SPACE 0x4 
#define RPR_POST_EFFECT_WHITE_BALANCE_COLOR_TEMPERATURE 0x5 
#define RPR_POST_EFFECT_SIMPLE_TONEMAP_EXPOSURE 0x6 
#define RPR_POST_EFFECT_SIMPLE_TONEMAP_CONTRAST 0x7 
#define RPR_POST_EFFECT_SIMPLE_TONEMAP_ENABLE_TONEMAP 0x8 
#define RPR_POST_EFFECT_BLOOM_RADIUS 0x9 
#define RPR_POST_EFFECT_BLOOM_THRESHOLD 0x0a 
#define RPR_POST_EFFECT_BLOOM_WEIGHT 0x0b 
#define RPR_POST_EFFECT_NAME RPR_OBJECT_NAME
#define RPR_POST_EFFECT_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_POST_EFFECT_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_aov*/
#define RPR_AOV_COLOR 0x0 
#define RPR_AOV_OPACITY 0x1 
#define RPR_AOV_WORLD_COORDINATE 0x2 
#define RPR_AOV_UV 0x3 
#define RPR_AOV_MATERIAL_ID 0x4 
#define RPR_AOV_GEOMETRIC_NORMAL 0x5 
#define RPR_AOV_SHADING_NORMAL 0x6 
#define RPR_AOV_DEPTH 0x7 
#define RPR_AOV_OBJECT_ID 0x8 
#define RPR_AOV_OBJECT_GROUP_ID 0x9 
#define RPR_AOV_SHADOW_CATCHER 0x0a 
#define RPR_AOV_BACKGROUND 0x0b 
#define RPR_AOV_EMISSION 0x0c 
#define RPR_AOV_VELOCITY 0x0d 
#define RPR_AOV_DIRECT_ILLUMINATION 0x0e 
#define RPR_AOV_INDIRECT_ILLUMINATION 0x0f 
#define RPR_AOV_AO 0x10 
#define RPR_AOV_DIRECT_DIFFUSE 0x11 
#define RPR_AOV_DIRECT_REFLECT 0x12 
#define RPR_AOV_INDIRECT_DIFFUSE 0x13 
#define RPR_AOV_INDIRECT_REFLECT 0x14 
#define RPR_AOV_REFRACT 0x15 
#define RPR_AOV_VOLUME 0x16 
#define RPR_AOV_LIGHT_GROUP0 0x17 
#define RPR_AOV_LIGHT_GROUP1 0x18 
#define RPR_AOV_LIGHT_GROUP2 0x19 
#define RPR_AOV_LIGHT_GROUP3 0x1a 
#define RPR_AOV_DIFFUSE_ALBEDO 0x1b 
#define RPR_AOV_VARIANCE 0x1c 
#define RPR_AOV_VIEW_SHADING_NORMAL 0x1d
#define RPR_AOV_REFLECTION_CATCHER 0x1e
#define RPR_AOV_COLOR_RIGHT 0x1f 
#define RPR_AOV_LPE_0 0x20 
#define RPR_AOV_LPE_1 0x21 
#define RPR_AOV_LPE_2 0x22 
#define RPR_AOV_LPE_3 0x23 
#define RPR_AOV_LPE_4 0x24 
#define RPR_AOV_LPE_5 0x25 
#define RPR_AOV_LPE_6 0x26 
#define RPR_AOV_LPE_7 0x27 
#define RPR_AOV_LPE_8 0x28 
#define RPR_AOV_CAMERA_NORMAL 0x29 
#define RPR_AOV_MATTE_PASS 0x2a 
#define RPR_AOV_SSS 0x2b 
#define RPR_AOV_CRYPTOMATTE_MAT0 0x30
#define RPR_AOV_CRYPTOMATTE_MAT1 0x31
#define RPR_AOV_CRYPTOMATTE_MAT2 0x32
#define RPR_AOV_CRYPTOMATTE_MAT3 0x33
#define RPR_AOV_CRYPTOMATTE_MAT4 0x34
#define RPR_AOV_CRYPTOMATTE_MAT5 0x35
#define RPR_AOV_CRYPTOMATTE_OBJ0 0x38
#define RPR_AOV_CRYPTOMATTE_OBJ1 0x39
#define RPR_AOV_CRYPTOMATTE_OBJ2 0x3a
#define RPR_AOV_CRYPTOMATTE_OBJ3 0x3b
#define RPR_AOV_CRYPTOMATTE_OBJ4 0x3c
#define RPR_AOV_CRYPTOMATTE_OBJ5 0x3d
#define RPR_AOV_DEEP_COLOR 0x40
#define RPR_AOV_LIGHT_GROUP4 0x50 
#define RPR_AOV_LIGHT_GROUP5 0x51 
#define RPR_AOV_LIGHT_GROUP6 0x52 
#define RPR_AOV_LIGHT_GROUP7 0x53 
#define RPR_AOV_LIGHT_GROUP8 0x54 
#define RPR_AOV_LIGHT_GROUP9 0x55 
#define RPR_AOV_LIGHT_GROUP10 0x56 
#define RPR_AOV_LIGHT_GROUP11 0x57 
#define RPR_AOV_LIGHT_GROUP12 0x58 
#define RPR_AOV_LIGHT_GROUP13 0x59 
#define RPR_AOV_LIGHT_GROUP14 0x5a 
#define RPR_AOV_LIGHT_GROUP15 0x5b 
#define RPR_AOV_MESH_ID 0x60 
/*rpr_post_effect_type*/
#define RPR_POST_EFFECT_TONE_MAP 0x0 
#define RPR_POST_EFFECT_WHITE_BALANCE 0x1 
#define RPR_POST_EFFECT_SIMPLE_TONEMAP 0x2 
#define RPR_POST_EFFECT_NORMALIZATION 0x3 
#define RPR_POST_EFFECT_GAMMA_CORRECTION 0x4 
#define RPR_POST_EFFECT_BLOOM 0x5 
/*rpr_color_space*/
#define RPR_COLOR_SPACE_SRGB 0x1 
#define RPR_COLOR_SPACE_ADOBE_RGB 0x2 
#define RPR_COLOR_SPACE_REC2020 0x3 
#define RPR_COLOR_SPACE_DCIP3 0x4 
/*rpr_material_node_input_type*/

    
#define RPR_MATERIAL_NODE_INPUT_TYPE_FLOAT4 0x1 
#define RPR_MATERIAL_NODE_INPUT_TYPE_UINT 0x2 
#define RPR_MATERIAL_NODE_INPUT_TYPE_NODE 0x3 
#define RPR_MATERIAL_NODE_INPUT_TYPE_IMAGE 0x4 
#define RPR_MATERIAL_NODE_INPUT_TYPE_BUFFER 0x5 
#define RPR_MATERIAL_NODE_INPUT_TYPE_GRID 0x6 
#define RPR_MATERIAL_NODE_INPUT_TYPE_DATA 0x7 
#define RPR_MATERIAL_NODE_INPUT_TYPE_LIGHT 0x8 
/*rpr_subdiv_boundary_interfop_type*/
#define RPR_SUBDIV_BOUNDARY_INTERFOP_TYPE_EDGE_AND_CORNER 0x1 
#define RPR_SUBDIV_BOUNDARY_INTERFOP_TYPE_EDGE_ONLY 0x2 
/*rpr_image_wrap_type*/
#define RPR_IMAGE_WRAP_TYPE_REPEAT 0x1 
#define RPR_IMAGE_WRAP_TYPE_MIRRORED_REPEAT 0x2 
#define RPR_IMAGE_WRAP_TYPE_CLAMP_TO_EDGE 0x3 
#define RPR_IMAGE_WRAP_TYPE_CLAMP_ZERO 0x5 
#define RPR_IMAGE_WRAP_TYPE_CLAMP_ONE 0x6 
/*rpr_voronoi_out_type*/
#define RPR_VORONOI_OUT_TYPE_DISTANCE 0x1 
#define RPR_VORONOI_OUT_TYPE_COLOR 0x2 
#define RPR_VORONOI_OUT_TYPE_POSITION 0x3 
/*rpr_image_filter_type*/
#define RPR_IMAGE_FILTER_TYPE_NEAREST 0x1 
#define RPR_IMAGE_FILTER_TYPE_LINEAR 0x2 
/*rpr_composite_info*/
#define RPR_COMPOSITE_TYPE 0x1  
#define RPR_COMPOSITE_FRAMEBUFFER_INPUT_FB 0x2  
#define RPR_COMPOSITE_NORMALIZE_INPUT_COLOR 0x3  
#define RPR_COMPOSITE_NORMALIZE_INPUT_AOVTYPE 0x4  
#define RPR_COMPOSITE_CONSTANT_INPUT_VALUE 0x5  
#define RPR_COMPOSITE_LERP_VALUE_INPUT_COLOR0 0x6  
#define RPR_COMPOSITE_LERP_VALUE_INPUT_COLOR1 0x7  
#define RPR_COMPOSITE_LERP_VALUE_INPUT_WEIGHT 0x8  
#define RPR_COMPOSITE_ARITHMETIC_INPUT_COLOR0 0x9  
#define RPR_COMPOSITE_ARITHMETIC_INPUT_COLOR1 0x0a  
#define RPR_COMPOSITE_ARITHMETIC_INPUT_OP 0x0b  
#define RPR_COMPOSITE_GAMMA_CORRECTION_INPUT_COLOR 0x0c  
#define RPR_COMPOSITE_LUT_INPUT_LUT 0x0d  
#define RPR_COMPOSITE_LUT_INPUT_COLOR 0x0e  
#define RPR_COMPOSITE_NAME RPR_OBJECT_NAME
#define RPR_COMPOSITE_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_COMPOSITE_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_composite_type*/
#define RPR_COMPOSITE_ARITHMETIC 0x1  
#define RPR_COMPOSITE_LERP_VALUE 0x2  
#define RPR_COMPOSITE_INVERSE 0x3  
#define RPR_COMPOSITE_NORMALIZE 0x4  
#define RPR_COMPOSITE_GAMMA_CORRECTION 0x5  
#define RPR_COMPOSITE_EXPOSURE 0x6  
#define RPR_COMPOSITE_CONTRAST 0x7  
#define RPR_COMPOSITE_SIDE_BY_SIDE 0x8  
#define RPR_COMPOSITE_TONEMAP_ACES 0x9  
#define RPR_COMPOSITE_TONEMAP_REINHARD 0xa  
#define RPR_COMPOSITE_TONEMAP_LINEAR 0xb  
#define RPR_COMPOSITE_FRAMEBUFFER 0xc  
#define RPR_COMPOSITE_CONSTANT 0xd  
#define RPR_COMPOSITE_LUT 0xe  
/*rpr_grid_parameter*/
#define RPR_GRID_SIZE_X 0x930 
#define RPR_GRID_SIZE_Y 0x931 
#define RPR_GRID_SIZE_Z 0x932 
#define RPR_GRID_DATA 0x933 
#define RPR_GRID_DATA_SIZEBYTE 0x934 
#define RPR_GRID_INDICES 0x936 
#define RPR_GRID_INDICES_NUMBER 0x937 
#define RPR_GRID_INDICES_TOPOLOGY 0x938 
#define RPR_GRID_NAME RPR_OBJECT_NAME
#define RPR_GRID_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_GRID_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_hetero_volume_parameter*/
#define RPR_HETEROVOLUME_TRANSFORM 0x735 
#define RPR_HETEROVOLUME_ALBEDO_V2 0x73c 
#define RPR_HETEROVOLUME_DENSITY_V2 0x73d 
#define RPR_HETEROVOLUME_EMISSION_V2 0x73e 
#define RPR_HETEROVOLUME_ALBEDO_LOOKUP_VALUES 0x73f 
#define RPR_HETEROVOLUME_ALBEDO_LOOKUP_VALUES_COUNT 0x740 
#define RPR_HETEROVOLUME_DENSITY_LOOKUP_VALUES 0x741 
#define RPR_HETEROVOLUME_DENSITY_LOOKUP_VALUES_COUNT 0x742 
#define RPR_HETEROVOLUME_EMISSION_LOOKUP_VALUES 0x743 
#define RPR_HETEROVOLUME_EMISSION_LOOKUP_VALUES_COUNT 0x744 
#define RPR_HETEROVOLUME_ALBEDO_SCALE 0x745 
#define RPR_HETEROVOLUME_DENSITY_SCALE 0x746 
#define RPR_HETEROVOLUME_EMISSION_SCALE 0x747 
#define RPR_HETEROVOLUME_NAME RPR_OBJECT_NAME
#define RPR_HETEROVOLUME_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_HETEROVOLUME_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
/*rpr_grid_indices_topology*/
#define RPR_GRID_INDICES_TOPOLOGY_I_U64 0x950 
#define RPR_GRID_INDICES_TOPOLOGY_XYZ_U32 0x951 
#define RPR_GRID_INDICES_TOPOLOGY_I_S64 0x952 
#define RPR_GRID_INDICES_TOPOLOGY_XYZ_S32 0x953 
/*rpr_curve_parameter*/
#define RPR_CURVE_CONTROLPOINTS_COUNT 0x830 
#define RPR_CURVE_CONTROLPOINTS_DATA 0x831 
#define RPR_CURVE_CONTROLPOINTS_STRIDE 0x832 
#define RPR_CURVE_INDICES_COUNT 0x833 
#define RPR_CURVE_INDICES_DATA 0x834 
#define RPR_CURVE_RADIUS 0x835 
#define RPR_CURVE_UV 0x836 
#define RPR_CURVE_COUNT_CURVE 0x837 
#define RPR_CURVE_SEGMENTS_PER_CURVE 0x838 
#define RPR_CURVE_CREATION_FLAG 0x839 
#define RPR_CURVE_NAME RPR_OBJECT_NAME
#define RPR_CURVE_UNIQUE_ID RPR_OBJECT_UNIQUE_ID
#define RPR_CURVE_CUSTOM_PTR RPR_OBJECT_CUSTOM_PTR
#define RPR_CURVE_TRANSFORM RPR_SHAPE_TRANSFORM
#define RPR_CURVE_MATERIAL RPR_SHAPE_MATERIAL
#define RPR_CURVE_VISIBILITY_PRIMARY_ONLY_FLAG RPR_SHAPE_VISIBILITY_PRIMARY_ONLY_FLAG
#define RPR_CURVE_VISIBILITY_SHADOW RPR_SHAPE_VISIBILITY_SHADOW
#define RPR_CURVE_VISIBILITY_REFLECTION RPR_SHAPE_VISIBILITY_REFLECTION
#define RPR_CURVE_VISIBILITY_REFRACTION RPR_SHAPE_VISIBILITY_REFRACTION
#define RPR_CURVE_VISIBILITY_TRANSPARENT RPR_SHAPE_VISIBILITY_TRANSPARENT
#define RPR_CURVE_VISIBILITY_DIFFUSE RPR_SHAPE_VISIBILITY_DIFFUSE
#define RPR_CURVE_VISIBILITY_GLOSSY_REFLECTION RPR_SHAPE_VISIBILITY_GLOSSY_REFLECTION
#define RPR_CURVE_VISIBILITY_GLOSSY_REFRACTION RPR_SHAPE_VISIBILITY_GLOSSY_REFRACTION
#define RPR_CURVE_VISIBILITY_LIGHT RPR_SHAPE_VISIBILITY_LIGHT
#define RPR_CURVE_VISIBILITY_RECEIVE_SHADOW RPR_SHAPE_VISIBILITY_RECEIVE_SHADOW

/* rpr_bool */
#define RPR_FALSE 0u
#define RPR_TRUE 1u

/* Library types *//* This is going to be moved to rpr_platform.h or similar */
typedef char rpr_char;
typedef unsigned char rpr_uchar;
typedef int rpr_int;
typedef unsigned int rpr_uint;
typedef long int rpr_long;
typedef long unsigned int rpr_ulong;
typedef short int rpr_short;
typedef short unsigned int rpr_ushort;
typedef float rpr_float;
typedef double rpr_double;
typedef long long int rpr_longlong;
typedef int rpr_bool;
typedef rpr_uint rpr_bitfield;
typedef rpr_int rpr_status;
typedef void * rpr_context;
typedef void * rpr_camera;
typedef void * rpr_shape;
typedef void * rpr_light;
typedef void * rpr_scene;
typedef void * rpr_image;
typedef void * rpr_buffer;
typedef void * rpr_hetero_volume;
typedef void * rpr_grid;
typedef void * rpr_curve;
typedef void * rpr_framebuffer;
typedef void * rpr_material_system;
typedef void * rpr_material_node;
typedef void * rpr_post_effect;
typedef void * rpr_context_properties;
typedef void * rpr_composite;
typedef void * rpr_lut;
typedef rpr_uint rpr_light_type;
typedef rpr_uint rpr_image_option;
typedef rpr_uint rpr_shape_type;
typedef rpr_uint rpr_context_type;
typedef rpr_bitfield rpr_creation_flags;
typedef rpr_uint rpr_aa_filter;
typedef rpr_uint rpr_context_sampler_type;
typedef rpr_uint rpr_primvar_interpolation_type;
typedef rpr_uint rpr_context_info;
typedef rpr_uint rpr_camera_info;
typedef rpr_uint rpr_image_info;
typedef rpr_uint rpr_buffer_info;
typedef rpr_uint rpr_shape_info;
typedef rpr_uint rpr_mesh_info;
typedef rpr_uint rpr_light_info;
typedef rpr_uint rpr_lut_info;
typedef rpr_uint rpr_scene_info;
typedef rpr_uint rpr_parameter_info;
typedef rpr_uint rpr_framebuffer_info;
typedef rpr_uint rpr_channel_order;
typedef rpr_uint rpr_channel_type;
typedef rpr_uint rpr_parameter_type;
typedef rpr_uint rpr_render_mode;
typedef rpr_uint rpr_component_type;
typedef rpr_uint rpr_buffer_element_type;
typedef rpr_uint rpr_camera_mode;
typedef rpr_uint rpr_tonemapping_operator;
typedef rpr_uint rpr_volume_type;
typedef rpr_uint rpr_material_system_info;
typedef rpr_uint rpr_material_system_type;
typedef rpr_uint rpr_material_node_type;
typedef rpr_uint rpr_material_node_input;
typedef rpr_uint rpr_material_input_raster;
typedef rpr_uint rpr_material_node_input_type;
typedef rpr_uint rpr_material_node_info;
typedef rpr_uint rpr_material_node_input_info;
typedef rpr_uint rpr_aov;
typedef rpr_uint rpr_post_effect_type;
typedef rpr_uint rpr_post_effect_info;
typedef rpr_uint rpr_composite_info;
typedef rpr_uint rpr_composite_type;
typedef rpr_uint rpr_color_space;
typedef rpr_uint rpr_environment_override;
typedef rpr_uint rpr_subdiv_boundary_interfop_type;
typedef rpr_uint rpr_material_node_lookup_value;
typedef rpr_uint rpr_material_node_uvtype_value;
typedef rpr_uint rpr_material_gradient_procedural_type;
typedef rpr_uint rpr_material_node_transform_op;
typedef rpr_uint rpr_image_wrap_type;
typedef rpr_uint rpr_voronoi_out_type;
typedef rpr_uint rpr_image_filter_type;
typedef rpr_uint rpr_material_node_arithmetic_operation;
typedef rpr_uint rpr_hetero_volume_parameter;
typedef rpr_uint rpr_grid_parameter;
typedef rpr_uint rpr_curve_parameter;
typedef rpr_uint rpr_grid_indices_topology;
typedef rpr_uint rpr_ubermaterial_ior_mode;
typedef rpr_uint rpr_interpolation_mode;
typedef rpr_uint rpr_ubermaterial_emission_mode;

struct _rpr_image_desc
{
    rpr_uint image_width;
    rpr_uint image_height;
    rpr_uint image_depth;
    rpr_uint image_row_pitch;
    rpr_uint image_slice_pitch;
};
typedef _rpr_image_desc rpr_image_desc;

struct _rpr_buffer_desc
{
    rpr_uint nb_element;
    rpr_buffer_element_type element_type;
    rpr_uint element_channel_size;
};
typedef _rpr_buffer_desc rpr_buffer_desc;

struct _rpr_framebuffer_desc
{
    rpr_uint fb_width;
    rpr_uint fb_height;
};
typedef _rpr_framebuffer_desc rpr_framebuffer_desc;

struct _rpr_render_statistics
{
    rpr_longlong gpumem_usage;
    rpr_longlong gpumem_total;
    rpr_longlong gpumem_max_allocation;
    rpr_longlong sysmem_usage;
};
typedef _rpr_render_statistics rpr_render_statistics;

struct _rpr_image_format
{
    rpr_uint num_components;
    rpr_component_type type;
};
typedef _rpr_image_format rpr_image_format;

struct _rpr_framebuffer_format
{
    rpr_uint num_components;
    rpr_component_type type;
};
typedef _rpr_framebuffer_format rpr_framebuffer_format;

struct _rpr_ies_image_desc
{
    rpr_int w;
    rpr_int h;
    rpr_char const * data;
    rpr_char const * filename;
};
typedef _rpr_ies_image_desc rpr_ies_image_desc;


/* API functions */
    /** @brief Register rendering plugin
    *
    *  <Description>
    *
    *  @param path     Path of plugin to load (for UNICODE, supports UTF-8 encoding)
    *  @return         unique identifier of plugin, -1 otherwise
    */
  extern RPR_API_ENTRY rpr_int rprRegisterPlugin(rpr_char const * path);


    /** @brief Create rendering context
    *
    *  Rendering context is a root concept encapsulating the render states and responsible
    *  for execution control. All the entities in Radeon ProRender are created for a particular rendering context.
    *  Entities created for some context can't be used with other contexts. Possible error codes for this call are:
    *
    *     RPR_ERROR_COMPUTE_API_NOT_SUPPORTED
    *     RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *     RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *     RPR_ERROR_INVALID_API_VERSION
    *     RPR_ERROR_INVALID_PARAMETER
    *
    *  @param api_version     Api version constant
    *	 @param context_type    Determines compute API to use, OPENCL only is supported for now
    *  @param creation_flags  Determines multi-gpu or cpu-gpu configuration
    *  @param props           Context creation properties. Specifies a list of context property names and their corresponding values.
    *                         Each property name is immediately followed by the corresponding desired value.
    *                         The list is terminated with 0.
    *  @param cache_path      Full path to kernel cache created by Radeon ProRender, NULL means to use current folder (for UNICODE, supports UTF-8 encoding)
    *  @param cpu_thread_limit	Limit for the number of threads used for CPU rendering
    *  @param out_context		Pointer to context object
    *  @return                RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCreateContext(rpr_uint api_version, rpr_int const * pluginIDs, size_t pluginCount, rpr_creation_flags creation_flags, rpr_context_properties const * props, rpr_char const * cache_path, rpr_context * out_context);


    /** @breif Set active context plugin
    *
    */
  extern RPR_API_ENTRY rpr_status rprContextSetActivePlugin(rpr_context context, rpr_int pluginID);


    /** @brief Query information about a context
    *
    *  The workflow is usually two-step: query with the data == NULL and size = 0 to get the required buffer size in size_ret,
    *  then query with size_ret == NULL to fill the buffer with the data.
    *   Possible error codes:
    *     RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context         The context to query
    *  @param  context_info    The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetInfo(rpr_context context, rpr_context_info context_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a context parameter
    *
    *  The workflow is usually two-step: query with the data == NULL and size = 0 to get the required buffer size in size_ret,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *     RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context         The context to query
    *  @param  param_idx	   The index of the parameter - must be between 0 and  (value stored by RPR_CONTEXT_PARAMETER_COUNT)-1
    *  @param  parameter_info  The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetParameterInfo(rpr_context context, int param_idx, rpr_parameter_info parameter_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query the AOV
    *
    *  @param  context     The context to get a frame buffer from
    *  @param  out_fb		Pointer to framebuffer object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetAOV(rpr_context context, rpr_aov aov, rpr_framebuffer * out_fb);


    /** @brief Set AOV
    *
    *  @param  context         The context to set AOV
    *  @param  aov				AOV
    *  @param  frame_buffer    Frame buffer object to set
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetAOV(rpr_context context, rpr_aov aov, rpr_framebuffer frame_buffer);


    /** @brief
    *
    *  @param  context               The context to set 
    *  @param  renderLayerString   Render layer name to attach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextAttachRenderLayer(rpr_context context, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  context               The context to set 
    *  @param  renderLayerString   Render layer name to detach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextDetachRenderLayer(rpr_context context, rpr_char const * renderLayerString);


    /** @brief Set a LPE ( Light Path Expression ) to a framebuffer.
    *          Note that this framebuffer should also be assigned to a LPE AOV:  RPR_AOV_LPE_0 , RPR_AOV_LPE_1 ....
    *
    *
    *  @param  frame_buffer    Frame buffer object to set
    *  @param  lpe             Light Path Expression
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferSetLPE(rpr_framebuffer frame_buffer, rpr_char const * lpe);


    /** @brief Set AOV Index Lookup Color
    *          change the color of  AOV rendering IDs,  like : RPR_AOV_MATERIAL_ID , RPR_AOV_OBJECT_ID, RPR_AOV_OBJECT_GROUP_ID.
    *          for example, you can render all the  shapes with ObjectGroupID=4  in the Red color inside the RPR_AOV_OBJECT_GROUP_ID AOV
    *
    *  @param  context         The context to set AOV index lookup
    *  @param  key				id
    *  @param  colorR			red channel
    *  @param  colorG			green channel
    *  @param  colorB			blue channel
    *  @param  colorA			alpha channel
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetAOVindexLookup(rpr_context context, rpr_int key, rpr_float colorR, rpr_float colorG, rpr_float colorB, rpr_float colorA);


    /** @brief Set a Cutting Plane (also called Clipping plane).
    *
    * Notes:
    *  - In order to disable the 'index' cutting plane, set (A,B,C,D) = (0,0,0,0)
    *    By default, on context creation all cutting planes are disabled.
    * 
    *  - Index can be any number. It doesn't need to define the list of plane as a contiguous list of indices.
    *
    *  - If the number of enabled planes is greater than the limit supported by the renderer,
    *    then RPR_ERROR_UNSUPPORTED is return by the function.
    *
    *  - The normal of the equation plane points toward the area that is kept.
    *
    *  - If several clipping planes are used the rendered area will be the one commonly facing all the planes.
    *
    *  - Plane equation is Ax + By + Cz + D = 0
    *
    *  @param  context			The context to set the Cutting Plane
    *  @param  index			cutting plane index ( starts from 0 )
    *  @param  a				equation plane A
    *  @param  b				equation plane B
    *  @param  c				equation plane C
    *  @param  d				equation plane D
    *  @return					RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetCuttingPlane(rpr_context context, rpr_int index, rpr_float a, rpr_float b, rpr_float c, rpr_float d);


    /** @brief call a batch of rprContextSetAOVindexLookup
    *
    * example:
    * rprContextSetAOVindicesLookup(ctx, 2, 3, table);
    * is equivalent to call :
    * rprContextSetAOVindexLookup(ctx, 2, table[0], table[1], table[2],  table[3]);
    * rprContextSetAOVindexLookup(ctx, 3, table[4], table[5], table[6],  table[7]);
    * rprContextSetAOVindexLookup(ctx, 4, table[8], table[9], table[10], table[11]);
    * 
    * Depending on the plugin, rprContextSetAOVindicesLookup could be faster than calling several rprContextSetAOVindexLookup.
    */
  extern RPR_API_ENTRY rpr_status rprContextSetAOVindicesLookup(rpr_context context, rpr_int keyOffset, rpr_int keyCount, rpr_float const * colorRGBA);


    /**
    * API user can create its own procedural texture.
    * The API needs both a GPU code ( OpenCL string code ) and a CPU code ( callback )
    * (API function supported by Northstar only)
    *
    * example:  
    *      #define DEFINE_FUNC(FUNCNAME, FUNC) FUNC; const std::string g_str_##FUNCNAME = #FUNC;
    *      DEFINE_FUNC( RprCustomMatA ,   void RprCustomMatA(float* a, float* b, float* c, float* d, float* e, float* f, float* valueOut){   valueOut[0]=0.0;  valueOut[1]=sin(d[0]*3.14159);  valueOut[2]=0.0;  }   );
    *      rprContextSetUserTexture(context, 3, g_str_RprCustomMatA.c_str(), RprCustomMatA); // use slot 3
    *      // create material based on slot 3 :
    *      rpr_material_node matUserTex3; rprMaterialSystemCreateNode(matsys, RPR_MATERIAL_NODE_USER_TEXTURE, & matUserTex3);
    *      rprMaterialNodeSetInputUByKey(matUserTex3, RPR_MATERIAL_INPUT_OP, 3 ); // bind matUserTex3 to slot 3
    *      rprMaterialNodeSetInputNByKey(matUserTex3, RPR_MATERIAL_INPUT_4, paramInput ); // bind 'paramInput' to the 'e' argument of 'RprCustomMatA'
    *
    * Notes:
    * - If only the GPU is used, a nullptr can be given to 'cpuCode'.
    * - RPR_MATERIAL_NODE_USER_TEXTURE_0...RPR_MATERIAL_NODE_USER_TEXTURE_3   ,    RPR_CONTEXT_USER_TEXTURE_0...RPR_CONTEXT_USER_TEXTURE_3  are deprecated and should only be used with the old Tahoe plugin.
    * - When exporting the RPR scene to RPRS or GLTF, the CPU callback pointer will be lost in the imported scene.
    *
    */
  extern RPR_API_ENTRY rpr_status rprContextSetUserTexture(rpr_context context, rpr_int index, rpr_char const * gpuCode, void * cpuCode);


    /**
    * get the gpuCode string set by rprContextSetUserTexture.
    * (API function supported by Northstar only)
    */
  extern RPR_API_ENTRY rpr_status rprContextGetUserTexture(rpr_context context, rpr_int index, size_t bufferSizeByte, void * buffer, size_t * size_ret);


    /** @brief Set the scene
    *
    *  The scene is a collection of objects and lights
    *  along with all the data required to shade those. The scene is
    *  used by the context to render the image.
    *
    *  @param  context     The context to set the scene
    *  @param  scene       The scene to set
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetScene(rpr_context context, rpr_scene scene);


    /** @brief Get the current scene
    *
    *  The scene is a collection of objects and lights
    *  along with all the data required to shade those. The scene is
    *  used by the context ro render the image.
    *
    *  @param  context     The context to get the scene from
    *  @param  out_scene   Pointer to scene object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextGetScene(rpr_context arg0, rpr_scene * out_scene);


    /** @brief Set context parameter
    *
    * Parameters are used to control rendering modes, global sampling and AA settings, etc
    *
    * @param  context                        The context to set the value to
    * @param  in_input						  Param name, can be any  RPR_CONTEXT_*  value
    * @param x,y,z,w						   Parameter value
    * @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey1u(rpr_context context, rpr_context_info in_input, rpr_uint x);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKeyPtr(rpr_context context, rpr_context_info in_input, void * x);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey1f(rpr_context context, rpr_context_info in_input, rpr_float x);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey3f(rpr_context context, rpr_context_info in_input, rpr_float x, rpr_float y, rpr_float z);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKey4f(rpr_context context, rpr_context_info in_input, rpr_float x, rpr_float y, rpr_float z, rpr_float w);
extern RPR_API_ENTRY rpr_status rprContextSetParameterByKeyString(rpr_context context, rpr_context_info in_input, rpr_char const * value);


    /** @brief This is an internal/experimental backdoor for RPR developers team.
    *
    * A classic usage of RPR doesn't require usage of this call.
    * Use this only if you understand what you are doing.
    * It's sending the name/value directly to the plugin without any process of RPR API.
    * the 'paramName' is not related with the parameters of rprContextSetParameterByKey4f.
    * 'pluginIndex' can be used if the context has more than one plugin - Not Implemented for now, set it to 0.
    */
  extern RPR_API_ENTRY rpr_status rprContextSetInternalParameter4f(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_float x, rpr_float y, rpr_float z, rpr_float w);
extern RPR_API_ENTRY rpr_status rprContextSetInternalParameter1u(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_uint x);
extern RPR_API_ENTRY rpr_status rprContextSetInternalParameterBuffer(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, void const * buffer, size_t bufferSizeByte);
extern RPR_API_ENTRY rpr_status rprContextGetInternalParameter4f(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_float * x, rpr_float * y, rpr_float * z, rpr_float * w);
extern RPR_API_ENTRY rpr_status rprContextGetInternalParameter1u(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, rpr_uint * x);
extern RPR_API_ENTRY rpr_status rprContextGetInternalParameterBuffer(rpr_context context, rpr_uint pluginIndex, rpr_char const * paramName, size_t bufferSizeByte, void * buffer, size_t * size_ret);


    /** @brief Perform evaluation and accumulation of a single sample (or number of AA samples if AA is enabled)
    *
    *  The call is blocking and the image is ready when returned. The context accumulates the samples in order
    *  to progressively refine the image and enable interactive response. So each new call to Render refines the
    *  resultin image with 1 (or num aa samples) color samples. Call rprFrameBufferClear if you want to start rendering new image
    *  instead of refining the previous one.
    *
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_INTERNAL_ERROR
    *      RPR_ERROR_MATERIAL_STACK_OVERFLOW
    *
    *  if you have the RPR_ERROR_MATERIAL_STACK_OVERFLOW error, you have created a shader graph with too many nodes.
    *  you can check the nodes limit with rprContextGetInfo(,RPR_CONTEXT_MATERIAL_STACK_SIZE,)
    *
    *  @param  context     The context object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextRender(rpr_context context);


    /** @brief  can be called in a different thread to interrupt the rendering
	*  then, rprContextRender will return  RPR_ERROR_ABORTED instead of RPR_SUCCESS
    */
  extern RPR_API_ENTRY rpr_status rprContextAbortRender(rpr_context context);


    /** @brief Perform evaluation and accumulation of a single sample (or number of AA samples if AA is enabled) on the part of the image
    *
    *  The call is blocking and the image is ready when returned. The context accumulates the samples in order
    *  to progressively refine the image and enable interactive response. So each new call to Render refines the
    *  resultin image with 1 (or num aa samples) color samples. Call rprFrameBufferClear if you want to start rendering new image
    *  instead of refining the previous one. Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_INTERNAL_ERROR
    *
    *  @param  context     The context to use for the rendering
    *  @param  xmin        X coordinate of the top left corner of a tile
    *  @param  xmax        X coordinate of the bottom right corner of a tile
    *  @param  ymin        Y coordinate of the top left corner of a tile
    *  @param  ymax        Y coordinate of the bottom right corner of a tile
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextRenderTile(rpr_context context, rpr_uint xmin, rpr_uint xmax, rpr_uint ymin, rpr_uint ymax);


    /** @brief Clear all video memory used by the context
    *
    *  This function should be called after all context objects have been destroyed.
    *  It guarantees that all context memory is freed and returns the context into its initial state.
    *  Will be removed later. Possible error codes are:
    *
    *      RPR_ERROR_INTERNAL_ERROR
    *
    *  @param  context     The context to wipe out
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextClearMemory(rpr_context context);


    /** @brief Create an image from memory data
    *
    *  Images are used as HDRI maps or inputs for various shading system nodes.
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context     The context to create image
    *  @param  format      Image format
    *  @param  image_desc  Image layout description
    *  @param  data        Image data in system memory, can be NULL in which case the memory is allocated
    *  @param  out_image   Pointer to image object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateImage(rpr_context context, rpr_image_format const format, rpr_image_desc const * image_desc, void const * data, rpr_image * out_image);


    /** @brief Create a buffer from memory data
    *
    *  Buffers are used as arbitrary input for other nodes
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context     The context to create image
    *  @param  buffer_desc Buffer layout description
    *  @param  data        Image data in system memory, can be NULL in which case the memory is allocated
    *  @param  out_buffer  Pointer to buffer object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateBuffer(rpr_context context, rpr_buffer_desc const * buffer_desc, void const * data, rpr_buffer * out_buffer);


    /** @brief Create an image from file
    *
    *   Images are used as HDRI maps or inputs for various shading system nodes.
    *
    *  The following image formats are supported:
    *      PNG, JPG, TGA, BMP, TIFF, TX(0-mip), HDR, EXR
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_IO_ERROR
    *
    *  @param  context     The context to create image
    *  @param  path        NULL terminated path to an image file (can be relative) (for UNICODE, supports UTF-8 encoding)
    *  @param  out_image   Pointer to image object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateImageFromFile(rpr_context context, rpr_char const * path, rpr_image * out_image);


    /** @brief  similar to rprContextCreateImageFromFile, except that the file input as a memory buffer
    *   extension must look like : ".png" , ".bmp" , ".hdr" , ".exr" , ".jpg" ....
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateImageFromFileMemory(rpr_context context, rpr_char const * extension, void const * data, size_t dataSizeByte, rpr_image * out_image);


    /** @brief Create a scene
    *
    *  Scene serves as a container for lights and objects.
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  out_scene   Pointer to scene object
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateScene(rpr_context context, rpr_scene * out_scene);


    /** @brief Create an instance of an object
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  context  The context to create an instance for
    *  @param  shape    Parent shape for an instance
    *  @param  out_instance   Pointer to instance object
    *  @return RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateInstance(rpr_context context, rpr_shape shape, rpr_shape * out_instance);


    /** @brief Create a mesh
    *
    *  Radeon ProRender supports mixed meshes consisting of triangles and quads.
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  vertices            Pointer to position data (each position is described with 3 rpr_float numbers)
    *  @param  num_vertices        Number of entries in position array
    *  @param  vertex_stride       Number of bytes between the beginnings of two successive position entries
    *  @param  normals             Pointer to normal data (each normal is described with 3 rpr_float numbers), can be NULL
    *  @param  num_normals         Number of entries in normal array
    *  @param  normal_stride       Number of bytes between the beginnings of two successive normal entries
    *  @param  texcoord            Pointer to texcoord data (each texcoord is described with 2 rpr_float numbers), can be NULL
    *  @param  num_texcoords       Number of entries in texcoord array
    *  @param  texcoord_stride     Number of bytes between the beginnings of two successive texcoord entries
    *  @param  vertex_indices      Pointer to an array of vertex indices
    *  @param  vidx_stride         Number of bytes between the beginnings of two successive vertex index entries
    *  @param  normal_indices      Pointer to an array of normal indices
    *  @param  nidx_stride         Number of bytes between the beginnings of two successive normal index entries
    *  @param  texcoord_indices    Pointer to an array of texcoord indices
    *  @param  tidx_stride         Number of bytes between the beginnings of two successive texcoord index entries
    *  @param  num_face_vertices   Pointer to an array of num_faces numbers describing number of vertices for each face (can be 3(triangle) or 4(quad))
    *  @param  num_faces           Number of faces in the mesh
    *  @param  out_mesh            Pointer to mesh object
    *  @return                     RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateMesh(rpr_context context, rpr_float const * vertices, size_t num_vertices, rpr_int vertex_stride, rpr_float const * normals, size_t num_normals, rpr_int normal_stride, rpr_float const * texcoords, size_t num_texcoords, rpr_int texcoord_stride, rpr_int const * vertex_indices, rpr_int vidx_stride, rpr_int const * normal_indices, rpr_int nidx_stride, rpr_int const * texcoord_indices, rpr_int tidx_stride, rpr_int const * num_face_vertices, size_t num_faces, rpr_shape * out_mesh);


    /*  @brief Create a mesh
    *
    *  @return                     RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateMeshEx(rpr_context context, rpr_float const * vertices, size_t num_vertices, rpr_int vertex_stride, rpr_float const * normals, size_t num_normals, rpr_int normal_stride, rpr_int const * perVertexFlag, size_t num_perVertexFlags, rpr_int perVertexFlag_stride, rpr_int numberOfTexCoordLayers, rpr_float const ** texcoords, size_t const * num_texcoords, rpr_int const * texcoord_stride, rpr_int const * vertex_indices, rpr_int vidx_stride, rpr_int const * normal_indices, rpr_int nidx_stride, rpr_int const ** texcoord_indices, rpr_int const * tidx_stride, rpr_int const * num_face_vertices, size_t num_faces, rpr_shape * out_mesh);


    /*  @brief Create a mesh
    *
    *  @return                     RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateMeshEx2(rpr_context context, rpr_float const * vertices, size_t num_vertices, rpr_int vertex_stride, rpr_float const * normals, size_t num_normals, rpr_int normal_stride, rpr_int const * perVertexFlag, size_t num_perVertexFlags, rpr_int perVertexFlag_stride, rpr_int numberOfTexCoordLayers, rpr_float const ** texcoords, size_t const * num_texcoords, rpr_int const * texcoord_stride, rpr_int const * vertex_indices, rpr_int vidx_stride, rpr_int const * normal_indices, rpr_int nidx_stride, rpr_int const ** texcoord_indices, rpr_int const * tidx_stride, rpr_int const * num_face_vertices, size_t num_faces, rpr_mesh_info const * mesh_properties, rpr_shape * out_mesh);


    /** @brief Create a camera
    *
    *  There are several camera types supported by a single rpr_camera type.
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  @param  context The context to create a camera for
    *  @param  out_camera Pointer to camera object
    *  @return RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateCamera(rpr_context context, rpr_camera * out_camera);


    /** @brief Create framebuffer object
    *
    *  Framebuffer is used to store final rendering result.
    *
    *  Possible error codes are:
    *
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  @param  context  The context to create framebuffer
    *  @param  format   Framebuffer format
    *  @param  fb_desc  Framebuffer layout description
    *  @param  status   Pointer to framebuffer object
    *  @return          RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateFrameBuffer(rpr_context context, rpr_framebuffer_format const format, rpr_framebuffer_desc const * fb_desc, rpr_framebuffer * out_fb);


      /** @brief Loads extension function from context
      */
  extern RPR_API_ENTRY rpr_status rprContextGetFunctionPtr(rpr_context context, rpr_char const * function_name, void ** out_function_ptr);

/* rpr_camera */
    /** @brief Query information about a camera
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data.
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  camera      The camera to query
    *  @param  camera_info The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraGetInfo(rpr_camera camera, rpr_camera_info camera_info, size_t size, void * data, size_t * size_ret);


    /** @brief Set camera focal length.
    *
    *  @param  camera  The camera to set focal length
    *  @param  flength Focal length in millimeters, default is 35mm
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFocalLength(rpr_camera camera, rpr_float flength);


    /* Number of motion matrices (set with rprCameraSetMotionTransform) to use.
    *  Set  transformCount=0  if you don't use Motion.
    *  For the moment, if you use motion in Northstar, only transformCount=1 is supported.
    *  example: to create a motion from matA to matB:
    *      rprCameraSetTransform(camera, false, matA) // matrix at time=0
    *      rprCameraSetMotionTransform(camera, false, matB, 1) // matrix at time=1
    *      rprCameraSetMotionTransformCount(camera,1) // use 1 motion matrix
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetMotionTransformCount(rpr_camera camera, rpr_uint transformCount);


    /* For Motion effect, set the transform of camera at different time index.
    * 'transform' is an array of 16 rpr_float values (row-major form).
    *  timeIndex=1 is camera position at camera exposure = 1.0
    *  For the moment, in Nortstar plugin only timeIndex=1 is implemented
    *  You also have to call  rprCameraSetMotionTransformCount, to define the number of indices to use.
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetMotionTransform(rpr_camera camera, rpr_bool transpose, rpr_float const * transform, rpr_uint timeIndex);


    /** @brief Set camera focus distance
    *
    *  @param  camera  The camera to set focus distance
    *  @param  fdist   Focus distance in meters, default is 1m
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFocusDistance(rpr_camera camera, rpr_float fdist);


    /** @brief Set world transform for the camera
    *
    *  @param  camera      The camera to set transform for
    *  @param  transpose   Determines whether the basis vectors are in columns(false) or in rows(true) of the matrix
    *  @param  transform   Array of 16 rpr_float values (row-major form)
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetTransform(rpr_camera camera, rpr_bool transpose, rpr_float const * transform);


    /** @brief Set sensor size for the camera
    *
    *  Default sensor size is the one corresponding to full frame 36x24mm sensor
    *
    *  @param  camera  The camera to set transform for
    *  @param  width   Sensor width in millimeters
    *  @param  height  Sensor height in millimeters
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetSensorSize(rpr_camera camera, rpr_float width, rpr_float height);


    /** @brief Set camera transform in lookat form
    *
    *  @param  camera  The camera to set transform for
    *  @param  posx    X component of the position
    *  @param  posy    Y component of the position
    *  @param  posz    Z component of the position
    *  @param  atx     X component of the center point
    *  @param  aty     Y component of the center point
    *  @param  atz     Z component of the center point
    *  @param  upx     X component of the up vector
    *  @param  upy     Y component of the up vector
    *  @param  upz     Z component of the up vector
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraLookAt(rpr_camera camera, rpr_float posx, rpr_float posy, rpr_float posz, rpr_float atx, rpr_float aty, rpr_float atz, rpr_float upx, rpr_float upy, rpr_float upz);


    /** @brief Set f-stop for the camera
    *
    *  @param  camera  The camera to set f-stop for
    *  @param  fstop   f-stop value in mm^-1, default is FLT_MAX
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFStop(rpr_camera camera, rpr_float fstop);


    /** @brief Set the number of aperture blades
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  camera      The camera to set aperture blades for
    *  @param  num_blades  Number of aperture blades 4 to 32
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetApertureBlades(rpr_camera camera, rpr_uint num_blades);


    /** @brief Set the exposure of a camera
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  camera    The camera to set aperture blades for
    *  @param  exposure  Represents a time length in the same time scale than rprShapeSetMotionTransform,rprCameraSetMotionTransform...
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetExposure(rpr_camera camera, rpr_float exposure);


    /** @brief Set camera mode
    *
    *  Camera modes include:
    *      RPR_CAMERA_MODE_PERSPECTIVE
    *      RPR_CAMERA_MODE_ORTHOGRAPHIC
    *      RPR_CAMERA_MODE_LATITUDE_LONGITUDE_360
    *      RPR_CAMERA_MODE_LATITUDE_LONGITUDE_STEREO
    *      RPR_CAMERA_MODE_CUBEMAP
    *      RPR_CAMERA_MODE_CUBEMAP_STEREO
    *      RPR_CAMERA_MODE_FISHEYE
    *
    *  @param  camera  The camera to set mode for
    *  @param  mode    Camera mode, default is RPR_CAMERA_MODE_PERSPECTIVE
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetMode(rpr_camera camera, rpr_camera_mode mode);


    /** @brief Set orthographic view volume width
    *
    *  @param  camera  The camera to set volume width for
    *  @param  width   View volume width in meters, default is 1 meter
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetOrthoWidth(rpr_camera camera, rpr_float width);
extern RPR_API_ENTRY rpr_status rprCameraSetFocalTilt(rpr_camera camera, rpr_float tilt);
extern RPR_API_ENTRY rpr_status rprCameraSetIPD(rpr_camera camera, rpr_float ipd);
extern RPR_API_ENTRY rpr_status rprCameraSetLensShift(rpr_camera camera, rpr_float shiftx, rpr_float shifty);
extern RPR_API_ENTRY rpr_status rprCameraSetTiltCorrection(rpr_camera camera, rpr_float tiltX, rpr_float tiltY);


    /** @brief Set orthographic view volume height
    *
    *  @param  camera  The camera to set volume height for
    *  @param  width   View volume height in meters, default is 1 meter
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetOrthoHeight(rpr_camera camera, rpr_float height);


    /** @brief Set near plane of a camear
    *
    *  @param  camera  The camera to set near plane for
    *  @param  near   Near plane distance in meters, default is 0.01f
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetNearPlane(rpr_camera camera, rpr_float near);


    /** @brief Set the post scale of camera ( 2D camera zoom )
    *
    *  @param  camera  The camera to set
    *  @param  scale   post scale value.
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetPostScale(rpr_camera camera, rpr_float scale);


    /** @brief Set far plane of a camear
    *
    *  @param  camera  The camera to set far plane for
    *  @param  far   Far plane distance in meters, default is 100000000.f
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCameraSetFarPlane(rpr_camera camera, rpr_float far);

/* rpr_image*/
    /** @brief Query information about an image
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  image       An image object to query
    *  @param  image_info  The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprImageGetInfo(rpr_image image, rpr_image_info image_info, size_t size, void * data, size_t * size_ret);


    /** @brief
    * 
    * this is DEPRECATED in the Northstar plugin.
    * In this plugin, the wrapping is done inside the RPR_MATERIAL_NODE_IMAGE_TEXTURE owning the image, 
    * example: rprMaterialNodeSetInputUByKey(materialNodeTexture, RPR_MATERIAL_INPUT_WRAP_U, RPR_IMAGE_WRAP_TYPE_REPEAT);
    *
    *  @param  image       The image to set wrap for
    *  @param  type
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprImageSetWrap(rpr_image image, rpr_image_wrap_type type);


    /** @brief
    * 
    * ( Northstar-only feature )
    * By default, images are compressed by the Northstar renderer.
    * Setting 'compressionEnabled'=0 will disable the compression for the images.
    * For better performance, it's advised to only disable it for textures that need it.
    *
    */
  extern RPR_API_ENTRY rpr_status rprImageSetInternalCompression(rpr_image image, rpr_uint compressionEnabled);


    /** @brief Set the OCIO Color Space
    *
    */
  extern RPR_API_ENTRY rpr_status rprImageSetOcioColorspace(rpr_image image, rpr_char const * ocioColorspace);


    /** @brief  Set a tile to an UDIM image.
    *
    *  @param  imageUdimRoot   must be an UDIM image  ( created with no data:  rprContextCreateImage(context, {0,RPR_COMPONENT_TYPE_UINT8}, nullptr, nullptr, ); )
    *  @param  tileIndex       a valid UDIM index: 1001 , 1002, 1003 ... 1011, 1012, 1013 ... etc ...
    *  @param  imageTile       a valid classic rpr_image
    */
  extern RPR_API_ENTRY rpr_status rprImageSetUDIM(rpr_image imageUdimRoot, rpr_uint tileIndex, rpr_image imageTile);


    /** @brief
    *
    *
    *  @param  image       The image to set filter for
    *  @param  type
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprImageSetFilter(rpr_image image, rpr_image_filter_type type);

/** @brief
*
*  @param  image       The image to set gamma for
*  @param  type
*  @return             RPR_SUCCESS in case of success, error code otherwise
*/extern RPR_API_ENTRY rpr_status rprImageSetGamma(rpr_image image, rpr_float type);

/** @brief
*
*  @param  image       The image to set mipmap for
*  @param  enabled     true (enable) or false (disable)
*  @return             RPR_SUCCESS in case of success, error code otherwise
*/extern RPR_API_ENTRY rpr_status rprImageSetMipmapEnabled(rpr_image image, rpr_bool enabled);

/* rpr_shape */
    /** @brief Set shape world transform
    *
    *
    *  @param  shape       The shape to set transform for
    *  @param  transpose   Determines whether the basis vectors are in columns(false) or in rows(true) of the matrix
    *  @param  transform   Array of 16 rpr_float values (row-major form)
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetTransform(rpr_shape shape, rpr_bool transpose, rpr_float const * transform);


    /** @brief assign custom float value to some vertices of the mesh
    *
    * example : 
    *   // indicesSet and values must have the same size
    *   rpr_int indicesSet[] = {4,0,1,2,3};
    *   rpr_float values[] = { 0.8 , 0.1 , 0.0 , 1.0 , 1.0 };
    *   rprShapeSetVertexValue(meshC, 0 , indicesSet , values , sizeof(indicesSet)/sizeof(indicesSet[0]) );
    *   
    *  setIndex can be between  0 and 3  :  we can assign up to 4 floats for each vertex.
    *
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVertexValue(rpr_shape in_shape, rpr_int setIndex, rpr_int const * indices, rpr_float const * values, rpr_int indicesCount);


    /* @brief set primvars data for a specific 'key'
    * 
    * A shape can have several primvars data. Each primvar of the shape is identified with a 'key'
    * 'data' is a list of float
    * 'floatCount' is a number of float in the 'data' buffer
    * 'componentCount' specifies the number of float(s) per component.  For example if you want to attach an RGB color to vertices, you need 'componentCount'=3  and  'floatCount' = 3 * 'number of vertices'
    * 'interop' defines how the data is interpolated.
    * 
    * @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetPrimvar(rpr_shape in_shape, rpr_uint key, rpr_float const * data, rpr_uint floatCount, rpr_uint componentCount, rpr_primvar_interpolation_type  interop);


    /** @brief Set shape subdivision
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  factor	   Number of subdivision steps to do
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionFactor(rpr_shape shape, rpr_uint factor);


    /** @brief Enable or Disable the auto ratio cap for subdivision
    *
    * autoRatioCap is a value from 0.0 to 1.0.
    * autoRatioCap=1.0 means very large polygons, less tessellation. as it goes to 0.0, it does more tessellation.
    * This value is ratio of the largest edge in the screen.
    * Example: If you want to make an edge 10 pixels on 1080p, you need to set 10/1080.
    *
    *  @param  shape           The shape to set
    *  @param  autoRatioCap    0.0 to 1.0
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionAutoRatioCap(rpr_shape shape, rpr_float autoRatioCap);


    /** @brief
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  factor
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionCreaseWeight(rpr_shape shape, rpr_float factor);


    /** @brief
    *
    *  @param  shape               The shape to set 
    *  @param  renderLayerString   Render layer name to attach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeAttachRenderLayer(rpr_shape shape, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  shape               The shape to set 
    *  @param  renderLayerString   Render layer name to detach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeDetachRenderLayer(rpr_shape shape, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  light               The light to set 
    *  @param  renderLayerString   Render layer name to attach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightAttachRenderLayer(rpr_light light, rpr_char const * renderLayerString);


    /** @brief
    *
    *  @param  light               The light to set 
    *  @param  renderLayerString   Render layer name to detach
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightDetachRenderLayer(rpr_light light, rpr_char const * renderLayerString);


    /** @brief
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  type
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetSubdivisionBoundaryInterop(rpr_shape shape, rpr_subdiv_boundary_interfop_type type);


    /** @brief Call this function to automatically set the Subdivision Factor depending on the camera position, frame buffer size.
    *          You can retrieve the internally computed factor with rprShapeGetInfo(...,RPR_SHAPE_SUBDIVISION_FACTOR,...)
    *          You have to call this function each time you want to re-adapt the Subdivision Factor :
    *          internally the factor will NOT be automatically re-computed when camera/shape/framebuffer changes.
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  framebuffer frame buffer used for factor adaptation
    *  @param  camera      camera used for factor adaptation
    *  @param  factor      factor to regulate the intensity of adaptation
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeAutoAdaptSubdivisionFactor(rpr_shape shape, rpr_framebuffer framebuffer, rpr_camera camera, rpr_int factor);


    /** @brief Set displacement scale
    *
    *
    *  @param  shape       The shape to set subdivision for
    *  @param  scale	   The amount of displacement applied
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetDisplacementScale(rpr_shape shape, rpr_float minscale, rpr_float maxscale);


    /** @brief Set object group ID (mainly for debugging).
    *
    *
    *  @param  shape          The shape to set
    *  @param  objectGroupID  The ID
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetObjectGroupID(rpr_shape shape, rpr_uint objectGroupID);


    /** @brief Set object ID (mainly for debugging).
    *
    *
    *  @param  shape          The shape to set
    *  @param  objectID       The ID
    *  @return                RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetObjectID(rpr_shape shape, rpr_uint objectID);


    /** @brief Set light group ID when shape has an emissive material (mainly for debugging).
    *
    *  @param  shape          The shape to set
    *  @param  lightGroupID  The ID
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetLightGroupID(rpr_shape shape, rpr_uint lightGroupID);


    /** @brief Set object rendering layer mask
    *          then, use   rprContextSetParameter1u(context,"renderLayerMask",mask)
    *          in order to render only a group of shape
    *
    *  @param  shape       The shape to set
    *  @param  layerMask   The render mask
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    *
    * WARNING: this function is deprecated and will be removed in the future, 
    *          use   rprShapeAttachRenderLayer/rprShapeDetachRenderLayer   and   rprContextAttachRenderLayer/rprContextDetachRenderLayer   instead
    *
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetLayerMask(rpr_shape shape, rpr_uint layerMask);


    /** @brief Set displacement texture
    *
    *
    *  @param  shape         The shape to set subdivision for
    *  @param  materialNode  Displacement texture , as material.
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetDisplacementMaterial(rpr_shape shape, rpr_material_node materialNode);


    /** @brief Set shape material
    *
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMaterial(rpr_shape shape, rpr_material_node node);


    /** @brief Set shape materials for specific faces
    *
    *  @param  shape	The shape to set the material for
    *  @param  node 	The material to set
    *  @param  face_indices
    *  @return		RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMaterialFaces(rpr_shape shape, rpr_material_node node, rpr_int const * face_indices, size_t num_faces);





    /** @brief Set shape volume material
    *
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVolumeMaterial(rpr_shape shape, rpr_material_node node);


    /* Number of motion matrices (set with rprShapeSetMotionTransform) to use.
    *  Set  transformCount=0  if you don't use Motion.
    *  For the moment, if you use motion in Northstar, only transformCount=1 is supported.
    *  example: to create a motion from matA to matB:
    *      rprShapeSetTransform(shape, false, matA) // matrix at time=0
    *      rprShapeSetMotionTransform(shape, false, matB, 1) // matrix at time=1
    *      rprShapeSetMotionTransformCount(shape,1) // use 1 motion matrix
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMotionTransformCount(rpr_shape shape, rpr_uint transformCount);


    /* For Motion effect, set the transform of shape at different time index.
    * 'transform' is an array of 16 rpr_float values (row-major form).
    *  timeIndex=1 is shape position at camera exposure = 1.0
    *  For the moment, in Nortstar plugin only timeIndex=1 is implemented
    *  You also have to call  rprShapeSetMotionTransformCount, to define the number of indices to use.
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetMotionTransform(rpr_shape shape, rpr_bool transpose, rpr_float const * transform, rpr_uint timeIndex);


    /** @brief Set visibility flag
    *
    *  @param  shape           The shape to set visibility for
    *  @param  visibilityFlag   . one of the visibility flags :
    *                             RPR_SHAPE_VISIBILITY_PRIMARY_ONLY_FLAG
    *                             RPR_SHAPE_VISIBILITY_SHADOW
    *                             RPR_SHAPE_VISIBILITY_REFLECTION
    *                             RPR_SHAPE_VISIBILITY_REFRACTION
    *                             RPR_SHAPE_VISIBILITY_TRANSPARENT
    *                             RPR_SHAPE_VISIBILITY_DIFFUSE
    *                             RPR_SHAPE_VISIBILITY_GLOSSY_REFLECTION
    *                             RPR_SHAPE_VISIBILITY_GLOSSY_REFRACTION
    *                             RPR_SHAPE_VISIBILITY_LIGHT
    *                             RPR_SHAPE_VISIBILITY_RECEIVE_SHADOW
    *  @param  visible          set the flag to TRUE or FALSE
    *  @return                  RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVisibilityFlag(rpr_shape shape, rpr_shape_info visibilityFlag, rpr_bool visible);


    /** @brief Set visibility flag
    *
    *  @param  curve           The curve to set visibility for
    *  @param  visibilityFlag   . one of the visibility flags :
    *                             RPR_CURVE_VISIBILITY_PRIMARY_ONLY_FLAG
    *                             RPR_CURVE_VISIBILITY_SHADOW
    *                             RPR_CURVE_VISIBILITY_REFLECTION
    *                             RPR_CURVE_VISIBILITY_REFRACTION
    *                             RPR_CURVE_VISIBILITY_TRANSPARENT
    *                             RPR_CURVE_VISIBILITY_DIFFUSE
    *                             RPR_CURVE_VISIBILITY_GLOSSY_REFLECTION
    *                             RPR_CURVE_VISIBILITY_GLOSSY_REFRACTION
    *                             RPR_CURVE_VISIBILITY_LIGHT
    *                             RPR_CURVE_VISIBILITY_RECEIVE_SHADOW
    *  @param  visible          set the flag to TRUE or FALSE
    *  @return                  RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCurveSetVisibilityFlag(rpr_curve curve, rpr_curve_parameter visibilityFlag, rpr_bool visible);


    /** @brief Set visibility flag
    *
    * This function sets all RPR_SHAPE_VISIBILITY_* flags to the 'visible' argument value
    * Calling rprShapeSetVisibilityFlag(xxx,visible); on each flags would lead to the same result.
    *
    *  @param  shape       The shape to set visibility for
    *  @param  visible     Determines if the shape is visible or not
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVisibility(rpr_shape shape, rpr_bool visible);


    /** @brief Set visibility flag for Light
    *
    *  @param  light           The light to set visibility for
    *  @param  visibilityFlag     one of the visibility flags :
    *                            - RPR_LIGHT_VISIBILITY_LIGHT
    *  @param  visible          set the flag to TRUE or FALSE
    *  @return                  RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightSetVisibilityFlag(rpr_light light, rpr_light_info visibilityFlag, rpr_bool visible);


    /** @brief Set visibility flag
    *
    * This function sets all RPR_CURVE_VISIBILITY_* flags to the 'visible' argument value
    * Calling rprCurveSetVisibilityFlag(xxx,visible); on each flags would lead to the same result.
    *
    *  @param  curve       The curve to set visibility for
    *  @param  visible     Determines if the curve is visible or not
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCurveSetVisibility(rpr_curve curve, rpr_bool visible);


    /** @brief Set visibility flag for specular refleacted\refracted rays
    *
    * This function sets both RPR_SHAPE_VISIBILITY_REFLECTION and RPR_SHAPE_VISIBILITY_REFRACTION flags to the 'visible' argument value
    * Calling rprShapeSetVisibilityFlag(xxx,visible); on those 2 flags would lead to the same result.
    *
    *  @param  shape       The shape to set visibility for
    *  @param  visible     Determines if the shape is visible or not
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetVisibilityInSpecular(rpr_shape shape, rpr_bool visible);


    /** @brief Set shadow catcher flag
    *
    *  @param  shape         The shape to set shadow catcher flag for
    *  @param  shadowCatcher Determines if the shape behaves as shadow catcher
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetShadowCatcher(rpr_shape shape, rpr_bool shadowCatcher);


    /** @brief Set shadow color
    *
    *  @param  shape         The shape to set shadow color for
    *  @param  r             Red component of the color
    *  @param  g             Green component of the color
    *  @param  b             Blue component of the color
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetShadowColor(rpr_shape shape, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set Reflection catcher flag
    *
    *  @param  shape             The shape to set Reflection catcher flag for
    *  @param  reflectionCatcher Determines if the shape behaves as Reflection catcher
    *  @return                   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetReflectionCatcher(rpr_shape shape, rpr_bool reflectionCatcher);


    /** @brief Set 1 if ignore shape in the Contour rendering flag.
    *   ( This flag is used only if Contour is enabled )
    *
    *  @param  shape             The shape to set
    *  @param  ignoreInContour   0 or 1.
    *  @return                   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetContourIgnore(rpr_shape shape, rpr_bool ignoreInContour);


    /** @brief Set 1 if the shape should be treated as an environment light (finite sphere environment light).
    *
    *  @param  shape             The shape to set
    *  @param  envLight   0 or 1.
    *  @return                   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeSetEnvironmentLight(rpr_shape shape, rpr_bool envLight);


      /**
      * Sets static flag on shape.
      *
      * Setting such flag will result in marking object as static.
      * Such objects can be processed more efficiently but with some restrictions:
      * @li Static object can't change its properties.
      * @li Static object can't change its transformation.
      *
      * @note Static flag can be set only before first call to rprContextRender.
      * By default all objects created as dynamic.
      *
      * @param in_shape shape to set flag on
      * @param in_is_static is object static or not
      */
  extern RPR_API_ENTRY rpr_status rprShapeMarkStatic(rpr_shape in_shape, rpr_bool in_is_static);


    /** @brief Set light world transform
    *
    *
    *  @param  light       The light to set transform for
    *  @param  transpose   Determines whether the basis vectors are in columns(false) or in rows(true) of the matrix
    *  @param  transform   Array of 16 rpr_float values (row-major form)
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightSetTransform(rpr_light light, rpr_bool transpose, rpr_float const * transform);


    /** @brief Set light group ID. This parameter can be used with RPR_AOV_LIGHT_GROUP0, RPR_AOV_LIGHT_GROUP1, ...
    *
    *  @param  light       The light to set transform for
    *  @param  groupId     -1 to remove the group.  or a value between 0 and 3.
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightSetGroupId(rpr_light light, rpr_uint groupId);


    /** @brief Query information about a shape
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape           The shape object to query
    *  @param  material_info   The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprShapeGetInfo(rpr_shape arg0, rpr_shape_info arg1, size_t arg2, void * arg3, size_t * arg4);

/* rpr_shape - mesh */
    /** @brief Query information about a mesh
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape       The mesh to query
    *  @param  mesh_info   The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprMeshGetInfo(rpr_shape mesh, rpr_mesh_info mesh_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a Curve
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape       The Curve to query
    *  @param  rpr_curve_parameter   The type of info to query
    *  @param  size        The size of the buffer pointed by data
    *  @param  data        The buffer to store queried info
    *  @param  size_ret    Returns the size in bytes of the data being queried
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprCurveGetInfo(rpr_curve curve, rpr_curve_parameter curve_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a hetero volume
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  heteroVol       The heteroVolume to query
    *  @param  heteroVol_info  The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprHeteroVolumeGetInfo(rpr_hetero_volume heteroVol, rpr_hetero_volume_parameter heteroVol_info, size_t size, void * data, size_t * size_ret);
extern RPR_API_ENTRY rpr_status rprGridGetInfo(rpr_grid grid, rpr_grid_parameter grid_info, size_t size, void * data, size_t * size_ret);


    /** @brief Query information about a Buffer
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  buffer       The heteroVolume to query
    *  @param  buffer_info  The type of info to query
    *  @param  size            The size of the buffer pointed by data
    *  @param  data            The buffer to store queried info
    *  @param  size_ret        Returns the size in bytes of the data being queried
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprBufferGetInfo(rpr_buffer buffer, rpr_buffer_info buffer_info, size_t size, void * data, size_t * size_ret);


    /** @brief Get the parent shape for an instance
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  shape    The shape to get a parent shape from
    *  @param  status   RPR_SUCCESS in case of success, error code otherwise
    *  @return          Shape object
    */
  extern RPR_API_ENTRY rpr_status rprInstanceGetBaseShape(rpr_shape shape, rpr_shape * out_shape);

/* rpr_light - point */
    /** @brief Create point light
    *
    *  Create analytic point light represented by a point in space.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreatePointLight(rpr_context context, rpr_light * out_light);


    /** @brief Set radiant power of a point light source
    *
    *  @param  r       R component of a radiant power vector
    *  @param  g       G component of a radiant power vector
    *  @param  b       B component of a radiant power vector
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprPointLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);

/* rpr_light - spot */
    /** @brief Create spot light
    *
    *  Create analytic spot light
    *
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateSpotLight(rpr_context context, rpr_light * light);
extern RPR_API_ENTRY rpr_status rprContextCreateSphereLight(rpr_context context, rpr_light * light);
extern RPR_API_ENTRY rpr_status rprContextCreateDiskLight(rpr_context context, rpr_light * light);


    /** @brief Set radiant power of a spot light source
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSpotLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief turn this spot-light into a textured light.
    *
    * 'img' can be NULL to disable textured.
    */
  extern RPR_API_ENTRY rpr_status rprSpotLightSetImage(rpr_light light, rpr_image img);


    /** @brief Set Power for Sphere Light
    *
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSphereLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set Radius for Sphere Light
    *
    *
    *  @param radius  Radius to set
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSphereLightSetRadius(rpr_light light, rpr_float radius);


    /** @brief Set Power for Disk Light
    *
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set Radius for Disk Light
    *
    *
    *  @param radius  Radius to set
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetRadius(rpr_light light, rpr_float radius);


    /** @brief Set Outer Angle for Disk Light
    *
    *
    *  @param  angle Outer angle in radians
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetAngle(rpr_light light, rpr_float angle);


    /** @brief Set Inner Angle for Disk Light
    *
    *  @param  innerAngle Inner angle in radians
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDiskLightSetInnerAngle(rpr_light light, rpr_float innerAngle);


    /** @brief Set cone shape for a spot light
    *
    * Spot light produces smooth penumbra in a region between inner and outer circles,
    * the area inside the inner cicrle receives full power while the area outside the
    * outer one is fully in shadow.
    *
    *  @param  iangle Inner angle of a cone in radians
    *  @param  oangle Outer angle of a coner in radians, should be greater that or equal to inner angle
    *  @return status RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSpotLightSetConeShape(rpr_light light, rpr_float iangle, rpr_float oangle);

/* rpr_light - directional */
    /** @brief Create directional light
    *
    *  Create analytic directional light.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return light id of a newly created light
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateDirectionalLight(rpr_context context, rpr_light * out_light);


    /** @brief Set radiant power of a directional light source
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDirectionalLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set softness of shadow produced by the light
    *
    *  @param  softnessAngle  (in Radian)  value should be between [ 0 ; pi/4 ]. 0.0 means sharp shadow
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprDirectionalLightSetShadowSoftnessAngle(rpr_light light, rpr_float softnessAngle);

/* rpr_light - environment */
    /** @brief Create an environment light
    *
    *  Environment light is a light based on lightprobe.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateEnvironmentLight(rpr_context context, rpr_light * out_light);


    /** @brief Set image for an environment light
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT
    *
    *  @param  env_light Environment light
    *  @param  image     Image object to set
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightSetImage(rpr_light env_light, rpr_image image);


    /** @brief Set intensity scale or an env light
    *
    *  @param  env_light       Environment light
    *  @param  intensity_scale Intensity scale
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightSetIntensityScale(rpr_light env_light, rpr_float intensity_scale);


    /** @brief Set portal for environment light to accelerate convergence of indoor scenes
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  env_light Environment light
    *  @param  portal    Portal mesh, might have multiple components
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightAttachPortal(rpr_scene scene, rpr_light env_light, rpr_shape portal);


    /** @brief Remove portal for environment light.
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  env_light Environment light
    *  @param  portal    Portal mesh, that have been added to light.
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightDetachPortal(rpr_scene scene, rpr_light env_light, rpr_shape portal);


      /**
      * Sets/Gets environment override on IBL
      *
      * This function sets overrides for different parts of IBL.
      * overrideType argument can take following values:
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFLECTION
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_REFRACTION
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_TRANSPARENCY
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_BACKGROUND
      * @li RPR_ENVIRONMENT_LIGHT_OVERRIDE_IRRADIANCE
      *
      * @param in_ibl image based light created with rprContextCreateEnvironmentLight
      * @param overrideType override parameter
      * @param in_iblOverride image based light created with rprContextCreateEnvironmentLight
      */
  extern RPR_API_ENTRY rpr_status rprEnvironmentLightSetEnvironmentLightOverride(rpr_light in_ibl, rpr_environment_override overrideType, rpr_light in_iblOverride);
extern RPR_API_ENTRY rpr_status rprEnvironmentLightGetEnvironmentLightOverride(rpr_light in_ibl, rpr_environment_override overrideType, rpr_light* out_iblOverride);

/* rpr_light - sky */
    /** @brief Create sky light
    *
    *  Analytical sky model
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateSkyLight(rpr_context context, rpr_light * out_light);


    /** @brief Set turbidity of a sky light
    *
    *  @param  skylight        Sky light
    *  @param  turbidity       Turbidity value
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetTurbidity(rpr_light skylight, rpr_float turbidity);


    /** @brief Set albedo of a sky light
    *
    *  @param  skylight        Sky light
    *  @param  albedo          Albedo value
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetAlbedo(rpr_light skylight, rpr_float albedo);


    /** @brief Set scale of a sky light
    *
    *  @param  skylight        Sky light
    *  @param  scale           Scale value
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetScale(rpr_light skylight, rpr_float scale);


    /** @brief Set the direction of the sky light
    *
    *  @param  skylight        Sky light
    *  @param  x               direction x
    *  @param  y               direction y
    *  @param  z               direction z
    *  @return                 RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightSetDirection(rpr_light skylight, rpr_float x, rpr_float y, rpr_float z);


    /** @brief Set portal for sky light to accelerate convergence of indoor scenes
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  skylight  Sky light
    *  @param  portal    Portal mesh, might have multiple components
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightAttachPortal(rpr_scene scene, rpr_light skylight, rpr_shape portal);


    /** @brief Remove portal for Sky light.
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  env_light Sky light
    *  @param  portal    Portal mesh, that have been added to light.
    *  @return           RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSkyLightDetachPortal(rpr_scene scene, rpr_light skylight, rpr_shape portal);


    /** @brief Create IES light
    *
    *  Create IES light
    *
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreateIESLight(rpr_context context, rpr_light * light);


    /** @brief Set radiant power of a IES light source
    *
    *  @param  r R component of a radiant power vector
    *  @param  g G component of a radiant power vector
    *  @param  b B component of a radiant power vector
    *  @return   RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprIESLightSetRadiantPower3f(rpr_light light, rpr_float r, rpr_float g, rpr_float b);


    /** @brief Set image for an IES light
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT : If the format of the IES file is not supported by Radeon ProRender.
    *      RPR_ERROR_IO_ERROR : If the IES image path file doesn't exist.
    *
    *  @param  env_light     Environment light
    *  @param  imagePath     Image path to set (for UNICODE, supports UTF-8 encoding)
    *  @param  nx			  resolution X of the IES image
    *  @param  ny            resolution Y of the IES image
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprIESLightSetImageFromFile(rpr_light env_light, rpr_char const * imagePath, rpr_int nx, rpr_int ny);


    /** @brief Set image for an IES light
    *
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *      RPR_ERROR_UNSUPPORTED_IMAGE_FORMAT : If the format of the IES data is not supported by Radeon ProRender.
    *
    *  @param  env_light     Environment light
    *  @param  iesData       Image data string defining the IES. null terminated string. IES format.
    *  @param  nx			  resolution X of the IES image
    *  @param  ny            resolution Y of the IES image
    *  @return               RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprIESLightSetImageFromIESdata(rpr_light env_light, rpr_char const * iesData, rpr_int nx, rpr_int ny);

/* rpr_light */
    /** @brief Query information about a light
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  light    The light to query
    *  @param  light_info The type of info to query
    *  @param  size     The size of the buffer pointed by data
    *  @param  data     The buffer to store queried info
    *  @param  size_ret Returns the size in bytes of the data being queried
    *  @return          RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprLightGetInfo(rpr_light light, rpr_light_info info, size_t size, void * data, size_t * size_ret);

/* rpr_scene */
    /** @brief Remove all objects from a scene
    *          Also detaches the camera
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene   The scene to clear
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneClear(rpr_scene scene);


    /** @brief Attach a shape to the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene  The scene to attach
    *  @param  shape  The shape to attach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneAttachShape(rpr_scene scene, rpr_shape shape);


    /** @brief Detach a shape from the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene   The scene to dettach from
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneDetachShape(rpr_scene scene, rpr_shape shape);


    /** @brief Attach a heteroVolume to the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene  The scene to attach
    *  @param  heteroVolume  The heteroVolume to attach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneAttachHeteroVolume(rpr_scene scene, rpr_hetero_volume heteroVolume);


    /** @brief Detach a heteroVolume from the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions.
    *
    *  @param  scene   The scene to dettach from
    *  @return         RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneDetachHeteroVolume(rpr_scene scene, rpr_hetero_volume heteroVolume);
extern RPR_API_ENTRY rpr_status rprSceneAttachCurve(rpr_scene scene, rpr_curve curve);
extern RPR_API_ENTRY rpr_status rprSceneDetachCurve(rpr_scene scene, rpr_curve curve);
extern RPR_API_ENTRY rpr_status rprCurveSetMaterial(rpr_curve curve, rpr_material_node material);
extern RPR_API_ENTRY rpr_status rprCurveSetTransform(rpr_curve curve, rpr_bool transpose, rpr_float const * transform);


/** @brief Create a set of curves
*
*  A rpr_curve is a set of curves
*  A curve is a set of segments
*  A segment is always composed of 4 3D points
*
*  @param controlPointsData  array of rpr_float[num_controlPoints*3]
*
*  @param controlPointsStride  in most of cases, for contiguous controlPointsData, should be set to 3*sizeof(float)
*
*  @param num_indices  should be set at : 4*(number of segments)
*
*  @param indicesData  array of rpr_uint[num_indices] .
*                      those are indices to the controlPointsData array.
*
*  @param radius  array of N float. 
*                 if curve is not tapered, N = curveCount.
*                 if curve is tapered, N = 2*(number of segments)
*
*  @param textureUV   array of float2[curveCount]. 
*
*  @param segmentPerCurve   array of rpr_int[curveCount]. 
*                           (number of segments) = sum of each element of this array.
*
*  @param  creationFlag_tapered  Set it to 0 by default.
*                                Set to 1 if using tapered radius.
*                                May be used for other bit field options in the future (so, don't set it to a value > 1 for now.)
*
*/
extern RPR_API_ENTRY rpr_status rprContextCreateCurve(rpr_context context, rpr_curve * out_curve, size_t num_controlPoints, rpr_float const * controlPointsData, rpr_int controlPointsStride, size_t num_indices, rpr_uint curveCount, rpr_uint const * indicesData, rpr_float const * radius, rpr_float const * textureUV, rpr_int const * segmentPerCurve, rpr_uint creationFlag_tapered);


    /** @brief Attach a light to the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions
    *
    *  @param  scene  The scene to attach
    *  @param  light  The light to attach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneAttachLight(rpr_scene scene, rpr_light light);


    /** @brief Detach a light from the scene
    *
    *  A scene is essentially a collection of shapes, lights and volume regions
    *
    *  @param  scene  The scene to dettach from
    *  @param  light  The light to detach
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneDetachLight(rpr_scene scene, rpr_light light);


      /**
      * Sets/gets environment override as active in scene
      *
      * @param in_scene scene
      * @param in_light ibl
      */
  extern RPR_API_ENTRY rpr_status rprSceneSetEnvironmentLight(rpr_scene in_scene, rpr_light in_light);
extern RPR_API_ENTRY rpr_status rprSceneGetEnvironmentLight(rpr_scene in_scene, rpr_light* out_light);


    /** @brief Query information about a scene
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  scene    The scene to query
    *  @param  info     The type of info to query
    *  @param  size     The size of the buffer pointed by data
    *  @param  data     The buffer to store queried info
    *  @param  size_ret Returns the size in bytes of the data being queried
    *  @return          RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetInfo(rpr_scene scene, rpr_scene_info info, size_t size, void * data, size_t * size_ret);


    /** @brief Set background image for the scene which does not affect the scene lighting,
    *    it is shown as view-independent rectangular background
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  scene  The scene to set background for
    *  @param  image  Background image
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneSetBackgroundImage(rpr_scene scene, rpr_image image);


    /** @brief Get background image
    *
    *  @param  scene  The scene to get background image from
    *  @param  status RPR_SUCCESS in case of success, error code otherwise
    *  @return        Image object
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetBackgroundImage(rpr_scene scene, rpr_image * out_image);


    /** @brief Set right camera for the scene
    *
    *  This is the main camera which for rays generation for the scene.
    *
    *  @param  scene  The scene to set camera for
    *  @param  camera Camera
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneSetCameraRight(rpr_scene scene, rpr_camera camera);


    /** @brief Get right camera for the scene
    *
    *  @param  scene  The scene to get camera for
    *  @param  status RPR_SUCCESS in case of success, error code otherwise
    *  @return camera id for the camera if any, NULL otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetCameraRight(rpr_scene scene, rpr_camera * out_camera);


    /** @brief Set camera for the scene
    *
    *  This is the main camera which for rays generation for the scene.
    *
    *  @param  scene  The scene to set camera for
    *  @param  camera Camera
    *  @return        RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneSetCamera(rpr_scene scene, rpr_camera camera);


    /** @brief Get camera for the scene
    *
    *  @param  scene  The scene to get camera for
    *  @param  status RPR_SUCCESS in case of success, error code otherwise
    *  @return camera id for the camera if any, NULL otherwise
    */
  extern RPR_API_ENTRY rpr_status rprSceneGetCamera(rpr_scene scene, rpr_camera * out_camera);


    /** @brief Query information about a framebuffer
    *
    *  The workflow is usually two-step: query with the data == NULL to get the required buffer size,
    *  then query with size_ret == NULL to fill the buffer with the data
    *   Possible error codes:
    *      RPR_ERROR_INVALID_PARAMETER
    *
    *  @param  framebuffer  Framebuffer object to query
    *  @param  info         The type of info to query
    *  @param  size         The size of the buffer pointed by data
    *  @param  data         The buffer to store queried info
    *  @param  size_ret     Returns the size in bytes of the data being queried
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferGetInfo(rpr_framebuffer framebuffer, rpr_framebuffer_info info, size_t size, void * data, size_t * size_ret);


    /** @brief Clear contents of a framebuffer to zero
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  The call is blocking and the image is ready when returned
    *
    *  @param  frame_buffer  Framebuffer to clear
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferClear(rpr_framebuffer frame_buffer);


    /** @brief Fill contents of a framebuffer with a single color
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  The call is blocking and the image is ready when returned.
    *  If you want to fill with zeros, it's advised to use rprFrameBufferClear.
    *
    *  @param  frame_buffer  Framebuffer to clear
    *  @param r,g,b,a : the color to fill
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferFillWithColor(rpr_framebuffer frame_buffer, rpr_float r, rpr_float g, rpr_float b, rpr_float a);


    /** @brief Save frame buffer to file. In case the file format is .bin, the header of the saved file contains
    * rpr_framebuffer_desc and rpr_framebuffer_format at very begining. The remaining data is raw data of saved framebuffer.
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    *  @param  frame_buffer Frame buffer to save
    *  @param  file_path    Path to file (for UNICODE, supports UTF-8 encoding)
    *  @return              RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferSaveToFile(rpr_framebuffer frame_buffer, rpr_char const * file_path);


    /** @brief Save frame buffer to file
    *
    *  Same that rprFrameBufferSaveToFile, but more options.
    *  A list of frambuffers can be given, they will be saved to a multilayer EXR.
    *
    *  'extraOptions' is not used for now, but may be use in the future to define some export options, like channel configurations, compression...
    *                 It must be set to NULL for now.
    *
    *  For layer names, the framebuffer names ( from rprObjectSetName ) will be used if it exists.
    *
    *  As this function is new ( 2.01.6 SDK ) and still experimental, its arguments may change in the future.
    */
  extern RPR_API_ENTRY rpr_status rprFrameBufferSaveToFileEx(rpr_framebuffer * framebufferList, rpr_uint framebufferCount, rpr_char const * filePath, void const * extraOptions);


    /** @brief Resolve framebuffer
    *
    * Convert the input Renderer's native raw format 'src_frame_buffer' into an output 'dst_frame_buffer' that can be used for final rendering.
    *
    * src_frame_buffer and dst_frame_buffer should usually have the same dimension/format.
    * src_frame_buffer is the result of a rprContextRender and should be attached to an AOV with rprContextSetAOV before the rprContextRender call.
    * dst_frame_buffer should not be attached to any AOV.
    *
    * The post process that is applied to src_frame_buffer depends on the AOV it's attached to. So it's important to not modify its AOV ( with rprContextSetAOV )
    * between the rprContextRender and rprContextResolveFrameBuffer calls.
    *
    * If noDisplayGamma=FALSE, then RPR_CONTEXT_DISPLAY_GAMMA is applied to the dst_frame_buffer otherwise, display gamma is not used.
    * It's recommended to set it to FALSE for AOVs representing colors ( like RPR_AOV_COLOR ) and use TRUE for other AOVs.
    *
    */
  extern RPR_API_ENTRY rpr_status rprContextResolveFrameBuffer(rpr_context context, rpr_framebuffer src_frame_buffer, rpr_framebuffer dst_frame_buffer, rpr_bool noDisplayGamma);


    /** @brief Create material system
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialSystemGetInfo(rpr_material_system in_material_system, rpr_material_system_info type, size_t in_size, void * in_data, size_t * out_size);


      /** @brief Get material system information
      *
      *   Possible error codes:
      *      RPR_ERROR_INTERNAL_ERROR
      *
      */
  extern RPR_API_ENTRY rpr_status rprContextCreateMaterialSystem(rpr_context in_context, rpr_material_system_type type, rpr_material_system * out_matsys);


    /** @brief Create material node
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialSystemGetSize(rpr_context in_context, rpr_uint * out_size);


    /** @brief Returns the number of material nodes for a given material system
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialSystemCreateNode(rpr_material_system in_matsys, rpr_material_node_type in_type, rpr_material_node * out_node);


    /** @brief set the RPR_MATERIAL_NODE_ID of a material.
    *   this ID doesn't need to be unique.
    *   this ID can be rendered with the RPR_AOV_MATERIAL_ID AOV - color of this AOV can be customized with rprContextSetAOVindexLookup.
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetID(rpr_material_node in_node, rpr_uint id);


    /** @brief Connect nodes
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputNByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_material_node in_input_node);


    /** @brief Set float input value
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputFByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_float in_value_x, rpr_float in_value_y, rpr_float in_value_z, rpr_float in_value_w);


    /** @brief Set generic data input value: Some complex materials inputs may need more than 4-floats or int.
    *  This API can be used to set any generic input data.
    *  Use it only when documentation requests to do it for specific material inputs.
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, void const * data, size_t dataSizeByte);


    /** @brief Set uint input value
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputUByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_uint in_value);


    /** @brief Set image input value
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputImageDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_image image);


    /** @brief Set light input value
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputLightDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_light light);


    /** @brief Set Buffer input value
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputBufferDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_buffer buffer);


    /** @brief Set Grid input value
    *
    */
  extern RPR_API_ENTRY rpr_status rprMaterialNodeSetInputGridDataByKey(rpr_material_node in_node, rpr_material_node_input in_input, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprMaterialNodeGetInfo(rpr_material_node in_node, rpr_material_node_info in_info, size_t in_size, void * in_data, size_t * out_size);
extern RPR_API_ENTRY rpr_status rprMaterialNodeGetInputInfo(rpr_material_node in_node, rpr_int in_input_idx, rpr_material_node_input_info in_info, size_t in_size, void * in_data, size_t * out_size);
extern RPR_API_ENTRY rpr_status rprContextCreateComposite(rpr_context context, rpr_composite_type in_type, rpr_composite * out_composite);
extern RPR_API_ENTRY rpr_status rprContextCreateLUTFromFile(rpr_context context, const rpr_char * fileLutPath, rpr_lut * out_lut);
extern RPR_API_ENTRY rpr_status rprContextCreateLUTFromData(rpr_context context, const rpr_char * lutData, rpr_lut * out_lut);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputFb(rpr_composite composite, const rpr_char * inputName, rpr_framebuffer input);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputC(rpr_composite composite, const rpr_char * inputName, rpr_composite input);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputLUT(rpr_composite composite, const rpr_char * inputName, rpr_lut input);
extern RPR_API_ENTRY rpr_status rprCompositeSetInput4f(rpr_composite composite, const rpr_char * inputName, float x, float y, float z, float w);
extern RPR_API_ENTRY rpr_status rprCompositeSetInput1u(rpr_composite composite, const rpr_char * inputName, rpr_uint value);
extern RPR_API_ENTRY rpr_status rprCompositeSetInputOp(rpr_composite composite, const rpr_char * inputName, rpr_material_node_arithmetic_operation op);
extern RPR_API_ENTRY rpr_status rprCompositeCompute(rpr_composite composite, rpr_framebuffer fb);
extern RPR_API_ENTRY rpr_status rprCompositeGetInfo(rpr_composite composite, rpr_composite_info composite_info, size_t size, void *  data, size_t * size_ret);


    /** @brief Delete object
    *
    *  rprObjectDelete(obj) deletes 'obj' from memory.
    *  User has to make sure that 'obj' will not be used anymore after this call.
    *
    *   Possible error codes:
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *
    */
  extern RPR_API_ENTRY rpr_status rprObjectDelete(void * obj);


    /** @brief Set material node name
    *
    *
    *  @param  node        Node to set the name for
    *  @param  name       NULL terminated string name
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprObjectSetName(void * node, rpr_char const * name);


    /** @brief Set a custom pointer to an RPR object ( rpr_shape, rpr_image ... )
    *          The custom pointer is not used internally by RPR. The API user only is responsible of it.
    *          An example of usage of this pointer is the C++ wrapper ( RadeonProRender.hpp )
    *
    *  @param  node        Node to set the 'custom pointer' for
    *  @param  customPtr   Any 8 bytes value decided by the API user.
    *  @return             RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprObjectSetCustomPointer(void * node, void const * customPtr);


    /** @brief   outputs the 'custom pointer' set by rprObjectSetCustomPointer.
    *            Equivalent of the calls :
    *             rprImageGetInfo(image,RPR_IMAGE_CUSTOM_PTR,...) for rpr_image ,
    *             rprCameraGetInfo(camera,RPR_CAMERA_CUSTOM_PTR,...) for rpr_camera ,
    *             ...etc...
    *
    *  @return      RPR_SUCCESS in case of success, error code otherwise
    */
  extern RPR_API_ENTRY rpr_status rprObjectGetCustomPointer(void * node, void const ** customPtr_out);

/* rpr_post_effect */
    /** @brief Create post effect
    *
    *  Create analytic point light represented by a point in space.
    *  Possible error codes:
    *      RPR_ERROR_OUT_OF_VIDEO_MEMORY
    *      RPR_ERROR_OUT_OF_SYSTEM_MEMORY
    *
    *  @param  context The context to create a light for
    *  @param  status  RPR_SUCCESS in case of success, error code otherwise
    *  @return         Light object
    */
  extern RPR_API_ENTRY rpr_status rprContextCreatePostEffect(rpr_context context, rpr_post_effect_type type, rpr_post_effect * out_effect);
extern RPR_API_ENTRY rpr_status rprContextAttachPostEffect(rpr_context context, rpr_post_effect effect);
extern RPR_API_ENTRY rpr_status rprContextDetachPostEffect(rpr_context context, rpr_post_effect effect);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter1u(rpr_post_effect effect, rpr_char const * name, rpr_uint x);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter1f(rpr_post_effect effect, rpr_char const * name, rpr_float x);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter3f(rpr_post_effect effect, rpr_char const * name, rpr_float x, rpr_float y, rpr_float z);
extern RPR_API_ENTRY rpr_status rprPostEffectSetParameter4f(rpr_post_effect effect, rpr_char const * name, rpr_float x, rpr_float y, rpr_float z, rpr_float w);
extern RPR_API_ENTRY rpr_status rprContextGetAttachedPostEffectCount(rpr_context context, rpr_uint *  nb);
extern RPR_API_ENTRY rpr_status rprContextGetAttachedPostEffect(rpr_context context, rpr_uint i, rpr_post_effect * out_effect);
extern RPR_API_ENTRY rpr_status rprPostEffectGetInfo(rpr_post_effect effect, rpr_post_effect_info info, size_t size,  void *  data, size_t *  size_ret);
extern RPR_API_ENTRY rpr_status rprContextCreateGrid(rpr_context context, rpr_grid * out_grid, size_t gridSizeX, size_t gridSizeY, size_t gridSizeZ, void const * indicesList, size_t numberOfIndices, rpr_grid_indices_topology indicesListTopology, void const * gridData, size_t gridDataSizeByte, rpr_uint gridDataTopology___unused);
extern RPR_API_ENTRY rpr_status rprContextCreateHeteroVolume(rpr_context context, rpr_hetero_volume * out_heteroVolume);
extern RPR_API_ENTRY rpr_status rprShapeSetHeteroVolume(rpr_shape shape, rpr_hetero_volume heteroVolume);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetTransform(rpr_hetero_volume heteroVolume, rpr_bool transpose, rpr_float const * transform);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetEmissionGrid(rpr_hetero_volume heteroVolume, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetDensityGrid(rpr_hetero_volume heteroVolume, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetAlbedoGrid(rpr_hetero_volume heteroVolume, rpr_grid grid);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetEmissionLookup(rpr_hetero_volume heteroVolume, rpr_float const * ptr, rpr_uint n);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetDensityLookup(rpr_hetero_volume heteroVolume, rpr_float const * ptr, rpr_uint n);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetAlbedoLookup(rpr_hetero_volume heteroVolume, rpr_float const * ptr, rpr_uint n);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetAlbedoScale(rpr_hetero_volume heteroVolume, rpr_float scale);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetEmissionScale(rpr_hetero_volume heteroVolume, rpr_float scale);
extern RPR_API_ENTRY rpr_status rprHeteroVolumeSetDensityScale(rpr_hetero_volume heteroVolume, rpr_float scale);




  #ifdef __cplusplus
}
#endif

#endif  /*__RADEONPRORENDER_H  */

#endif  /* RPR_API_USE_HEADER_V2 */
